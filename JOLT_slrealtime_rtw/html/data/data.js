var dataJson = {"arch":{"ispc":false,"isunix":true,"ismac":false},"build":"JOLT","ref":false,"files":[{"name":"JOLT.cpp","type":"source","group":"model","path":"/home/electro/Code_Repo/n-CORTEx/JOLT_slrealtime_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * JOLT.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"JOLT\".\n *\n * Model version              : 1.375\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Fri Dec  1 17:02:18 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"JOLT.h\"\n#include \"rtwtypes.h\"\n#include \"JOLT_private.h\"\n#include \"JOLT_cal.h\"\n#include <cstring>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#include <cmath>\n\n/* Named constants for MATLAB Function: '<S8>/MATLAB Function4' */\nconst int32_T JOLT_CALL_EVENT = -1;\n\n/* Named constants for MATLAB Function: '<S1>/MATLAB Function' */\nconst int32_T JOLT_CALL_EVENT_l = -1;\nconst real_T JOLT_RGND = 0.0;          /* real_T ground */\n\n/* Block signals (default storage) */\nB_JOLT_T JOLT_B;\n\n/* Block states (default storage) */\nDW_JOLT_T JOLT_DW;\n\n/* Real-time model */\nRT_MODEL_JOLT_T JOLT_M_ = RT_MODEL_JOLT_T();\nRT_MODEL_JOLT_T *const JOLT_M = &JOLT_M_;\n\n/* Forward declaration for local functions */\nstatic void JOLT_nonzeros(const real_T s[8000], real_T v_data[], int32_T *v_size);\nstatic real_T JOLT_blockedSummation(const real_T x_data[], const int32_T *x_size,\n  int32_T vlen);\n\n/*\n * System initialize for atomic system:\n *    '<S8>/MATLAB Function4'\n *    '<S9>/MATLAB Function4'\n */\nvoid JOLT_MATLABFunction4_Init(DW_MATLABFunction4_JOLT_T *localDW)\n{\n  localDW->sfEvent = JOLT_CALL_EVENT;\n  localDW->t0_not_empty = false;\n  localDW->is_active_c7_JOLT = 0U;\n}\n\n/*\n * Output and update for atomic system:\n *    '<S8>/MATLAB Function4'\n *    '<S9>/MATLAB Function4'\n */\nvoid JOLT_MATLABFunction4(real_T rtu_onset_trig, real_T rtu_sigAmp, real_T\n  rtu_sigPulseLen, real_T rtu_t, B_MATLABFunction4_JOLT_T *localB,\n  DW_MATLABFunction4_JOLT_T *localDW)\n{\n  localDW->sfEvent = JOLT_CALL_EVENT;\n  if (rtu_onset_trig != 0.0) {\n    localB->sigPulse = rtu_sigAmp;\n    localDW->t0 = rtu_t;\n    localDW->t0_not_empty = true;\n  } else if (localDW->t0_not_empty) {\n    if (rtu_t - localDW->t0 < rtu_sigPulseLen) {\n      localB->sigPulse = rtu_sigAmp;\n    } else {\n      localB->sigPulse = 0.0;\n    }\n  } else {\n    localB->sigPulse = 0.0;\n  }\n}\n\n/* Function for MATLAB Function: '<Root>/MATLAB Function1' */\nstatic void JOLT_nonzeros(const real_T s[8000], real_T v_data[], int32_T *v_size)\n{\n  int32_T i;\n  i = 0;\n  for (int32_T b_k = 0; b_k < 8000; b_k++) {\n    if (s[b_k] != 0.0) {\n      i++;\n    }\n  }\n\n  *v_size = i;\n  i = -1;\n  for (int32_T b_k = 0; b_k < 8000; b_k++) {\n    real_T s_0;\n    s_0 = s[b_k];\n    if (s_0 != 0.0) {\n      i++;\n      v_data[i] = s_0;\n    }\n  }\n}\n\n/* Function for MATLAB Function: '<Root>/MATLAB Function1' */\nstatic real_T JOLT_blockedSummation(const real_T x_data[], const int32_T *x_size,\n  int32_T vlen)\n{\n  real_T y;\n  if ((*x_size == 0) || (vlen == 0)) {\n    y = 0.0;\n  } else {\n    int32_T firstBlockLength;\n    int32_T lastBlockLength;\n    int32_T nblocks;\n    int32_T xblockoffset;\n    if (vlen <= 1024) {\n      firstBlockLength = vlen;\n      lastBlockLength = 0;\n      nblocks = 1;\n    } else {\n      firstBlockLength = 1024;\n      nblocks = static_cast<uint16_T>(vlen) >> 10;\n      lastBlockLength = vlen - (nblocks << 10);\n      if (lastBlockLength > 0) {\n        nblocks++;\n      } else {\n        lastBlockLength = 1024;\n      }\n    }\n\n    y = x_data[0];\n    for (xblockoffset = 2; xblockoffset <= firstBlockLength; xblockoffset++) {\n      y += x_data[xblockoffset - 1];\n    }\n\n    for (firstBlockLength = 2; firstBlockLength <= nblocks; firstBlockLength++)\n    {\n      real_T bsum;\n      int32_T hi;\n      xblockoffset = (firstBlockLength - 1) << 10;\n      bsum = x_data[xblockoffset];\n      if (firstBlockLength == nblocks) {\n        hi = lastBlockLength;\n      } else {\n        hi = 1024;\n      }\n\n      for (int32_T b_k = 2; b_k <= hi; b_k++) {\n        bsum += x_data[(xblockoffset + b_k) - 1];\n      }\n\n      y += bsum;\n    }\n  }\n\n  return y;\n}\n\nreal_T rt_roundd_snf(real_T u)\n{\n  real_T y;\n  if (std::abs(u) < 4.503599627370496E+15) {\n    if (u >= 0.5) {\n      y = std::floor(u + 0.5);\n    } else if (u > -0.5) {\n      y = u * 0.0;\n    } else {\n      y = std::ceil(u - 0.5);\n    }\n  } else {\n    y = u;\n  }\n\n  return y;\n}\n\n/* Model step function */\nvoid JOLT_step(void)\n{\n  real_T v_data[10];\n  real_T absdiff;\n  real_T baseAvg;\n  real_T scale;\n  real_T t;\n  real_T xbar;\n  int32_T b;\n  int32_T i;\n  int32_T x_size;\n  uint8_T tmp;\n  boolean_T result;\n\n  /* Memory: '<Root>/Memory2' */\n  std::memcpy(&JOLT_B.Memory2[0], &JOLT_DW.Memory2_PreviousInput[0], 8000U *\n              sizeof(real_T));\n\n  /* S-Function (sg_IO191_setup_s): '<Root>/Setup ' */\n\n  /* Level2 S-Function Block: '<Root>/Setup ' (sg_IO191_setup_s) */\n  {\n    SimStruct *rts = JOLT_M->childSfunctions[0];\n    sfcnOutputs(rts,0);\n  }\n\n  /* S-Function (slrealtimeTCPServer): '<Root>/TCP Server' incorporates:\n   *  Constant: '<Root>/Constant'\n   */\n  {\n    try {\n      int enable = (int)JOLT_cal->Constant_Value;\n      slrealtime::ip::tcp::Server* server = reinterpret_cast<slrealtime::ip::tcp::\n        Server*>(JOLT_DW.TCPServer_PWORK);\n      bool connected = server->connected();\n      if (enable <= 0) {\n        if (connected)\n          server->reset();\n        connected = false;\n      } else {\n        if (!connected)\n          server->connect();\n      }\n\n      connected = server->connected();\n      JOLT_B.TCPServer = (double)connected;\n    } catch (std::exception& e) {\n      std::string tmp = std::string(e.what());\n      static std::string eMsg = tmp;\n      rtmSetErrorStatus(JOLT_M, eMsg.c_str());\n      rtmSetStopRequested(JOLT_M, 1);\n      ;\n    }\n  }\n\n  /* S-Function (slrealtimeTCPReceive): '<Root>/TCP Receive' */\n  {\n    try {\n      int status = 0;\n      size_t bytesReceived = 0;\n      int outportWidth = (int)JOLT_DW.TCPReceive_IWORK;\n      char *rcvBuf = (char *)JOLT_DW.TCPReceive_PWORK[1];\n      int enable = (int)JOLT_B.TCPServer;\n      slrealtime::ip::tcp::Socket* sock = reinterpret_cast<slrealtime::ip::tcp::\n        Socket*>(JOLT_DW.TCPReceive_PWORK[0]);\n      if (!sock)\n        return;\n      memset(rcvBuf, 0, outportWidth);\n      if (enable > 0) {\n        bytesReceived = sock->receive(rcvBuf, outportWidth);\n      }\n\n      JOLT_B.TCPReceive_o2 = (double)bytesReceived;\n      void *dataPort = &JOLT_B.buttonStat;\n      if (bytesReceived>0) {\n        memcpy(dataPort,(void*)rcvBuf,outportWidth);\n      }\n    } catch (std::exception& e) {\n      std::string tmp = std::string(e.what());\n      static std::string eMsg = tmp;\n      rtmSetErrorStatus(JOLT_M, eMsg.c_str());\n      rtmSetStopRequested(JOLT_M, 1);\n      ;\n    }\n  }\n\n  /* Memory: '<Root>/Memory1' */\n  JOLT_B.Memory1 = JOLT_DW.Memory1_PreviousInput;\n\n  /* MATLAB Function: '<Root>/MATLAB Function1' incorporates:\n   *  Memory: '<Root>/Memory2'\n   */\n  JOLT_DW.sfEvent_d = JOLT_CALL_EVENT_l;\n  switch (static_cast<int32_T>(JOLT_B.Memory1)) {\n   case 0:\n    switch (JOLT_B.buttonStat) {\n     case 1U:\n      JOLT_B.npxlsAcq_out = 0.0;\n      JOLT_B.acqStatus = 1.0;\n      JOLT_B.S_out = 1.0;\n      JOLT_B.restingAcq = 0.0;\n      break;\n\n     case 2U:\n      JOLT_B.npxlsAcq_out = 0.0;\n      JOLT_B.acqStatus = 2.0;\n      JOLT_B.S_out = JOLT_B.Memory1;\n      JOLT_B.restingAcq = 0.0;\n      break;\n\n     case 3U:\n      JOLT_B.npxlsAcq_out = 0.0;\n      JOLT_B.acqStatus = 3.0;\n      JOLT_B.S_out = JOLT_B.Memory1;\n      JOLT_B.restingAcq = 0.0;\n      break;\n\n     case 4U:\n      JOLT_B.acqStatus = 4.0;\n      JOLT_B.restingAcq = 0.0;\n      JOLT_B.npxlsAcq_out = 2.5;\n      JOLT_B.S_out = 0.0;\n      break;\n\n     default:\n      JOLT_B.acqStatus = 0.0;\n      JOLT_B.S_out = JOLT_B.Memory1;\n      JOLT_B.npxlsAcq_out = 0.0;\n      JOLT_B.restingAcq = 0.0;\n      break;\n    }\n\n    JOLT_B.acqTone_trig = 0.0;\n    JOLT_B.npxlsAcq_trig = 0.0;\n    baseAvg = 0.0;\n    scale = 0.0;\n    JOLT_B.baseBuffLen = 0.0;\n    JOLT_B.stimSig_sel = 0.0;\n    std::memset(&JOLT_B.monofilBaseBuffer_out[0], 0, 8000U * sizeof(real_T));\n    break;\n\n   case 1:\n    JOLT_B.acqStatus = 0.0;\n    JOLT_B.acqTone_trig = 0.0;\n    JOLT_B.npxlsAcq_out = 0.0;\n    JOLT_B.npxlsAcq_trig = 0.0;\n    JOLT_B.restingAcq = 0.0;\n    JOLT_B.stimSig_sel = 0.0;\n    JOLT_B.S_out = 1.0;\n    std::memcpy(&JOLT_B.monofilBaseBuffer_out[0], &JOLT_B.Memory2[0], 8000U *\n                sizeof(real_T));\n    JOLT_B.baseBuffLen = 8000.0;\n    JOLT_nonzeros(&JOLT_B.Memory2[0], JOLT_B.x_data, &x_size);\n    baseAvg = JOLT_blockedSummation(JOLT_B.x_data, &x_size, x_size) /\n      static_cast<real_T>(x_size);\n    JOLT_nonzeros(&JOLT_B.Memory2[0], JOLT_B.x_data, &x_size);\n    if (x_size == 0) {\n      xbar = (rtNaN);\n    } else if (x_size == 1) {\n      if ((!rtIsInf(JOLT_B.x_data[0])) && (!rtIsNaN(JOLT_B.x_data[0]))) {\n        xbar = 0.0;\n      } else {\n        xbar = (rtNaN);\n      }\n    } else {\n      xbar = JOLT_blockedSummation(JOLT_B.x_data, &x_size, x_size) /\n        static_cast<real_T>(x_size);\n      b = x_size;\n      for (i = 0; i < b; i++) {\n        JOLT_B.absdiff_data[i] = std::abs(JOLT_B.x_data[i] - xbar);\n      }\n\n      xbar = 0.0;\n      scale = 3.3121686421112381E-170;\n      i = x_size;\n      for (b = 0; b < i; b++) {\n        absdiff = JOLT_B.absdiff_data[b];\n        if (absdiff > scale) {\n          t = scale / absdiff;\n          xbar = xbar * t * t + 1.0;\n          scale = absdiff;\n        } else {\n          t = absdiff / scale;\n          xbar += t * t;\n        }\n      }\n\n      xbar = scale * std::sqrt(xbar);\n      xbar /= std::sqrt(static_cast<real_T>(x_size) - 1.0);\n    }\n\n    i = 0;\n    for (b = 0; b < 10; b++) {\n      if (JOLT_B.Memory2[b + 7990] != 0.0) {\n        i++;\n      }\n    }\n\n    x_size = i;\n    i = -1;\n    for (b = 0; b < 10; b++) {\n      scale = JOLT_B.Memory2[b + 7990];\n      if (scale != 0.0) {\n        i++;\n        v_data[i] = scale;\n      }\n    }\n\n    scale = JOLT_blockedSummation(v_data, &x_size, x_size) / static_cast<real_T>\n      (x_size);\n    if (scale > 2.8 * xbar + baseAvg) {\n      JOLT_B.stimSig_sel = 1.0;\n      JOLT_B.S_out = 2.0;\n    }\n    break;\n\n   case 2:\n    std::memcpy(&JOLT_B.monofilBaseBuffer_out[0], &JOLT_B.Memory2[0], 8000U *\n                sizeof(real_T));\n    JOLT_B.baseBuffLen = 0.0;\n    baseAvg = 0.0;\n    scale = 0.0;\n    JOLT_B.acqStatus = 0.0;\n    JOLT_B.restingAcq = 1.0;\n    JOLT_B.stimSig_sel = 0.0;\n    JOLT_B.npxlsAcq_out = 0.0;\n    JOLT_B.npxlsAcq_trig = 1.0;\n    JOLT_B.acqTone_trig = 1.0;\n    JOLT_B.S_out = 0.0;\n    break;\n\n   default:\n    std::memcpy(&JOLT_B.monofilBaseBuffer_out[0], &JOLT_B.Memory2[0], 8000U *\n                sizeof(real_T));\n    JOLT_B.baseBuffLen = 0.0;\n    baseAvg = 0.0;\n    scale = 0.0;\n    JOLT_B.S_out = 0.0;\n    JOLT_B.acqStatus = 0.0;\n    JOLT_B.stimSig_sel = 0.0;\n    JOLT_B.acqTone_trig = 0.0;\n    JOLT_B.npxlsAcq_out = 0.0;\n    JOLT_B.npxlsAcq_trig = 0.0;\n    JOLT_B.restingAcq = 1.0;\n    break;\n  }\n\n  JOLT_B.baseAvg = baseAvg;\n  JOLT_B.changeAvg = scale;\n\n  /* End of MATLAB Function: '<Root>/MATLAB Function1' */\n\n  /* DiscretePulseGenerator: '<Root>/Npxls Trig' */\n  baseAvg = JOLT_cal->T_npxls / 2.0;\n\n  /* DiscretePulseGenerator: '<Root>/Npxls Trig' */\n  JOLT_B.npxls_trig = (JOLT_DW.clockTickCounter < baseAvg) &&\n    (JOLT_DW.clockTickCounter >= 0) ? JOLT_cal->NpxlsTrig_Amp : 0.0;\n\n  /* DiscretePulseGenerator: '<Root>/Npxls Trig' */\n  if (JOLT_DW.clockTickCounter >= JOLT_cal->T_npxls - 1.0) {\n    JOLT_DW.clockTickCounter = 0;\n  } else {\n    JOLT_DW.clockTickCounter++;\n  }\n\n  /* Clock: '<S6>/Clock' */\n  JOLT_B.Clock = JOLT_M->Timing.t[0];\n\n  /* MATLAB Function: '<S6>/MATLAB Function4' incorporates:\n   *  Constant: '<S6>/Constant'\n   *  Constant: '<S6>/Constant1'\n   */\n  JOLT_DW.sfEvent_k = JOLT_CALL_EVENT_l;\n  if (JOLT_B.npxlsAcq_trig != 0.0) {\n    JOLT_B.sigPulse_p = JOLT_cal->Constant_Value_c;\n    JOLT_DW.t0_b = JOLT_B.Clock;\n    JOLT_DW.t0_not_empty_p = true;\n  } else if (JOLT_DW.t0_not_empty_p) {\n    if (JOLT_B.Clock - JOLT_DW.t0_b < JOLT_cal->Constant1_Value) {\n      JOLT_B.sigPulse_p = JOLT_cal->Constant_Value_c;\n    } else {\n      JOLT_B.sigPulse_p = 0.0;\n    }\n  } else {\n    JOLT_B.sigPulse_p = 0.0;\n  }\n\n  /* End of MATLAB Function: '<S6>/MATLAB Function4' */\n\n  /* Clock: '<S8>/Clock' */\n  JOLT_B.Clock_p = JOLT_M->Timing.t[0];\n\n  /* MATLAB Function: '<S8>/MATLAB Function4' incorporates:\n   *  Constant: '<S8>/Constant'\n   *  Constant: '<S8>/Constant1'\n   */\n  JOLT_MATLABFunction4(JOLT_B.restingAcq, JOLT_cal->Constant_Value_a,\n                       JOLT_cal->Constant1_Value_p, JOLT_B.Clock_p,\n                       &JOLT_B.sf_MATLABFunction4_d,\n                       &JOLT_DW.sf_MATLABFunction4_d);\n\n  /* MATLAB Function: '<S3>/MATLAB Function' */\n  JOLT_DW.sfEvent_e = JOLT_CALL_EVENT_l;\n  switch (static_cast<int32_T>(JOLT_B.sf_MATLABFunction4_d.sigPulse)) {\n   case 1:\n    JOLT_B.out_c = JOLT_B.sigPulse_p;\n    break;\n\n   case 0:\n    JOLT_B.out_c = JOLT_B.npxlsAcq_out;\n    break;\n\n   default:\n    JOLT_B.out_c = 0.0;\n    break;\n  }\n\n  /* End of MATLAB Function: '<S3>/MATLAB Function' */\n\n  /* Clock: '<S7>/Clock' */\n  JOLT_B.Clock_j = JOLT_M->Timing.t[0];\n\n  /* MATLAB Function: '<S7>/MATLAB Function4' incorporates:\n   *  Constant: '<S7>/Constant'\n   *  Constant: '<S7>/Constant1'\n   */\n  JOLT_DW.sfEvent = JOLT_CALL_EVENT_l;\n  if (JOLT_B.acqTone_trig != 0.0) {\n    JOLT_B.sigPulse = JOLT_cal->Constant_Value_j;\n    JOLT_DW.t0 = JOLT_B.Clock_j;\n    JOLT_DW.t0_not_empty = true;\n  } else if (JOLT_DW.t0_not_empty) {\n    if (JOLT_B.Clock_j - JOLT_DW.t0 < JOLT_cal->Constant1_Value_k) {\n      JOLT_B.sigPulse = JOLT_cal->Constant_Value_j;\n    } else {\n      JOLT_B.sigPulse = 0.0;\n    }\n  } else {\n    JOLT_B.sigPulse = 0.0;\n  }\n\n  /* End of MATLAB Function: '<S7>/MATLAB Function4' */\n\n  /* S-Function (sg_IO191_do_s): '<Root>/Digital output ' */\n\n  /* Level2 S-Function Block: '<Root>/Digital output ' (sg_IO191_do_s) */\n  {\n    SimStruct *rts = JOLT_M->childSfunctions[1];\n    sfcnOutputs(rts,0);\n  }\n\n  /* S-Function (sg_IO191_ad_s): '<Root>/Analog input ' */\n\n  /* Level2 S-Function Block: '<Root>/Analog input ' (sg_IO191_ad_s) */\n  {\n    SimStruct *rts = JOLT_M->childSfunctions[2];\n    sfcnOutputs(rts,0);\n  }\n\n  /* Product: '<Root>/Product' incorporates:\n   *  Constant: '<Root>/Constant5'\n   */\n  JOLT_B.Product = JOLT_B.stim_raw * JOLT_cal->Constant5_Value;\n\n  /* DiscreteFilter: '<Root>/Discrete Filter' */\n  baseAvg = JOLT_B.Product;\n  baseAvg /= JOLT_cal->DiscreteFilter_DenCoef;\n  JOLT_DW.DiscreteFilter_tmp = baseAvg;\n  baseAvg = JOLT_cal->DiscreteFilter_NumCoef[0] * JOLT_DW.DiscreteFilter_tmp;\n  i = 1;\n  for (b = 0; b < 500; b++) {\n    baseAvg += JOLT_cal->DiscreteFilter_NumCoef[i] *\n      JOLT_DW.DiscreteFilter_states[b];\n    i++;\n  }\n\n  /* DiscreteFilter: '<Root>/Discrete Filter' */\n  JOLT_B.stim_filt = baseAvg;\n\n  /* MATLAB Function: '<S1>/MATLAB Function' */\n  JOLT_DW.sfEvent_c = JOLT_CALL_EVENT_l;\n  std::memcpy(&JOLT_B.buffOut[0], &JOLT_B.monofilBaseBuffer_out[1], 7999U *\n              sizeof(real_T));\n  JOLT_B.buffOut[7999] = JOLT_B.stim_filt;\n\n  /* Sum: '<S10>/Add1' incorporates:\n   *  Constant: '<S10>/Constant1'\n   */\n  JOLT_B.Add1 = JOLT_cal->Constant1_Value_d + JOLT_B.stim_filt;\n\n  /* Product: '<S10>/Product' incorporates:\n   *  Constant: '<S10>/Constant2'\n   */\n  JOLT_B.Product_o = JOLT_cal->Constant2_Value * JOLT_B.Add1;\n\n  /* DataTypeConversion: '<S10>/Data Type Conversion' */\n  baseAvg = std::ceil(JOLT_B.Product_o);\n  if (rtIsNaN(baseAvg) || rtIsInf(baseAvg)) {\n    baseAvg = 0.0;\n  } else {\n    baseAvg = std::fmod(baseAvg, 256.0);\n  }\n\n  /* DataTypeConversion: '<S10>/Data Type Conversion' */\n  JOLT_B.convertedMonofil = static_cast<uint8_T>(baseAvg < 0.0 ?\n    static_cast<int32_T>(static_cast<uint8_T>(-static_cast<int8_T>\n    (static_cast<uint8_T>(-baseAvg)))) : static_cast<int32_T>\n    (static_cast<uint8_T>(baseAvg)));\n\n  /* Sum: '<S10>/Add' incorporates:\n   *  Constant: '<S10>/Constant5'\n   */\n  JOLT_B.Add = JOLT_cal->Constant5_Value_k + static_cast<real_T>\n    (JOLT_B.convertedMonofil);\n\n  /* Delay: '<Root>/Delay' */\n  JOLT_B.npxlsAcqCutoff = JOLT_DW.Delay_DSTATE[0];\n\n  /* Clock: '<S9>/Clock' */\n  JOLT_B.Clock_a = JOLT_M->Timing.t[0];\n\n  /* MATLAB Function: '<S9>/MATLAB Function4' incorporates:\n   *  Constant: '<S9>/Constant'\n   *  Constant: '<S9>/Constant1'\n   */\n  JOLT_MATLABFunction4(JOLT_B.stimSig_sel, JOLT_cal->Constant_Value_n,\n                       JOLT_cal->Constant1_Value_bz, JOLT_B.Clock_a,\n                       &JOLT_B.sf_MATLABFunction4_h,\n                       &JOLT_DW.sf_MATLABFunction4_h);\n\n  /* MATLAB Function: '<S5>/MATLAB Function' incorporates:\n   *  Constant: '<Root>/Constant1'\n   */\n  JOLT_DW.sfEvent_m = JOLT_CALL_EVENT_l;\n  switch (static_cast<int32_T>(JOLT_B.sf_MATLABFunction4_h.sigPulse)) {\n   case 1:\n    JOLT_B.out = JOLT_cal->Constant1_Value_b;\n    break;\n\n   case 0:\n    JOLT_B.out = JOLT_B.npxlsAcqCutoff;\n    break;\n\n   default:\n    JOLT_B.out = 0.0;\n    break;\n  }\n\n  /* End of MATLAB Function: '<S5>/MATLAB Function' */\n\n  /* MATLAB Function: '<S4>/MATLAB Function' incorporates:\n   *  Constant: '<Root>/Constant2'\n   *  Constant: '<Root>/Constant4'\n   */\n  JOLT_DW.sfEvent_p = JOLT_CALL_EVENT_l;\n  result = (JOLT_B.out == 0.0);\n  if (result) {\n    i = 0;\n  } else {\n    result = (JOLT_B.out == 2.5);\n    if (result) {\n      i = 1;\n    } else {\n      result = (JOLT_B.out == 2.0);\n      if (result) {\n        i = 2;\n      } else {\n        i = -1;\n      }\n    }\n  }\n\n  switch (i) {\n   case 0:\n    baseAvg = rt_roundd_snf(JOLT_B.Add);\n    if (baseAvg < 256.0) {\n      if (baseAvg >= 0.0) {\n        tmp = static_cast<uint8_T>(baseAvg);\n      } else {\n        tmp = 0U;\n      }\n    } else {\n      tmp = MAX_uint8_T;\n    }\n\n    JOLT_B.out_j = tmp;\n    break;\n\n   case 1:\n    baseAvg = rt_roundd_snf(JOLT_cal->Constant4_Value);\n    if (baseAvg < 256.0) {\n      if (baseAvg >= 0.0) {\n        tmp = static_cast<uint8_T>(baseAvg);\n      } else {\n        tmp = 0U;\n      }\n    } else {\n      tmp = MAX_uint8_T;\n    }\n\n    JOLT_B.out_j = tmp;\n    break;\n\n   case 2:\n    baseAvg = rt_roundd_snf(JOLT_cal->Constant2_Value_c);\n    if (baseAvg < 256.0) {\n      if (baseAvg >= 0.0) {\n        tmp = static_cast<uint8_T>(baseAvg);\n      } else {\n        tmp = 0U;\n      }\n    } else {\n      tmp = MAX_uint8_T;\n    }\n\n    JOLT_B.out_j = tmp;\n    break;\n\n   default:\n    baseAvg = rt_roundd_snf(JOLT_cal->Constant4_Value);\n    if (baseAvg < 256.0) {\n      if (baseAvg >= 0.0) {\n        tmp = static_cast<uint8_T>(baseAvg);\n      } else {\n        tmp = 0U;\n      }\n    } else {\n      tmp = MAX_uint8_T;\n    }\n\n    JOLT_B.out_j = tmp;\n    break;\n  }\n\n  /* End of MATLAB Function: '<S4>/MATLAB Function' */\n  /* S-Function (slrealtimeTCPSend): '<Root>/TCP Send' incorporates:\n   *  Constant: '<Root>/Constant3'\n   */\n  {\n    try {\n      size_t bytesSent = 0;\n      int enable = (int)JOLT_B.TCPServer;\n      char *sendBuf = (char *)&JOLT_B.out_j;\n      size_t bytesToSend = (size_t)JOLT_cal->Constant3_Value;\n      slrealtime::ip::tcp::Socket* sock = reinterpret_cast<slrealtime::ip::tcp::\n        Socket*>(JOLT_DW.TCPSend_PWORK);\n      if (!sock)\n        return;\n      if (enable > 0) {\n        bytesSent = sock->send(sendBuf, bytesToSend);\n        JOLT_B.TCPSend = (double)bytesSent;\n      }\n    } catch (std::exception& e) {\n      std::string tmp = std::string(e.what());\n      static std::string eMsg = tmp;\n      rtmSetErrorStatus(JOLT_M, eMsg.c_str());\n      rtmSetStopRequested(JOLT_M, 1);\n      ;\n    }\n  }\n\n  /* S-Function (sg_IO191_di_s): '<Root>/Digital input ' */\n\n  /* Level2 S-Function Block: '<Root>/Digital input ' (sg_IO191_di_s) */\n  {\n    SimStruct *rts = JOLT_M->childSfunctions[3];\n    sfcnOutputs(rts,0);\n  }\n\n  /* RateTransition generated from: '<Root>/Digital input ' */\n  JOLT_B.HiddenRateTransitionForToWks_In = JOLT_B.PulseGen1Hz;\n\n  /* Update for Memory: '<Root>/Memory2' */\n  std::memcpy(&JOLT_DW.Memory2_PreviousInput[0], &JOLT_B.buffOut[0], 8000U *\n              sizeof(real_T));\n\n  /* Update for Memory: '<Root>/Memory1' */\n  JOLT_DW.Memory1_PreviousInput = JOLT_B.S_out;\n\n  /* Update for DiscreteFilter: '<Root>/Discrete Filter' */\n  for (int32_T i = 0; i < 499; i++) {\n    JOLT_DW.DiscreteFilter_states[499 - i] = JOLT_DW.DiscreteFilter_states[498 -\n      i];\n  }\n\n  JOLT_DW.DiscreteFilter_states[0] = JOLT_DW.DiscreteFilter_tmp;\n\n  /* End of Update for DiscreteFilter: '<Root>/Discrete Filter' */\n\n  /* Update for Delay: '<Root>/Delay' */\n  for (int32_T i = 0; i < 699; i++) {\n    JOLT_DW.Delay_DSTATE[i] = JOLT_DW.Delay_DSTATE[i + 1];\n  }\n\n  JOLT_DW.Delay_DSTATE[699] = JOLT_B.sigPulse_p;\n\n  /* End of Update for Delay: '<Root>/Delay' */\n\n  /* Update absolute time for base rate */\n  /* The \"clockTick0\" counts the number of times the code of this task has\n   * been executed. The absolute time is the multiplication of \"clockTick0\"\n   * and \"Timing.stepSize0\". Size of \"clockTick0\" ensures timer will not\n   * overflow during the application lifespan selected.\n   * Timer of this task consists of two 32 bit unsigned integers.\n   * The two integers represent the low bits Timing.clockTick0 and the high bits\n   * Timing.clockTickH0. When the low bit overflows to 0, the high bits increment.\n   */\n  if (!(++JOLT_M->Timing.clockTick0)) {\n    ++JOLT_M->Timing.clockTickH0;\n  }\n\n  JOLT_M->Timing.t[0] = JOLT_M->Timing.clockTick0 * JOLT_M->Timing.stepSize0 +\n    JOLT_M->Timing.clockTickH0 * JOLT_M->Timing.stepSize0 * 4294967296.0;\n\n  {\n    /* Update absolute timer for sample time: [0.001s, 0.0s] */\n    /* The \"clockTick1\" counts the number of times the code of this task has\n     * been executed. The absolute time is the multiplication of \"clockTick1\"\n     * and \"Timing.stepSize1\". Size of \"clockTick1\" ensures timer will not\n     * overflow during the application lifespan selected.\n     * Timer of this task consists of two 32 bit unsigned integers.\n     * The two integers represent the low bits Timing.clockTick1 and the high bits\n     * Timing.clockTickH1. When the low bit overflows to 0, the high bits increment.\n     */\n    if (!(++JOLT_M->Timing.clockTick1)) {\n      ++JOLT_M->Timing.clockTickH1;\n    }\n\n    JOLT_M->Timing.t[1] = JOLT_M->Timing.clockTick1 * JOLT_M->Timing.stepSize1 +\n      JOLT_M->Timing.clockTickH1 * JOLT_M->Timing.stepSize1 * 4294967296.0;\n  }\n}\n\n/* Model initialize function */\nvoid JOLT_initialize(void)\n{\n  /* Registration code */\n\n  /* initialize non-finites */\n  rt_InitInfAndNaN(sizeof(real_T));\n\n  {\n    /* Setup solver object */\n    rtsiSetSimTimeStepPtr(&JOLT_M->solverInfo, &JOLT_M->Timing.simTimeStep);\n    rtsiSetTPtr(&JOLT_M->solverInfo, &rtmGetTPtr(JOLT_M));\n    rtsiSetStepSizePtr(&JOLT_M->solverInfo, &JOLT_M->Timing.stepSize0);\n    rtsiSetErrorStatusPtr(&JOLT_M->solverInfo, (&rtmGetErrorStatus(JOLT_M)));\n    rtsiSetRTModelPtr(&JOLT_M->solverInfo, JOLT_M);\n  }\n\n  rtsiSetSimTimeStep(&JOLT_M->solverInfo, MAJOR_TIME_STEP);\n  rtsiSetSolverName(&JOLT_M->solverInfo,\"FixedStepDiscrete\");\n  JOLT_M->solverInfoPtr = (&JOLT_M->solverInfo);\n\n  /* Initialize timing info */\n  {\n    int_T *mdlTsMap = JOLT_M->Timing.sampleTimeTaskIDArray;\n    mdlTsMap[0] = 0;\n    mdlTsMap[1] = 1;\n\n    /* polyspace +2 MISRA2012:D4.1 [Justified:Low] \"JOLT_M points to\n       static memory which is guaranteed to be non-NULL\" */\n    JOLT_M->Timing.sampleTimeTaskIDPtr = (&mdlTsMap[0]);\n    JOLT_M->Timing.sampleTimes = (&JOLT_M->Timing.sampleTimesArray[0]);\n    JOLT_M->Timing.offsetTimes = (&JOLT_M->Timing.offsetTimesArray[0]);\n\n    /* task periods */\n    JOLT_M->Timing.sampleTimes[0] = (0.0);\n    JOLT_M->Timing.sampleTimes[1] = (0.001);\n\n    /* task offsets */\n    JOLT_M->Timing.offsetTimes[0] = (0.0);\n    JOLT_M->Timing.offsetTimes[1] = (0.0);\n  }\n\n  rtmSetTPtr(JOLT_M, &JOLT_M->Timing.tArray[0]);\n\n  {\n    int_T *mdlSampleHits = JOLT_M->Timing.sampleHitArray;\n    mdlSampleHits[0] = 1;\n    mdlSampleHits[1] = 1;\n    JOLT_M->Timing.sampleHits = (&mdlSampleHits[0]);\n  }\n\n  rtmSetTFinal(JOLT_M, -1);\n  JOLT_M->Timing.stepSize0 = 0.001;\n  JOLT_M->Timing.stepSize1 = 0.001;\n  JOLT_M->solverInfoPtr = (&JOLT_M->solverInfo);\n  JOLT_M->Timing.stepSize = (0.001);\n  rtsiSetFixedStepSize(&JOLT_M->solverInfo, 0.001);\n  rtsiSetSolverMode(&JOLT_M->solverInfo, SOLVER_MODE_SINGLETASKING);\n\n  /* block I/O */\n  (void) std::memset((static_cast<void *>(&JOLT_B)), 0,\n                     sizeof(B_JOLT_T));\n\n  /* states (dwork) */\n  (void) std::memset(static_cast<void *>(&JOLT_DW), 0,\n                     sizeof(DW_JOLT_T));\n\n  /* child S-Function registration */\n  {\n    RTWSfcnInfo *sfcnInfo = &JOLT_M->NonInlinedSFcns.sfcnInfo;\n    JOLT_M->sfcnInfo = (sfcnInfo);\n    rtssSetErrorStatusPtr(sfcnInfo, (&rtmGetErrorStatus(JOLT_M)));\n    JOLT_M->Sizes.numSampTimes = (2);\n    rtssSetNumRootSampTimesPtr(sfcnInfo, &JOLT_M->Sizes.numSampTimes);\n    JOLT_M->NonInlinedSFcns.taskTimePtrs[0] = (&rtmGetTPtr(JOLT_M)[0]);\n    JOLT_M->NonInlinedSFcns.taskTimePtrs[1] = (&rtmGetTPtr(JOLT_M)[1]);\n    rtssSetTPtrPtr(sfcnInfo,JOLT_M->NonInlinedSFcns.taskTimePtrs);\n    rtssSetTStartPtr(sfcnInfo, &rtmGetTStart(JOLT_M));\n    rtssSetTFinalPtr(sfcnInfo, &rtmGetTFinal(JOLT_M));\n    rtssSetTimeOfLastOutputPtr(sfcnInfo, &rtmGetTimeOfLastOutput(JOLT_M));\n    rtssSetStepSizePtr(sfcnInfo, &JOLT_M->Timing.stepSize);\n    rtssSetStopRequestedPtr(sfcnInfo, &rtmGetStopRequested(JOLT_M));\n    rtssSetDerivCacheNeedsResetPtr(sfcnInfo, &JOLT_M->derivCacheNeedsReset);\n    rtssSetZCCacheNeedsResetPtr(sfcnInfo, &JOLT_M->zCCacheNeedsReset);\n    rtssSetContTimeOutputInconsistentWithStateAtMajorStepPtr(sfcnInfo,\n      &JOLT_M->CTOutputIncnstWithState);\n    rtssSetSampleHitsPtr(sfcnInfo, &JOLT_M->Timing.sampleHits);\n    rtssSetPerTaskSampleHitsPtr(sfcnInfo, &JOLT_M->Timing.perTaskSampleHits);\n    rtssSetSimModePtr(sfcnInfo, &JOLT_M->simMode);\n    rtssSetSolverInfoPtr(sfcnInfo, &JOLT_M->solverInfoPtr);\n  }\n\n  JOLT_M->Sizes.numSFcns = (4);\n\n  /* register each child */\n  {\n    (void) std::memset(static_cast<void *>\n                       (&JOLT_M->NonInlinedSFcns.childSFunctions[0]), 0,\n                       4*sizeof(SimStruct));\n    JOLT_M->childSfunctions = (&JOLT_M->NonInlinedSFcns.childSFunctionPtrs[0]);\n    JOLT_M->childSfunctions[0] = (&JOLT_M->NonInlinedSFcns.childSFunctions[0]);\n    JOLT_M->childSfunctions[1] = (&JOLT_M->NonInlinedSFcns.childSFunctions[1]);\n    JOLT_M->childSfunctions[2] = (&JOLT_M->NonInlinedSFcns.childSFunctions[2]);\n    JOLT_M->childSfunctions[3] = (&JOLT_M->NonInlinedSFcns.childSFunctions[3]);\n\n    /* Level2 S-Function Block: JOLT/<Root>/Setup  (sg_IO191_setup_s) */\n    {\n      SimStruct *rts = JOLT_M->childSfunctions[0];\n\n      /* timing info */\n      time_T *sfcnPeriod = JOLT_M->NonInlinedSFcns.Sfcn0.sfcnPeriod;\n      time_T *sfcnOffset = JOLT_M->NonInlinedSFcns.Sfcn0.sfcnOffset;\n      int_T *sfcnTsMap = JOLT_M->NonInlinedSFcns.Sfcn0.sfcnTsMap;\n      (void) std::memset(static_cast<void*>(sfcnPeriod), 0,\n                         sizeof(time_T)*1);\n      (void) std::memset(static_cast<void*>(sfcnOffset), 0,\n                         sizeof(time_T)*1);\n      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);\n      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);\n      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);\n\n      {\n        ssSetBlkInfo2Ptr(rts, &JOLT_M->NonInlinedSFcns.blkInfo2[0]);\n      }\n\n      _ssSetBlkInfo2PortInfo2Ptr(rts,\n        &JOLT_M->NonInlinedSFcns.inputOutputPortInfo2[0]);\n\n      /* Set up the mdlInfo pointer */\n      ssSetRTWSfcnInfo(rts, JOLT_M->sfcnInfo);\n\n      /* Allocate memory of model methods 2 */\n      {\n        ssSetModelMethods2(rts, &JOLT_M->NonInlinedSFcns.methods2[0]);\n      }\n\n      /* Allocate memory of model methods 3 */\n      {\n        ssSetModelMethods3(rts, &JOLT_M->NonInlinedSFcns.methods3[0]);\n      }\n\n      /* Allocate memory of model methods 4 */\n      {\n        ssSetModelMethods4(rts, &JOLT_M->NonInlinedSFcns.methods4[0]);\n      }\n\n      /* Allocate memory for states auxilliary information */\n      {\n        ssSetStatesInfo2(rts, &JOLT_M->NonInlinedSFcns.statesInfo2[0]);\n        ssSetPeriodicStatesInfo(rts, &JOLT_M->\n          NonInlinedSFcns.periodicStatesInfo[0]);\n      }\n\n      /* path info */\n      ssSetModelName(rts, \"Setup \");\n      ssSetPath(rts, \"JOLT/Setup \");\n      ssSetRTModel(rts,JOLT_M);\n      ssSetParentSS(rts, (NULL));\n      ssSetRootSS(rts, rts);\n      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);\n\n      /* parameters */\n      {\n        mxArray **sfcnParams = (mxArray **)\n          &JOLT_M->NonInlinedSFcns.Sfcn0.params;\n        ssSetSFcnParamsCount(rts, 9);\n        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);\n        ssSetSFcnParam(rts, 0, (mxArray*)JOLT_cal->Setup_P1_Size);\n        ssSetSFcnParam(rts, 1, (mxArray*)JOLT_cal->Setup_P2_Size);\n        ssSetSFcnParam(rts, 2, (mxArray*)JOLT_cal->Setup_P3_Size);\n        ssSetSFcnParam(rts, 3, (mxArray*)JOLT_cal->Setup_P4_Size);\n        ssSetSFcnParam(rts, 4, (mxArray*)JOLT_cal->Setup_P5_Size);\n        ssSetSFcnParam(rts, 5, (mxArray*)JOLT_cal->Setup_P6_Size);\n        ssSetSFcnParam(rts, 6, (mxArray*)JOLT_cal->Setup_P7_Size);\n        ssSetSFcnParam(rts, 7, (mxArray*)JOLT_cal->Setup_P8_Size);\n        ssSetSFcnParam(rts, 8, (mxArray*)JOLT_cal->Setup_P9_Size);\n      }\n\n      /* work vectors */\n      ssSetRWork(rts, (real_T *) &JOLT_DW.Setup_RWORK[0]);\n      ssSetPWork(rts, (void **) &JOLT_DW.Setup_PWORK);\n\n      {\n        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)\n          &JOLT_M->NonInlinedSFcns.Sfcn0.dWork;\n        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)\n          &JOLT_M->NonInlinedSFcns.Sfcn0.dWorkAux;\n        ssSetSFcnDWork(rts, dWorkRecord);\n        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);\n        ssSetNumDWorkAsInt(rts, 2);\n\n        /* RWORK */\n        ssSetDWorkWidthAsInt(rts, 0, 2);\n        ssSetDWorkDataType(rts, 0,SS_DOUBLE);\n        ssSetDWorkComplexSignal(rts, 0, 0);\n        ssSetDWork(rts, 0, &JOLT_DW.Setup_RWORK[0]);\n\n        /* PWORK */\n        ssSetDWorkWidthAsInt(rts, 1, 1);\n        ssSetDWorkDataType(rts, 1,SS_POINTER);\n        ssSetDWorkComplexSignal(rts, 1, 0);\n        ssSetDWork(rts, 1, &JOLT_DW.Setup_PWORK);\n      }\n\n      /* registration */\n      sg_IO191_setup_s(rts);\n      sfcnInitializeSizes(rts);\n      sfcnInitializeSampleTimes(rts);\n\n      /* adjust sample time */\n      ssSetSampleTime(rts, 0, 0.001);\n      ssSetOffsetTime(rts, 0, 0.0);\n      sfcnTsMap[0] = 1;\n\n      /* set compiled values of dynamic vector attributes */\n      ssSetNumNonsampledZCsAsInt(rts, 0);\n\n      /* Update connectivity flags for each port */\n      /* Update the BufferDstPort flags for each input port */\n    }\n\n    /* Level2 S-Function Block: JOLT/<Root>/Digital output  (sg_IO191_do_s) */\n    {\n      SimStruct *rts = JOLT_M->childSfunctions[1];\n\n      /* timing info */\n      time_T *sfcnPeriod = JOLT_M->NonInlinedSFcns.Sfcn1.sfcnPeriod;\n      time_T *sfcnOffset = JOLT_M->NonInlinedSFcns.Sfcn1.sfcnOffset;\n      int_T *sfcnTsMap = JOLT_M->NonInlinedSFcns.Sfcn1.sfcnTsMap;\n      (void) std::memset(static_cast<void*>(sfcnPeriod), 0,\n                         sizeof(time_T)*1);\n      (void) std::memset(static_cast<void*>(sfcnOffset), 0,\n                         sizeof(time_T)*1);\n      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);\n      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);\n      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);\n\n      {\n        ssSetBlkInfo2Ptr(rts, &JOLT_M->NonInlinedSFcns.blkInfo2[1]);\n      }\n\n      _ssSetBlkInfo2PortInfo2Ptr(rts,\n        &JOLT_M->NonInlinedSFcns.inputOutputPortInfo2[1]);\n\n      /* Set up the mdlInfo pointer */\n      ssSetRTWSfcnInfo(rts, JOLT_M->sfcnInfo);\n\n      /* Allocate memory of model methods 2 */\n      {\n        ssSetModelMethods2(rts, &JOLT_M->NonInlinedSFcns.methods2[1]);\n      }\n\n      /* Allocate memory of model methods 3 */\n      {\n        ssSetModelMethods3(rts, &JOLT_M->NonInlinedSFcns.methods3[1]);\n      }\n\n      /* Allocate memory of model methods 4 */\n      {\n        ssSetModelMethods4(rts, &JOLT_M->NonInlinedSFcns.methods4[1]);\n      }\n\n      /* Allocate memory for states auxilliary information */\n      {\n        ssSetStatesInfo2(rts, &JOLT_M->NonInlinedSFcns.statesInfo2[1]);\n        ssSetPeriodicStatesInfo(rts, &JOLT_M->\n          NonInlinedSFcns.periodicStatesInfo[1]);\n      }\n\n      /* inputs */\n      {\n        _ssSetNumInputPorts(rts, 15);\n        ssSetPortInfoForInputs(rts, &JOLT_M->\n          NonInlinedSFcns.Sfcn1.inputPortInfo[0]);\n        ssSetPortInfoForInputs(rts, &JOLT_M->\n          NonInlinedSFcns.Sfcn1.inputPortInfo[0]);\n        _ssSetPortInfo2ForInputUnits(rts,\n          &JOLT_M->NonInlinedSFcns.Sfcn1.inputPortUnits[0]);\n        ssSetInputPortUnit(rts, 0, 0);\n        ssSetInputPortUnit(rts, 1, 0);\n        ssSetInputPortUnit(rts, 2, 0);\n        ssSetInputPortUnit(rts, 3, 0);\n        ssSetInputPortUnit(rts, 4, 0);\n        ssSetInputPortUnit(rts, 5, 0);\n        ssSetInputPortUnit(rts, 6, 0);\n        ssSetInputPortUnit(rts, 7, 0);\n        ssSetInputPortUnit(rts, 8, 0);\n        ssSetInputPortUnit(rts, 9, 0);\n        ssSetInputPortUnit(rts, 10, 0);\n        ssSetInputPortUnit(rts, 11, 0);\n        ssSetInputPortUnit(rts, 12, 0);\n        ssSetInputPortUnit(rts, 13, 0);\n        ssSetInputPortUnit(rts, 14, 0);\n        _ssSetPortInfo2ForInputCoSimAttribute(rts,\n          &JOLT_M->NonInlinedSFcns.Sfcn1.inputPortCoSimAttribute[0]);\n        ssSetInputPortIsContinuousQuantity(rts, 0, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 1, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 2, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 3, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 4, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 5, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 6, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 7, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 8, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 9, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 10, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 11, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 12, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 13, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 14, 0);\n\n        /* port 0 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 0, 1);\n          ssSetInputPortSignal(rts, 0, (const_cast<real_T*>(&JOLT_RGND)));\n          _ssSetInputPortNumDimensions(rts, 0, 1);\n          ssSetInputPortWidthAsInt(rts, 0, 1);\n        }\n\n        /* port 1 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 1, 1);\n          ssSetInputPortSignal(rts, 1, &JOLT_B.npxls_trig);\n          _ssSetInputPortNumDimensions(rts, 1, 1);\n          ssSetInputPortWidthAsInt(rts, 1, 1);\n        }\n\n        /* port 2 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 2, 1);\n          ssSetInputPortSignal(rts, 2, (const_cast<real_T*>(&JOLT_RGND)));\n          _ssSetInputPortNumDimensions(rts, 2, 1);\n          ssSetInputPortWidthAsInt(rts, 2, 1);\n        }\n\n        /* port 3 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 3, 1);\n          ssSetInputPortSignal(rts, 3, &JOLT_B.out_c);\n          _ssSetInputPortNumDimensions(rts, 3, 1);\n          ssSetInputPortWidthAsInt(rts, 3, 1);\n        }\n\n        /* port 4 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 4, 1);\n          ssSetInputPortSignal(rts, 4, (const_cast<real_T*>(&JOLT_RGND)));\n          _ssSetInputPortNumDimensions(rts, 4, 1);\n          ssSetInputPortWidthAsInt(rts, 4, 1);\n        }\n\n        /* port 5 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 5, 1);\n          ssSetInputPortSignal(rts, 5, (const_cast<real_T*>(&JOLT_RGND)));\n          _ssSetInputPortNumDimensions(rts, 5, 1);\n          ssSetInputPortWidthAsInt(rts, 5, 1);\n        }\n\n        /* port 6 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 6, 1);\n          ssSetInputPortSignal(rts, 6, (const_cast<real_T*>(&JOLT_RGND)));\n          _ssSetInputPortNumDimensions(rts, 6, 1);\n          ssSetInputPortWidthAsInt(rts, 6, 1);\n        }\n\n        /* port 7 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 7, 1);\n          ssSetInputPortSignal(rts, 7, (const_cast<real_T*>(&JOLT_RGND)));\n          _ssSetInputPortNumDimensions(rts, 7, 1);\n          ssSetInputPortWidthAsInt(rts, 7, 1);\n        }\n\n        /* port 8 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 8, 1);\n          ssSetInputPortSignal(rts, 8, (const_cast<real_T*>(&JOLT_RGND)));\n          _ssSetInputPortNumDimensions(rts, 8, 1);\n          ssSetInputPortWidthAsInt(rts, 8, 1);\n        }\n\n        /* port 9 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 9, 1);\n          ssSetInputPortSignal(rts, 9, (const_cast<real_T*>(&JOLT_RGND)));\n          _ssSetInputPortNumDimensions(rts, 9, 1);\n          ssSetInputPortWidthAsInt(rts, 9, 1);\n        }\n\n        /* port 10 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 10, 1);\n          ssSetInputPortSignal(rts, 10, (const_cast<real_T*>(&JOLT_RGND)));\n          _ssSetInputPortNumDimensions(rts, 10, 1);\n          ssSetInputPortWidthAsInt(rts, 10, 1);\n        }\n\n        /* port 11 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 11, 1);\n          ssSetInputPortSignal(rts, 11, (const_cast<real_T*>(&JOLT_RGND)));\n          _ssSetInputPortNumDimensions(rts, 11, 1);\n          ssSetInputPortWidthAsInt(rts, 11, 1);\n        }\n\n        /* port 12 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 12, 1);\n          ssSetInputPortSignal(rts, 12, (const_cast<real_T*>(&JOLT_RGND)));\n          _ssSetInputPortNumDimensions(rts, 12, 1);\n          ssSetInputPortWidthAsInt(rts, 12, 1);\n        }\n\n        /* port 13 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 13, 1);\n          ssSetInputPortSignal(rts, 13, (const_cast<real_T*>(&JOLT_RGND)));\n          _ssSetInputPortNumDimensions(rts, 13, 1);\n          ssSetInputPortWidthAsInt(rts, 13, 1);\n        }\n\n        /* port 14 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 14, 1);\n          ssSetInputPortSignal(rts, 14, &JOLT_B.sigPulse);\n          _ssSetInputPortNumDimensions(rts, 14, 1);\n          ssSetInputPortWidthAsInt(rts, 14, 1);\n        }\n      }\n\n      /* path info */\n      ssSetModelName(rts, \"Digital output \");\n      ssSetPath(rts, \"JOLT/Digital output \");\n      ssSetRTModel(rts,JOLT_M);\n      ssSetParentSS(rts, (NULL));\n      ssSetRootSS(rts, rts);\n      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);\n\n      /* parameters */\n      {\n        mxArray **sfcnParams = (mxArray **)\n          &JOLT_M->NonInlinedSFcns.Sfcn1.params;\n        ssSetSFcnParamsCount(rts, 6);\n        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);\n        ssSetSFcnParam(rts, 0, (mxArray*)JOLT_cal->Digitaloutput_P1_Size);\n        ssSetSFcnParam(rts, 1, (mxArray*)JOLT_cal->Digitaloutput_P2_Size);\n        ssSetSFcnParam(rts, 2, (mxArray*)JOLT_cal->Digitaloutput_P3_Size);\n        ssSetSFcnParam(rts, 3, (mxArray*)JOLT_cal->Digitaloutput_P4_Size);\n        ssSetSFcnParam(rts, 4, (mxArray*)JOLT_cal->Digitaloutput_P5_Size);\n        ssSetSFcnParam(rts, 5, (mxArray*)JOLT_cal->Digitaloutput_P6_Size);\n      }\n\n      /* work vectors */\n      ssSetPWork(rts, (void **) &JOLT_DW.Digitaloutput_PWORK);\n\n      {\n        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)\n          &JOLT_M->NonInlinedSFcns.Sfcn1.dWork;\n        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)\n          &JOLT_M->NonInlinedSFcns.Sfcn1.dWorkAux;\n        ssSetSFcnDWork(rts, dWorkRecord);\n        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);\n        ssSetNumDWorkAsInt(rts, 1);\n\n        /* PWORK */\n        ssSetDWorkWidthAsInt(rts, 0, 1);\n        ssSetDWorkDataType(rts, 0,SS_POINTER);\n        ssSetDWorkComplexSignal(rts, 0, 0);\n        ssSetDWork(rts, 0, &JOLT_DW.Digitaloutput_PWORK);\n      }\n\n      /* registration */\n      sg_IO191_do_s(rts);\n      sfcnInitializeSizes(rts);\n      sfcnInitializeSampleTimes(rts);\n\n      /* adjust sample time */\n      ssSetSampleTime(rts, 0, 0.001);\n      ssSetOffsetTime(rts, 0, 0.0);\n      sfcnTsMap[0] = 1;\n\n      /* set compiled values of dynamic vector attributes */\n      ssSetNumNonsampledZCsAsInt(rts, 0);\n\n      /* Update connectivity flags for each port */\n      _ssSetInputPortConnected(rts, 0, 0);\n      _ssSetInputPortConnected(rts, 1, 1);\n      _ssSetInputPortConnected(rts, 2, 0);\n      _ssSetInputPortConnected(rts, 3, 1);\n      _ssSetInputPortConnected(rts, 4, 0);\n      _ssSetInputPortConnected(rts, 5, 0);\n      _ssSetInputPortConnected(rts, 6, 0);\n      _ssSetInputPortConnected(rts, 7, 0);\n      _ssSetInputPortConnected(rts, 8, 0);\n      _ssSetInputPortConnected(rts, 9, 0);\n      _ssSetInputPortConnected(rts, 10, 0);\n      _ssSetInputPortConnected(rts, 11, 0);\n      _ssSetInputPortConnected(rts, 12, 0);\n      _ssSetInputPortConnected(rts, 13, 0);\n      _ssSetInputPortConnected(rts, 14, 1);\n\n      /* Update the BufferDstPort flags for each input port */\n      ssSetInputPortBufferDstPort(rts, 0, -1);\n      ssSetInputPortBufferDstPort(rts, 1, -1);\n      ssSetInputPortBufferDstPort(rts, 2, -1);\n      ssSetInputPortBufferDstPort(rts, 3, -1);\n      ssSetInputPortBufferDstPort(rts, 4, -1);\n      ssSetInputPortBufferDstPort(rts, 5, -1);\n      ssSetInputPortBufferDstPort(rts, 6, -1);\n      ssSetInputPortBufferDstPort(rts, 7, -1);\n      ssSetInputPortBufferDstPort(rts, 8, -1);\n      ssSetInputPortBufferDstPort(rts, 9, -1);\n      ssSetInputPortBufferDstPort(rts, 10, -1);\n      ssSetInputPortBufferDstPort(rts, 11, -1);\n      ssSetInputPortBufferDstPort(rts, 12, -1);\n      ssSetInputPortBufferDstPort(rts, 13, -1);\n      ssSetInputPortBufferDstPort(rts, 14, -1);\n    }\n\n    /* Level2 S-Function Block: JOLT/<Root>/Analog input  (sg_IO191_ad_s) */\n    {\n      SimStruct *rts = JOLT_M->childSfunctions[2];\n\n      /* timing info */\n      time_T *sfcnPeriod = JOLT_M->NonInlinedSFcns.Sfcn2.sfcnPeriod;\n      time_T *sfcnOffset = JOLT_M->NonInlinedSFcns.Sfcn2.sfcnOffset;\n      int_T *sfcnTsMap = JOLT_M->NonInlinedSFcns.Sfcn2.sfcnTsMap;\n      (void) std::memset(static_cast<void*>(sfcnPeriod), 0,\n                         sizeof(time_T)*1);\n      (void) std::memset(static_cast<void*>(sfcnOffset), 0,\n                         sizeof(time_T)*1);\n      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);\n      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);\n      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);\n\n      {\n        ssSetBlkInfo2Ptr(rts, &JOLT_M->NonInlinedSFcns.blkInfo2[2]);\n      }\n\n      _ssSetBlkInfo2PortInfo2Ptr(rts,\n        &JOLT_M->NonInlinedSFcns.inputOutputPortInfo2[2]);\n\n      /* Set up the mdlInfo pointer */\n      ssSetRTWSfcnInfo(rts, JOLT_M->sfcnInfo);\n\n      /* Allocate memory of model methods 2 */\n      {\n        ssSetModelMethods2(rts, &JOLT_M->NonInlinedSFcns.methods2[2]);\n      }\n\n      /* Allocate memory of model methods 3 */\n      {\n        ssSetModelMethods3(rts, &JOLT_M->NonInlinedSFcns.methods3[2]);\n      }\n\n      /* Allocate memory of model methods 4 */\n      {\n        ssSetModelMethods4(rts, &JOLT_M->NonInlinedSFcns.methods4[2]);\n      }\n\n      /* Allocate memory for states auxilliary information */\n      {\n        ssSetStatesInfo2(rts, &JOLT_M->NonInlinedSFcns.statesInfo2[2]);\n        ssSetPeriodicStatesInfo(rts, &JOLT_M->\n          NonInlinedSFcns.periodicStatesInfo[2]);\n      }\n\n      /* outputs */\n      {\n        ssSetPortInfoForOutputs(rts,\n          &JOLT_M->NonInlinedSFcns.Sfcn2.outputPortInfo[0]);\n        ssSetPortInfoForOutputs(rts,\n          &JOLT_M->NonInlinedSFcns.Sfcn2.outputPortInfo[0]);\n        _ssSetNumOutputPorts(rts, 2);\n        _ssSetPortInfo2ForOutputUnits(rts,\n          &JOLT_M->NonInlinedSFcns.Sfcn2.outputPortUnits[0]);\n        ssSetOutputPortUnit(rts, 0, 0);\n        ssSetOutputPortUnit(rts, 1, 0);\n        _ssSetPortInfo2ForOutputCoSimAttribute(rts,\n          &JOLT_M->NonInlinedSFcns.Sfcn2.outputPortCoSimAttribute[0]);\n        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);\n        ssSetOutputPortIsContinuousQuantity(rts, 1, 0);\n\n        /* port 0 */\n        {\n          _ssSetOutputPortNumDimensions(rts, 0, 1);\n          ssSetOutputPortWidthAsInt(rts, 0, 1);\n          ssSetOutputPortSignal(rts, 0, ((real_T *) &JOLT_B.stim_raw));\n        }\n\n        /* port 1 */\n        {\n          _ssSetOutputPortNumDimensions(rts, 1, 1);\n          ssSetOutputPortWidthAsInt(rts, 1, 1);\n          ssSetOutputPortSignal(rts, 1, ((real_T *) &JOLT_B.rawMonofilData));\n        }\n      }\n\n      /* path info */\n      ssSetModelName(rts, \"Analog input \");\n      ssSetPath(rts, \"JOLT/Analog input \");\n      ssSetRTModel(rts,JOLT_M);\n      ssSetParentSS(rts, (NULL));\n      ssSetRootSS(rts, rts);\n      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);\n\n      /* parameters */\n      {\n        mxArray **sfcnParams = (mxArray **)\n          &JOLT_M->NonInlinedSFcns.Sfcn2.params;\n        ssSetSFcnParamsCount(rts, 9);\n        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);\n        ssSetSFcnParam(rts, 0, (mxArray*)JOLT_cal->Analoginput_P1_Size);\n        ssSetSFcnParam(rts, 1, (mxArray*)JOLT_cal->Analoginput_P2_Size);\n        ssSetSFcnParam(rts, 2, (mxArray*)JOLT_cal->Analoginput_P3_Size);\n        ssSetSFcnParam(rts, 3, (mxArray*)JOLT_cal->Analoginput_P4_Size);\n        ssSetSFcnParam(rts, 4, (mxArray*)JOLT_cal->Analoginput_P5_Size);\n        ssSetSFcnParam(rts, 5, (mxArray*)JOLT_cal->Analoginput_P6_Size);\n        ssSetSFcnParam(rts, 6, (mxArray*)JOLT_cal->Analoginput_P7_Size);\n        ssSetSFcnParam(rts, 7, (mxArray*)JOLT_cal->Analoginput_P8_Size);\n        ssSetSFcnParam(rts, 8, (mxArray*)JOLT_cal->Analoginput_P9_Size);\n      }\n\n      /* work vectors */\n      ssSetIWork(rts, (int_T *) &JOLT_DW.Analoginput_IWORK[0]);\n      ssSetPWork(rts, (void **) &JOLT_DW.Analoginput_PWORK);\n\n      {\n        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)\n          &JOLT_M->NonInlinedSFcns.Sfcn2.dWork;\n        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)\n          &JOLT_M->NonInlinedSFcns.Sfcn2.dWorkAux;\n        ssSetSFcnDWork(rts, dWorkRecord);\n        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);\n        ssSetNumDWorkAsInt(rts, 2);\n\n        /* IWORK */\n        ssSetDWorkWidthAsInt(rts, 0, 2);\n        ssSetDWorkDataType(rts, 0,SS_INTEGER);\n        ssSetDWorkComplexSignal(rts, 0, 0);\n        ssSetDWork(rts, 0, &JOLT_DW.Analoginput_IWORK[0]);\n\n        /* PWORK */\n        ssSetDWorkWidthAsInt(rts, 1, 1);\n        ssSetDWorkDataType(rts, 1,SS_POINTER);\n        ssSetDWorkComplexSignal(rts, 1, 0);\n        ssSetDWork(rts, 1, &JOLT_DW.Analoginput_PWORK);\n      }\n\n      /* registration */\n      sg_IO191_ad_s(rts);\n      sfcnInitializeSizes(rts);\n      sfcnInitializeSampleTimes(rts);\n\n      /* adjust sample time */\n      ssSetSampleTime(rts, 0, 0.001);\n      ssSetOffsetTime(rts, 0, 0.0);\n      sfcnTsMap[0] = 1;\n\n      /* set compiled values of dynamic vector attributes */\n      ssSetNumNonsampledZCsAsInt(rts, 0);\n\n      /* Update connectivity flags for each port */\n      _ssSetOutputPortConnected(rts, 0, 1);\n      _ssSetOutputPortConnected(rts, 1, 1);\n      _ssSetOutputPortBeingMerged(rts, 0, 0);\n      _ssSetOutputPortBeingMerged(rts, 1, 0);\n\n      /* Update the BufferDstPort flags for each input port */\n    }\n\n    /* Level2 S-Function Block: JOLT/<Root>/Digital input  (sg_IO191_di_s) */\n    {\n      SimStruct *rts = JOLT_M->childSfunctions[3];\n\n      /* timing info */\n      time_T *sfcnPeriod = JOLT_M->NonInlinedSFcns.Sfcn3.sfcnPeriod;\n      time_T *sfcnOffset = JOLT_M->NonInlinedSFcns.Sfcn3.sfcnOffset;\n      int_T *sfcnTsMap = JOLT_M->NonInlinedSFcns.Sfcn3.sfcnTsMap;\n      (void) std::memset(static_cast<void*>(sfcnPeriod), 0,\n                         sizeof(time_T)*1);\n      (void) std::memset(static_cast<void*>(sfcnOffset), 0,\n                         sizeof(time_T)*1);\n      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);\n      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);\n      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);\n\n      {\n        ssSetBlkInfo2Ptr(rts, &JOLT_M->NonInlinedSFcns.blkInfo2[3]);\n      }\n\n      _ssSetBlkInfo2PortInfo2Ptr(rts,\n        &JOLT_M->NonInlinedSFcns.inputOutputPortInfo2[3]);\n\n      /* Set up the mdlInfo pointer */\n      ssSetRTWSfcnInfo(rts, JOLT_M->sfcnInfo);\n\n      /* Allocate memory of model methods 2 */\n      {\n        ssSetModelMethods2(rts, &JOLT_M->NonInlinedSFcns.methods2[3]);\n      }\n\n      /* Allocate memory of model methods 3 */\n      {\n        ssSetModelMethods3(rts, &JOLT_M->NonInlinedSFcns.methods3[3]);\n      }\n\n      /* Allocate memory of model methods 4 */\n      {\n        ssSetModelMethods4(rts, &JOLT_M->NonInlinedSFcns.methods4[3]);\n      }\n\n      /* Allocate memory for states auxilliary information */\n      {\n        ssSetStatesInfo2(rts, &JOLT_M->NonInlinedSFcns.statesInfo2[3]);\n        ssSetPeriodicStatesInfo(rts, &JOLT_M->\n          NonInlinedSFcns.periodicStatesInfo[3]);\n      }\n\n      /* outputs */\n      {\n        ssSetPortInfoForOutputs(rts,\n          &JOLT_M->NonInlinedSFcns.Sfcn3.outputPortInfo[0]);\n        ssSetPortInfoForOutputs(rts,\n          &JOLT_M->NonInlinedSFcns.Sfcn3.outputPortInfo[0]);\n        _ssSetNumOutputPorts(rts, 1);\n        _ssSetPortInfo2ForOutputUnits(rts,\n          &JOLT_M->NonInlinedSFcns.Sfcn3.outputPortUnits[0]);\n        ssSetOutputPortUnit(rts, 0, 0);\n        _ssSetPortInfo2ForOutputCoSimAttribute(rts,\n          &JOLT_M->NonInlinedSFcns.Sfcn3.outputPortCoSimAttribute[0]);\n        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);\n\n        /* port 0 */\n        {\n          _ssSetOutputPortNumDimensions(rts, 0, 1);\n          ssSetOutputPortWidthAsInt(rts, 0, 1);\n          ssSetOutputPortSignal(rts, 0, ((real_T *) &JOLT_B.PulseGen1Hz));\n        }\n      }\n\n      /* path info */\n      ssSetModelName(rts, \"Digital input \");\n      ssSetPath(rts, \"JOLT/Digital input \");\n      ssSetRTModel(rts,JOLT_M);\n      ssSetParentSS(rts, (NULL));\n      ssSetRootSS(rts, rts);\n      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);\n\n      /* parameters */\n      {\n        mxArray **sfcnParams = (mxArray **)\n          &JOLT_M->NonInlinedSFcns.Sfcn3.params;\n        ssSetSFcnParamsCount(rts, 4);\n        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);\n        ssSetSFcnParam(rts, 0, (mxArray*)JOLT_cal->Digitalinput_P1_Size);\n        ssSetSFcnParam(rts, 1, (mxArray*)JOLT_cal->Digitalinput_P2_Size);\n        ssSetSFcnParam(rts, 2, (mxArray*)JOLT_cal->Digitalinput_P3_Size);\n        ssSetSFcnParam(rts, 3, (mxArray*)JOLT_cal->Digitalinput_P4_Size);\n      }\n\n      /* work vectors */\n      ssSetPWork(rts, (void **) &JOLT_DW.Digitalinput_PWORK);\n\n      {\n        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)\n          &JOLT_M->NonInlinedSFcns.Sfcn3.dWork;\n        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)\n          &JOLT_M->NonInlinedSFcns.Sfcn3.dWorkAux;\n        ssSetSFcnDWork(rts, dWorkRecord);\n        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);\n        ssSetNumDWorkAsInt(rts, 1);\n\n        /* PWORK */\n        ssSetDWorkWidthAsInt(rts, 0, 1);\n        ssSetDWorkDataType(rts, 0,SS_POINTER);\n        ssSetDWorkComplexSignal(rts, 0, 0);\n        ssSetDWork(rts, 0, &JOLT_DW.Digitalinput_PWORK);\n      }\n\n      /* registration */\n      sg_IO191_di_s(rts);\n      sfcnInitializeSizes(rts);\n      sfcnInitializeSampleTimes(rts);\n\n      /* adjust sample time */\n      ssSetSampleTime(rts, 0, 0.001);\n      ssSetOffsetTime(rts, 0, 0.0);\n      sfcnTsMap[0] = 1;\n\n      /* set compiled values of dynamic vector attributes */\n      ssSetNumNonsampledZCsAsInt(rts, 0);\n\n      /* Update connectivity flags for each port */\n      _ssSetOutputPortConnected(rts, 0, 1);\n      _ssSetOutputPortBeingMerged(rts, 0, 0);\n\n      /* Update the BufferDstPort flags for each input port */\n    }\n  }\n\n  /* Start for S-Function (sg_IO191_setup_s): '<Root>/Setup ' */\n  /* Level2 S-Function Block: '<Root>/Setup ' (sg_IO191_setup_s) */\n  {\n    SimStruct *rts = JOLT_M->childSfunctions[0];\n    sfcnStart(rts);\n    if (ssGetErrorStatus(rts) != (NULL))\n      return;\n  }\n\n  /* Start for S-Function (slrealtimeTCPServer): '<Root>/TCP Server' incorporates:\n   *  Constant: '<Root>/Constant'\n   */\n  {\n    try {\n      slrealtime::ip::tcp::Server* server = (slrealtime::ip::tcp::Server*)\n        slrealtime::ip::SocketFactory::createSocket(slrealtime::ip::SocketType::\n        TCPServer, \"0.0.0.0\", 8001U);\n      JOLT_DW.TCPServer_PWORK = reinterpret_cast<void*>(server);\n      server->reset();\n    } catch (std::exception& e) {\n      std::string tmp = std::string(e.what());\n      static std::string eMsg = tmp;\n      rtmSetErrorStatus(JOLT_M, eMsg.c_str());\n      rtmSetStopRequested(JOLT_M, 1);\n      ;\n    }\n  }\n\n  /* Start for S-Function (slrealtimeTCPReceive): '<Root>/TCP Receive' */\n  {\n    try {\n      slrealtime::ip::tcp::Socket* sock = (slrealtime::ip::tcp::Socket*)\n        slrealtime::ip::SocketFactory::getSocket(\"0.0.0.0\", 8001U);\n      char *buffer = (char *) calloc(1, 1);\n      JOLT_DW.TCPReceive_PWORK[0] = reinterpret_cast<void*>(sock);\n      JOLT_DW.TCPReceive_PWORK[1] = (void *)buffer;\n      JOLT_DW.TCPReceive_IWORK = 1;\n    } catch (std::exception& e) {\n      std::string tmp = std::string(e.what());\n      static std::string eMsg = tmp;\n      rtmSetErrorStatus(JOLT_M, eMsg.c_str());\n      rtmSetStopRequested(JOLT_M, 1);\n      ;\n    }\n  }\n\n  /* Start for S-Function (sg_IO191_do_s): '<Root>/Digital output ' */\n  /* Level2 S-Function Block: '<Root>/Digital output ' (sg_IO191_do_s) */\n  {\n    SimStruct *rts = JOLT_M->childSfunctions[1];\n    sfcnStart(rts);\n    if (ssGetErrorStatus(rts) != (NULL))\n      return;\n  }\n\n  /* Start for S-Function (sg_IO191_ad_s): '<Root>/Analog input ' */\n  /* Level2 S-Function Block: '<Root>/Analog input ' (sg_IO191_ad_s) */\n  {\n    SimStruct *rts = JOLT_M->childSfunctions[2];\n    sfcnStart(rts);\n    if (ssGetErrorStatus(rts) != (NULL))\n      return;\n  }\n\n  /* Start for S-Function (slrealtimeTCPSend): '<Root>/TCP Send' incorporates:\n   *  Constant: '<Root>/Constant3'\n   */\n  {\n    try {\n      slrealtime::ip::tcp::Socket* sock = (slrealtime::ip::tcp::Socket*)\n        slrealtime::ip::SocketFactory::getSocket(\"0.0.0.0\", 8001U);\n      JOLT_DW.TCPSend_PWORK = reinterpret_cast<void*>(sock);\n    } catch (std::exception& e) {\n      std::string tmp = std::string(e.what());\n      static std::string eMsg = tmp;\n      rtmSetErrorStatus(JOLT_M, eMsg.c_str());\n      rtmSetStopRequested(JOLT_M, 1);\n      ;\n    }\n  }\n\n  /* Start for S-Function (sg_IO191_di_s): '<Root>/Digital input ' */\n  /* Level2 S-Function Block: '<Root>/Digital input ' (sg_IO191_di_s) */\n  {\n    SimStruct *rts = JOLT_M->childSfunctions[3];\n    sfcnStart(rts);\n    if (ssGetErrorStatus(rts) != (NULL))\n      return;\n  }\n\n  {\n    int32_T i;\n\n    /* InitializeConditions for Memory: '<Root>/Memory2' */\n    for (i = 0; i < 8000; i++) {\n      JOLT_DW.Memory2_PreviousInput[i] = JOLT_cal->Memory2_InitialCondition;\n    }\n\n    /* End of InitializeConditions for Memory: '<Root>/Memory2' */\n\n    /* InitializeConditions for Memory: '<Root>/Memory1' */\n    JOLT_DW.Memory1_PreviousInput = JOLT_cal->Memory1_InitialCondition;\n\n    /* InitializeConditions for DiscretePulseGenerator: '<Root>/Npxls Trig' */\n    JOLT_DW.clockTickCounter = 0;\n\n    /* InitializeConditions for DiscreteFilter: '<Root>/Discrete Filter' */\n    for (i = 0; i < 500; i++) {\n      JOLT_DW.DiscreteFilter_states[i] = JOLT_cal->DiscreteFilter_InitialStates;\n    }\n\n    /* End of InitializeConditions for DiscreteFilter: '<Root>/Discrete Filter' */\n\n    /* InitializeConditions for Delay: '<Root>/Delay' */\n    for (i = 0; i < 700; i++) {\n      JOLT_DW.Delay_DSTATE[i] = JOLT_cal->Delay_InitialCondition;\n    }\n\n    /* End of InitializeConditions for Delay: '<Root>/Delay' */\n\n    /* SystemInitialize for MATLAB Function: '<Root>/MATLAB Function1' */\n    JOLT_DW.sfEvent_d = JOLT_CALL_EVENT_l;\n    JOLT_DW.is_active_c2_JOLT = 0U;\n\n    /* SystemInitialize for MATLAB Function: '<S6>/MATLAB Function4' */\n    JOLT_DW.sfEvent_k = JOLT_CALL_EVENT_l;\n    JOLT_DW.t0_not_empty_p = false;\n    JOLT_DW.is_active_c4_JOLT = 0U;\n\n    /* SystemInitialize for MATLAB Function: '<S8>/MATLAB Function4' */\n    JOLT_MATLABFunction4_Init(&JOLT_DW.sf_MATLABFunction4_d);\n\n    /* SystemInitialize for MATLAB Function: '<S3>/MATLAB Function' */\n    JOLT_DW.sfEvent_e = JOLT_CALL_EVENT_l;\n    JOLT_DW.is_active_c1_JOLT = 0U;\n\n    /* SystemInitialize for MATLAB Function: '<S7>/MATLAB Function4' */\n    JOLT_DW.sfEvent = JOLT_CALL_EVENT_l;\n    JOLT_DW.t0_not_empty = false;\n    JOLT_DW.is_active_c5_JOLT = 0U;\n\n    /* SystemInitialize for MATLAB Function: '<S1>/MATLAB Function' */\n    JOLT_DW.sfEvent_c = JOLT_CALL_EVENT_l;\n    JOLT_DW.is_active_c3_JOLT = 0U;\n\n    /* SystemInitialize for MATLAB Function: '<S9>/MATLAB Function4' */\n    JOLT_MATLABFunction4_Init(&JOLT_DW.sf_MATLABFunction4_h);\n\n    /* SystemInitialize for MATLAB Function: '<S5>/MATLAB Function' */\n    JOLT_DW.sfEvent_m = JOLT_CALL_EVENT_l;\n    JOLT_DW.is_active_c8_JOLT = 0U;\n\n    /* SystemInitialize for MATLAB Function: '<S4>/MATLAB Function' */\n    JOLT_DW.sfEvent_p = JOLT_CALL_EVENT_l;\n    JOLT_DW.is_active_c6_JOLT = 0U;\n  }\n}\n\n/* Model terminate function */\nvoid JOLT_terminate(void)\n{\n  /* Terminate for S-Function (sg_IO191_setup_s): '<Root>/Setup ' */\n  /* Level2 S-Function Block: '<Root>/Setup ' (sg_IO191_setup_s) */\n  {\n    SimStruct *rts = JOLT_M->childSfunctions[0];\n    sfcnTerminate(rts);\n  }\n\n  /* Terminate for S-Function (slrealtimeTCPServer): '<Root>/TCP Server' incorporates:\n   *  Constant: '<Root>/Constant'\n   */\n  {\n    if (JOLT_DW.TCPServer_PWORK != NULL) {\n      slrealtime::ip::tcp::Server* server = reinterpret_cast<slrealtime::ip::tcp::\n        Server*>(JOLT_DW.TCPServer_PWORK);\n      slrealtime::ip::SocketFactory::releaseSocket(server->localAddress(),\n        server->port());\n    }\n  }\n\n  /* Terminate for S-Function (slrealtimeTCPReceive): '<Root>/TCP Receive' */\n  {\n    if (JOLT_DW.TCPReceive_PWORK[1] != NULL) {\n      char_T *rcvBuf = (char_T *)JOLT_DW.TCPReceive_PWORK[1];\n      if (rcvBuf)\n        free(rcvBuf);\n    }\n  }\n\n  /* Terminate for S-Function (sg_IO191_do_s): '<Root>/Digital output ' */\n  /* Level2 S-Function Block: '<Root>/Digital output ' (sg_IO191_do_s) */\n  {\n    SimStruct *rts = JOLT_M->childSfunctions[1];\n    sfcnTerminate(rts);\n  }\n\n  /* Terminate for S-Function (sg_IO191_ad_s): '<Root>/Analog input ' */\n  /* Level2 S-Function Block: '<Root>/Analog input ' (sg_IO191_ad_s) */\n  {\n    SimStruct *rts = JOLT_M->childSfunctions[2];\n    sfcnTerminate(rts);\n  }\n\n  /* Terminate for S-Function (slrealtimeTCPSend): '<Root>/TCP Send' incorporates:\n   *  Constant: '<Root>/Constant3'\n   */\n  {\n  }\n\n  /* Terminate for S-Function (sg_IO191_di_s): '<Root>/Digital input ' */\n  /* Level2 S-Function Block: '<Root>/Digital input ' (sg_IO191_di_s) */\n  {\n    SimStruct *rts = JOLT_M->childSfunctions[3];\n    sfcnTerminate(rts);\n  }\n}\n"},{"name":"JOLT.h","type":"header","group":"model","path":"/home/electro/Code_Repo/n-CORTEx/JOLT_slrealtime_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * JOLT.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"JOLT\".\n *\n * Model version              : 1.375\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Fri Dec  1 17:02:18 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_JOLT_h_\n#define RTW_HEADER_JOLT_h_\n#include <logsrv.h>\n#include \"rtwtypes.h\"\n#include \"simstruc.h\"\n#include \"fixedpoint.h\"\n#include \"verify/verifyIntrf.h\"\n#include \"slrealtime/libsrc/IP/tcp.hpp\"\n#include \"slrealtime/libsrc/IP/ip.hpp\"\n#include \"slrealtime/libsrc/IP/socketFactory.hpp\"\n#include \"JOLT_types.h\"\n#include <stddef.h>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\nextern \"C\"\n{\n\n#include \"rtGetNaN.h\"\n\n}\n\n#include <cstring>\n#include \"JOLT_cal.h\"\n\n/* Macros for accessing real-time model data structure */\n#ifndef rtmGetContTimeOutputInconsistentWithStateAtMajorStepFlag\n#define rtmGetContTimeOutputInconsistentWithStateAtMajorStepFlag(rtm) ((rtm)->CTOutputIncnstWithState)\n#endif\n\n#ifndef rtmSetContTimeOutputInconsistentWithStateAtMajorStepFlag\n#define rtmSetContTimeOutputInconsistentWithStateAtMajorStepFlag(rtm, val) ((rtm)->CTOutputIncnstWithState = (val))\n#endif\n\n#ifndef rtmGetDerivCacheNeedsReset\n#define rtmGetDerivCacheNeedsReset(rtm) ((rtm)->derivCacheNeedsReset)\n#endif\n\n#ifndef rtmSetDerivCacheNeedsReset\n#define rtmSetDerivCacheNeedsReset(rtm, val) ((rtm)->derivCacheNeedsReset = (val))\n#endif\n\n#ifndef rtmGetFinalTime\n#define rtmGetFinalTime(rtm)           ((rtm)->Timing.tFinal)\n#endif\n\n#ifndef rtmGetSampleHitArray\n#define rtmGetSampleHitArray(rtm)      ((rtm)->Timing.sampleHitArray)\n#endif\n\n#ifndef rtmGetStepSize\n#define rtmGetStepSize(rtm)            ((rtm)->Timing.stepSize)\n#endif\n\n#ifndef rtmGetZCCacheNeedsReset\n#define rtmGetZCCacheNeedsReset(rtm)   ((rtm)->zCCacheNeedsReset)\n#endif\n\n#ifndef rtmSetZCCacheNeedsReset\n#define rtmSetZCCacheNeedsReset(rtm, val) ((rtm)->zCCacheNeedsReset = (val))\n#endif\n\n#ifndef rtmGet_TimeOfLastOutput\n#define rtmGet_TimeOfLastOutput(rtm)   ((rtm)->Timing.timeOfLastOutput)\n#endif\n\n#ifndef rtmGetErrorStatus\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\n#endif\n\n#ifndef rtmSetErrorStatus\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\n#endif\n\n#ifndef rtmGetStopRequested\n#define rtmGetStopRequested(rtm)       ((rtm)->Timing.stopRequestedFlag)\n#endif\n\n#ifndef rtmSetStopRequested\n#define rtmSetStopRequested(rtm, val)  ((rtm)->Timing.stopRequestedFlag = (val))\n#endif\n\n#ifndef rtmGetStopRequestedPtr\n#define rtmGetStopRequestedPtr(rtm)    (&((rtm)->Timing.stopRequestedFlag))\n#endif\n\n#ifndef rtmGetT\n#define rtmGetT(rtm)                   (rtmGetTPtr((rtm))[0])\n#endif\n\n#ifndef rtmGetTFinal\n#define rtmGetTFinal(rtm)              ((rtm)->Timing.tFinal)\n#endif\n\n#ifndef rtmGetTPtr\n#define rtmGetTPtr(rtm)                ((rtm)->Timing.t)\n#endif\n\n#ifndef rtmGetTStart\n#define rtmGetTStart(rtm)              ((rtm)->Timing.tStart)\n#endif\n\n#ifndef rtmGetTimeOfLastOutput\n#define rtmGetTimeOfLastOutput(rtm)    ((rtm)->Timing.timeOfLastOutput)\n#endif\n\n/* Block signals for system '<S8>/MATLAB Function4' */\nstruct B_MATLABFunction4_JOLT_T {\n  real_T sigPulse;                     /* '<S8>/MATLAB Function4' */\n};\n\n/* Block states (default storage) for system '<S8>/MATLAB Function4' */\nstruct DW_MATLABFunction4_JOLT_T {\n  real_T t0;                           /* '<S8>/MATLAB Function4' */\n  int32_T sfEvent;                     /* '<S8>/MATLAB Function4' */\n  uint8_T is_active_c7_JOLT;           /* '<S8>/MATLAB Function4' */\n  boolean_T doneDoubleBufferReInit;    /* '<S8>/MATLAB Function4' */\n  boolean_T t0_not_empty;              /* '<S8>/MATLAB Function4' */\n};\n\n/* Block signals (default storage) */\nstruct B_JOLT_T {\n  real_T Memory2[8000];                /* '<Root>/Memory2' */\n  real_T x_data[8000];\n  real_T absdiff_data[8000];\n  real_T TCPServer;                    /* '<Root>/TCP Server' */\n  real_T TCPReceive_o2;                /* '<Root>/TCP Receive' */\n  real_T Memory1;                      /* '<Root>/Memory1' */\n  real_T npxls_trig;                   /* '<Root>/Npxls Trig' */\n  real_T Clock;                        /* '<S6>/Clock' */\n  real_T Clock_p;                      /* '<S8>/Clock' */\n  real_T Clock_j;                      /* '<S7>/Clock' */\n  real_T stim_raw;                     /* '<Root>/Analog input ' */\n  real_T rawMonofilData;               /* '<Root>/Analog input ' */\n  real_T Product;                      /* '<Root>/Product' */\n  real_T stim_filt;                    /* '<Root>/Discrete Filter' */\n  real_T Add1;                         /* '<S10>/Add1' */\n  real_T Product_o;                    /* '<S10>/Product' */\n  real_T Add;                          /* '<S10>/Add' */\n  real_T npxlsAcqCutoff;               /* '<Root>/Delay' */\n  real_T Clock_a;                      /* '<S9>/Clock' */\n  real_T TCPSend;                      /* '<Root>/TCP Send' */\n  real_T PulseGen1Hz;                  /* '<Root>/Digital input ' */\n  real_T HiddenRateTransitionForToWks_In;\n  /* '<Root>/HiddenRateTransitionForToWks_InsertedFor_TAQSigLogging_InsertedFor_Digital input _at_outport_0_at_inport_0' */\n  real_T sigPulse;                     /* '<S7>/MATLAB Function4' */\n  real_T sigPulse_p;                   /* '<S6>/MATLAB Function4' */\n  real_T out;                          /* '<S5>/MATLAB Function' */\n  real_T out_c;                        /* '<S3>/MATLAB Function' */\n  real_T npxlsAcq_trig;                /* '<Root>/MATLAB Function1' */\n  real_T acqStatus;                    /* '<Root>/MATLAB Function1' */\n  real_T S_out;                        /* '<Root>/MATLAB Function1' */\n  real_T acqTone_trig;                 /* '<Root>/MATLAB Function1' */\n  real_T npxlsAcq_out;                 /* '<Root>/MATLAB Function1' */\n  real_T restingAcq;                   /* '<Root>/MATLAB Function1' */\n  real_T stimSig_sel;                  /* '<Root>/MATLAB Function1' */\n  real_T monofilBaseBuffer_out[8000];  /* '<Root>/MATLAB Function1' */\n  real_T baseAvg;                      /* '<Root>/MATLAB Function1' */\n  real_T changeAvg;                    /* '<Root>/MATLAB Function1' */\n  real_T baseBuffLen;                  /* '<Root>/MATLAB Function1' */\n  real_T buffOut[8000];                /* '<S1>/MATLAB Function' */\n  uint8_T buttonStat;                  /* '<Root>/TCP Receive' */\n  uint8_T convertedMonofil;            /* '<S10>/Data Type Conversion' */\n  uint8_T out_j;                       /* '<S4>/MATLAB Function' */\n  B_MATLABFunction4_JOLT_T sf_MATLABFunction4_h;/* '<S9>/MATLAB Function4' */\n  B_MATLABFunction4_JOLT_T sf_MATLABFunction4_d;/* '<S8>/MATLAB Function4' */\n};\n\n/* Block states (default storage) for system '<Root>' */\nstruct DW_JOLT_T {\n  real_T DiscreteFilter_states[500];   /* '<Root>/Discrete Filter' */\n  real_T Delay_DSTATE[700];            /* '<Root>/Delay' */\n  real_T Memory2_PreviousInput[8000];  /* '<Root>/Memory2' */\n  real_T Memory1_PreviousInput;        /* '<Root>/Memory1' */\n  real_T DiscreteFilter_tmp;           /* '<Root>/Discrete Filter' */\n  real_T Add_DWORK1;                   /* '<S10>/Add' */\n  real_T t0;                           /* '<S7>/MATLAB Function4' */\n  real_T t0_b;                         /* '<S6>/MATLAB Function4' */\n  real_T Setup_RWORK[2];               /* '<Root>/Setup ' */\n  void *Setup_PWORK;                   /* '<Root>/Setup ' */\n  void *TCPServer_PWORK;               /* '<Root>/TCP Server' */\n  void *TCPReceive_PWORK[2];           /* '<Root>/TCP Receive' */\n  void *Digitaloutput_PWORK;           /* '<Root>/Digital output ' */\n  void *Analoginput_PWORK;             /* '<Root>/Analog input ' */\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_Discr;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MUX1_;   /* synthesized block */\n\n  void *TCPSend_PWORK;                 /* '<Root>/TCP Send' */\n  void *Digitalinput_PWORK;            /* '<Root>/Digital input ' */\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_Digit;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MUX2_;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_Subsy;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_Delay;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_DataT;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_Analo;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_Ana_p;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_Sub_a;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MUX_a;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_Sub_l;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_Npxls;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MATLA;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_a;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_j;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_c;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_f;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_g;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_o;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_TCPRe;   /* synthesized block */\n\n  int32_T clockTickCounter;            /* '<Root>/Npxls Trig' */\n  int32_T sfEvent;                     /* '<S7>/MATLAB Function4' */\n  int32_T sfEvent_k;                   /* '<S6>/MATLAB Function4' */\n  int32_T sfEvent_m;                   /* '<S5>/MATLAB Function' */\n  int32_T sfEvent_p;                   /* '<S4>/MATLAB Function' */\n  int32_T sfEvent_e;                   /* '<S3>/MATLAB Function' */\n  int32_T sfEvent_d;                   /* '<Root>/MATLAB Function1' */\n  int32_T sfEvent_c;                   /* '<S1>/MATLAB Function' */\n  int_T TCPReceive_IWORK;              /* '<Root>/TCP Receive' */\n  int_T Analoginput_IWORK[2];          /* '<Root>/Analog input ' */\n  uint8_T is_active_c5_JOLT;           /* '<S7>/MATLAB Function4' */\n  uint8_T is_active_c4_JOLT;           /* '<S6>/MATLAB Function4' */\n  uint8_T is_active_c8_JOLT;           /* '<S5>/MATLAB Function' */\n  uint8_T is_active_c6_JOLT;           /* '<S4>/MATLAB Function' */\n  uint8_T is_active_c1_JOLT;           /* '<S3>/MATLAB Function' */\n  uint8_T is_active_c2_JOLT;           /* '<Root>/MATLAB Function1' */\n  uint8_T is_active_c3_JOLT;           /* '<S1>/MATLAB Function' */\n  boolean_T doneDoubleBufferReInit;    /* '<S7>/MATLAB Function4' */\n  boolean_T t0_not_empty;              /* '<S7>/MATLAB Function4' */\n  boolean_T doneDoubleBufferReInit_f;  /* '<S6>/MATLAB Function4' */\n  boolean_T t0_not_empty_p;            /* '<S6>/MATLAB Function4' */\n  boolean_T doneDoubleBufferReInit_m;  /* '<S5>/MATLAB Function' */\n  boolean_T doneDoubleBufferReInit_c;  /* '<S4>/MATLAB Function' */\n  boolean_T doneDoubleBufferReInit_fa; /* '<S3>/MATLAB Function' */\n  boolean_T doneDoubleBufferReInit_d;  /* '<Root>/MATLAB Function1' */\n  boolean_T doneDoubleBufferReInit_h;  /* '<S1>/MATLAB Function' */\n  DW_MATLABFunction4_JOLT_T sf_MATLABFunction4_h;/* '<S9>/MATLAB Function4' */\n  DW_MATLABFunction4_JOLT_T sf_MATLABFunction4_d;/* '<S8>/MATLAB Function4' */\n};\n\n/* Real-time Model Data Structure */\nstruct tag_RTM_JOLT_T {\n  struct SimStruct_tag * *childSfunctions;\n  const char_T *errorStatus;\n  SS_SimMode simMode;\n  RTWSolverInfo solverInfo;\n  RTWSolverInfo *solverInfoPtr;\n  void *sfcnInfo;\n\n  /*\n   * NonInlinedSFcns:\n   * The following substructure contains information regarding\n   * non-inlined s-functions used in the model.\n   */\n  struct {\n    RTWSfcnInfo sfcnInfo;\n    time_T *taskTimePtrs[2];\n    SimStruct childSFunctions[4];\n    SimStruct *childSFunctionPtrs[4];\n    struct _ssBlkInfo2 blkInfo2[4];\n    struct _ssSFcnModelMethods2 methods2[4];\n    struct _ssSFcnModelMethods3 methods3[4];\n    struct _ssSFcnModelMethods4 methods4[4];\n    struct _ssStatesInfo2 statesInfo2[4];\n    ssPeriodicStatesInfo periodicStatesInfo[4];\n    struct _ssPortInfo2 inputOutputPortInfo2[4];\n    struct {\n      time_T sfcnPeriod[1];\n      time_T sfcnOffset[1];\n      int_T sfcnTsMap[1];\n      uint_T attribs[9];\n      mxArray *params[9];\n      struct _ssDWorkRecord dWork[2];\n      struct _ssDWorkAuxRecord dWorkAux[2];\n    } Sfcn0;\n\n    struct {\n      time_T sfcnPeriod[1];\n      time_T sfcnOffset[1];\n      int_T sfcnTsMap[1];\n      struct _ssPortInputs inputPortInfo[15];\n      struct _ssInPortUnit inputPortUnits[15];\n      struct _ssInPortCoSimAttribute inputPortCoSimAttribute[15];\n      uint_T attribs[6];\n      mxArray *params[6];\n      struct _ssDWorkRecord dWork[1];\n      struct _ssDWorkAuxRecord dWorkAux[1];\n    } Sfcn1;\n\n    struct {\n      time_T sfcnPeriod[1];\n      time_T sfcnOffset[1];\n      int_T sfcnTsMap[1];\n      struct _ssPortOutputs outputPortInfo[2];\n      struct _ssOutPortUnit outputPortUnits[2];\n      struct _ssOutPortCoSimAttribute outputPortCoSimAttribute[2];\n      uint_T attribs[9];\n      mxArray *params[9];\n      struct _ssDWorkRecord dWork[2];\n      struct _ssDWorkAuxRecord dWorkAux[2];\n    } Sfcn2;\n\n    struct {\n      time_T sfcnPeriod[1];\n      time_T sfcnOffset[1];\n      int_T sfcnTsMap[1];\n      struct _ssPortOutputs outputPortInfo[1];\n      struct _ssOutPortUnit outputPortUnits[1];\n      struct _ssOutPortCoSimAttribute outputPortCoSimAttribute[1];\n      uint_T attribs[4];\n      mxArray *params[4];\n      struct _ssDWorkRecord dWork[1];\n      struct _ssDWorkAuxRecord dWorkAux[1];\n    } Sfcn3;\n  } NonInlinedSFcns;\n\n  boolean_T zCCacheNeedsReset;\n  boolean_T derivCacheNeedsReset;\n  boolean_T CTOutputIncnstWithState;\n\n  /*\n   * Sizes:\n   * The following substructure contains sizes information\n   * for many of the model attributes such as inputs, outputs,\n   * dwork, sample times, etc.\n   */\n  struct {\n    uint32_T options;\n    int_T numContStates;\n    int_T numU;\n    int_T numY;\n    int_T numSampTimes;\n    int_T numBlocks;\n    int_T numBlockIO;\n    int_T numBlockPrms;\n    int_T numDwork;\n    int_T numSFcnPrms;\n    int_T numSFcns;\n    int_T numIports;\n    int_T numOports;\n    int_T numNonSampZCs;\n    int_T sysDirFeedThru;\n    int_T rtwGenSfcn;\n  } Sizes;\n\n  /*\n   * Timing:\n   * The following substructure contains information regarding\n   * the timing information for the model.\n   */\n  struct {\n    time_T stepSize;\n    uint32_T clockTick0;\n    uint32_T clockTickH0;\n    time_T stepSize0;\n    uint32_T clockTick1;\n    uint32_T clockTickH1;\n    time_T stepSize1;\n    time_T tStart;\n    time_T tFinal;\n    time_T timeOfLastOutput;\n    SimTimeStep simTimeStep;\n    boolean_T stopRequestedFlag;\n    time_T *sampleTimes;\n    time_T *offsetTimes;\n    int_T *sampleTimeTaskIDPtr;\n    int_T *sampleHits;\n    int_T *perTaskSampleHits;\n    time_T *t;\n    time_T sampleTimesArray[2];\n    time_T offsetTimesArray[2];\n    int_T sampleTimeTaskIDArray[2];\n    int_T sampleHitArray[2];\n    int_T perTaskSampleHitsArray[4];\n    time_T tArray[2];\n  } Timing;\n};\n\n/* Block signals (default storage) */\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern struct B_JOLT_T JOLT_B;\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n/* Block states (default storage) */\nextern struct DW_JOLT_T JOLT_DW;\n\n/* External data declarations for dependent source files */\nextern const real_T JOLT_RGND;         /* real_T ground */\n\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  /* Model entry point functions */\n  extern void JOLT_initialize(void);\n  extern void JOLT_step(void);\n  extern void JOLT_terminate(void);\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n/* Real-time Model object */\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern RT_MODEL_JOLT_T *const JOLT_M;\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n/*-\n * The generated code includes comments that allow you to trace directly\n * back to the appropriate location in the model.  The basic format\n * is <system>/block_name, where system is the system number (uniquely\n * assigned by Simulink) and block_name is the name of the block.\n *\n * Use the MATLAB hilite_system command to trace the generated code back\n * to the model.  For example,\n *\n * hilite_system('<S3>')    - opens system 3\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\n *\n * Here is the system hierarchy for this model\n *\n * '<Root>' : 'JOLT'\n * '<S1>'   : 'JOLT/Buffer'\n * '<S2>'   : 'JOLT/MATLAB Function1'\n * '<S3>'   : 'JOLT/MUX'\n * '<S4>'   : 'JOLT/MUX1'\n * '<S5>'   : 'JOLT/MUX2'\n * '<S6>'   : 'JOLT/Subsystem'\n * '<S7>'   : 'JOLT/Subsystem1'\n * '<S8>'   : 'JOLT/Subsystem2'\n * '<S9>'   : 'JOLT/Subsystem3'\n * '<S10>'  : 'JOLT/tcpConversion'\n * '<S11>'  : 'JOLT/Buffer/MATLAB Function'\n * '<S12>'  : 'JOLT/MUX/MATLAB Function'\n * '<S13>'  : 'JOLT/MUX1/MATLAB Function'\n * '<S14>'  : 'JOLT/MUX2/MATLAB Function'\n * '<S15>'  : 'JOLT/Subsystem/MATLAB Function4'\n * '<S16>'  : 'JOLT/Subsystem1/MATLAB Function4'\n * '<S17>'  : 'JOLT/Subsystem2/MATLAB Function4'\n * '<S18>'  : 'JOLT/Subsystem3/MATLAB Function4'\n */\n#endif                                 /* RTW_HEADER_JOLT_h_ */\n"},{"name":"JOLT_private.h","type":"header","group":"model","path":"/home/electro/Code_Repo/n-CORTEx/JOLT_slrealtime_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * JOLT_private.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"JOLT\".\n *\n * Model version              : 1.375\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Fri Dec  1 17:02:18 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_JOLT_private_h_\n#define RTW_HEADER_JOLT_private_h_\n#include \"rtwtypes.h\"\n#include \"multiword_types.h\"\n#include \"JOLT.h\"\n#include \"JOLT_types.h\"\n\n/* Private macros used by the generated code to access rtModel */\n#ifndef rtmIsMajorTimeStep\n#define rtmIsMajorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MAJOR_TIME_STEP)\n#endif\n\n#ifndef rtmIsMinorTimeStep\n#define rtmIsMinorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MINOR_TIME_STEP)\n#endif\n\n#ifndef rtmSetTFinal\n#define rtmSetTFinal(rtm, val)         ((rtm)->Timing.tFinal = (val))\n#endif\n\n#ifndef rtmSetTPtr\n#define rtmSetTPtr(rtm, val)           ((rtm)->Timing.t = (val))\n#endif\n\nextern real_T rt_roundd_snf(real_T u);\nextern void* slrtRegisterSignalToLoggingService(uintptr_t sigAddr);\nextern \"C\" void sg_IO191_setup_s(SimStruct *rts);\nextern \"C\" void sg_IO191_do_s(SimStruct *rts);\nextern \"C\" void sg_IO191_ad_s(SimStruct *rts);\nextern \"C\" void sg_IO191_di_s(SimStruct *rts);\nextern void JOLT_MATLABFunction4_Init(DW_MATLABFunction4_JOLT_T *localDW);\nextern void JOLT_MATLABFunction4(real_T rtu_onset_trig, real_T rtu_sigAmp,\n  real_T rtu_sigPulseLen, real_T rtu_t, B_MATLABFunction4_JOLT_T *localB,\n  DW_MATLABFunction4_JOLT_T *localDW);\n\n#endif                                 /* RTW_HEADER_JOLT_private_h_ */\n"},{"name":"JOLT_types.h","type":"header","group":"model","path":"/home/electro/Code_Repo/n-CORTEx/JOLT_slrealtime_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * JOLT_types.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"JOLT\".\n *\n * Model version              : 1.375\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Fri Dec  1 17:02:18 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_JOLT_types_h_\n#define RTW_HEADER_JOLT_types_h_\n\n/* Forward declaration for rtModel */\ntypedef struct tag_RTM_JOLT_T RT_MODEL_JOLT_T;\n\n#endif                                 /* RTW_HEADER_JOLT_types_h_ */\n"},{"name":"JOLT_cal.cpp","type":"source","group":"data","path":"/home/electro/Code_Repo/n-CORTEx/JOLT_slrealtime_rtw","tag":"","groupDisplay":"Data files","code":"#include \"JOLT_cal.h\"\n#include \"JOLT.h\"\n\n/* Storage class 'PageSwitching' */\nJOLT_cal_type JOLT_cal_impl = {\n  /* Variable: T_npxls\n   * Referenced by: '<Root>/Npxls Trig'\n   */\n  4.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Memory2'\n   */\n  0.0,\n\n  /* Computed Parameter: Setup_P1_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parPciSlot\n   * Referenced by: '<Root>/Setup '\n   */\n  -1.0,\n\n  /* Computed Parameter: Setup_P2_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parModuleId\n   * Referenced by: '<Root>/Setup '\n   */\n  1.0,\n\n  /* Computed Parameter: Setup_P3_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parTriggerSignal\n   * Referenced by: '<Root>/Setup '\n   */\n  1.0,\n\n  /* Computed Parameter: Setup_P4_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parAdcChannels\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 2.0 },\n\n  /* Computed Parameter: Setup_P5_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parAdcMode\n   * Referenced by: '<Root>/Setup '\n   */\n  2.0,\n\n  /* Computed Parameter: Setup_P6_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parAdcRanges\n   * Referenced by: '<Root>/Setup '\n   */\n  { 4.0, 4.0 },\n\n  /* Computed Parameter: Setup_P7_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parDacChannels\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 2.0 },\n\n  /* Computed Parameter: Setup_P8_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parDacRanges\n   * Referenced by: '<Root>/Setup '\n   */\n  { 4.0, 4.0 },\n\n  /* Computed Parameter: Setup_P9_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 8.0 },\n\n  /* Expression: parDioFirstControl\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 8.0, 9.0 },\n\n  /* Expression: 1\n   * Referenced by: '<Root>/Constant'\n   */\n  1.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Memory1'\n   */\n  0.0,\n\n  /* Expression: 2.5\n   * Referenced by: '<Root>/Npxls Trig'\n   */\n  2.5,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Npxls Trig'\n   */\n  0.0,\n\n  /* Expression: 2.5\n   * Referenced by: '<S6>/Constant'\n   */\n  2.5,\n\n  /* Expression: 8\n   * Referenced by: '<S6>/Constant1'\n   */\n  8.0,\n\n  /* Expression: 1\n   * Referenced by: '<S8>/Constant'\n   */\n  1.0,\n\n  /* Expression: 4\n   * Referenced by: '<S8>/Constant1'\n   */\n  4.0,\n\n  /* Expression: 1\n   * Referenced by: '<S7>/Constant'\n   */\n  1.0,\n\n  /* Expression: 1\n   * Referenced by: '<S7>/Constant1'\n   */\n  1.0,\n\n  /* Computed Parameter: Digitaloutput_P1_Size\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parModuleId\n   * Referenced by: '<Root>/Digital output '\n   */\n  1.0,\n\n  /* Computed Parameter: Digitaloutput_P2_Size\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parSampleTime\n   * Referenced by: '<Root>/Digital output '\n   */\n  0.001,\n\n  /* Computed Parameter: Digitaloutput_P3_Size\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parPciSlot\n   * Referenced by: '<Root>/Digital output '\n   */\n  -1.0,\n\n  /* Computed Parameter: Digitaloutput_P4_Size\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 15.0 },\n\n  /* Expression: parDoChannels\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 15.0,\n    16.0 },\n\n  /* Computed Parameter: Digitaloutput_P5_Size\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 15.0 },\n\n  /* Expression: parDoInitValues\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },\n\n  /* Computed Parameter: Digitaloutput_P6_Size\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 15.0 },\n\n  /* Expression: parDoResets\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },\n\n  /* Computed Parameter: Analoginput_P1_Size\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parModuleId\n   * Referenced by: '<Root>/Analog input '\n   */\n  1.0,\n\n  /* Computed Parameter: Analoginput_P2_Size\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parSampleTime\n   * Referenced by: '<Root>/Analog input '\n   */\n  0.001,\n\n  /* Computed Parameter: Analoginput_P3_Size\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parPciSlot\n   * Referenced by: '<Root>/Analog input '\n   */\n  -1.0,\n\n  /* Computed Parameter: Analoginput_P4_Size\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parAdcChannels\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 2.0 },\n\n  /* Computed Parameter: Analoginput_P5_Size\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parAdcMode\n   * Referenced by: '<Root>/Analog input '\n   */\n  2.0,\n\n  /* Computed Parameter: Analoginput_P6_Size\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parAdcRate\n   * Referenced by: '<Root>/Analog input '\n   */\n  100000.0,\n\n  /* Computed Parameter: Analoginput_P7_Size\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parAdcRanges\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 4.0, 4.0 },\n\n  /* Computed Parameter: Analoginput_P8_Size\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parAdcInitValues\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 0.0, 0.0 },\n\n  /* Computed Parameter: Analoginput_P9_Size\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parAdcResets\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: 1.5\n   * Referenced by: '<Root>/Constant5'\n   */\n  1.5,\n\n  /* Expression: [0.000225702073991021\t0.000226941692700600\t0.000228073287794944\t0.000229094394896881\t0.000230001025806862\t0.000230787649113105\t0.000231447175105064\t0.000231970945074563\t0.000232348725080504\t0.000232568704244421\t0.000232617497635240\t0.000232480153792668\t0.000232140166929364\t0.000231579493842769\t0.000230778575557996\t0.000229716363713601\t0.000228370351692414\t0.000226716610489856\t0.000224729829302366\t0.000222383360808750\t0.000219649271107363\t0.000216498394262206\t0.000212900391401155\t0.000208823814299713\t0.000204236173373925\t0.000199104009996386\t0.000193392973039663\t0.000187067899541950\t0.000180092899380403\t0.000172431443828326\t0.000164046457863377\t0.000154900416084959\t0.000144955442090363\t0.000134173411150651\t0.000122516056019064\t0.000109945075696683\t9.64222469723577e-05\t8.19095385463890e-05\t6.63692275403348e-05\t4.97640181883689e-05\t3.20571624991370e-05\t1.32125826707841e-05\t-6.80500496398180e-06\t-2.80299646914686e-05\t-5.04956151029706e-05\t-7.42341019516690e-05\t-9.92762704232763e-05\t-0.000125651537067 */\n  { 0.000225702073991021, 0.0002269416927006, 0.000228073287794944,\n    0.000229094394896881, 0.000230001025806862, 0.000230787649113105,\n    0.000231447175105064, 0.000231970945074563, 0.000232348725080504,\n    0.000232568704244421, 0.00023261749763524, 0.000232480153792668,\n    0.000232140166929364, 0.000231579493842769, 0.000230778575557996,\n    0.000229716363713601, 0.000228370351692414, 0.000226716610489856,\n    0.000224729829302366, 0.00022238336080875, 0.000219649271107363,\n    0.000216498394262206, 0.000212900391401155, 0.000208823814299713,\n    0.000204236173373925, 0.000199104009996386, 0.000193392973039663,\n    0.00018706789954195, 0.000180092899380403, 0.000172431443828326,\n    0.000164046457863377, 0.000154900416084959, 0.000144955442090363,\n    0.000134173411150651, 0.000122516056019064, 0.000109945075696683,\n    9.64222469723577E-5, 8.1909538546389E-5, 6.63692275403348E-5,\n    4.97640181883689E-5, 3.2057162499137E-5, 1.32125826707841E-5,\n    -6.8050049639818E-6, -2.80299646914686E-5, -5.04956151029706E-5,\n    -7.4234101951669E-5, -9.92762704232763E-5, -0.000125651537067215,\n    -0.000153387761638575, -0.000182511119104207, -0.000213045972068947,\n    -0.000245014743880103, -0.00027843779267018, -0.000313333286598986,\n    -0.000349717080557181, -0.00038760259459362, -0.000427000694328744,\n    -0.000467919573615688, -0.000510364639709676, -0.000554338401204762,\n    -0.000599840358994912, -0.000646866900513922, -0.000695411197505717,\n    -0.000745463107573071, -0.000797009079748875, -0.00085003206432969,\n    -0.000904511427206446, -0.000960422868921823, -0.00101773834867808,\n    -0.00107642601351286, -0.00113645013285391, -0.00119777103865641,\n    -0.0012603450713193, -0.00132412453156891, -0.00138905763848997,\n    -0.00145508849387536, -0.00152215705305684, -0.00159019910236961,\n    -0.00165914624339381, -0.00172892588410581, -0.00179946123706178,\n    -0.0018706713247254, -0.00194247099204039, -0.00201477092633729,\n    -0.00208747768465241, -0.00216049372852516, -0.00223371746632778,\n    -0.00230704330316955, -0.00238036169840505, -0.00245355923076355,\n    -0.00252651867110405, -0.00259911906278754, -0.00267123580964543,\n    -0.00274274077151004, -0.00281350236726, -0.00288338568532052,\n    -0.0029522526015455, -0.00301996190439523, -0.00308636942731078,\n    -0.00315132818817294, -0.00321468853572103, -0.00327629830279398,\n    -0.00333600296624359, -0.00339364581335732, -0.0034490681146158,\n    -0.00350210930259806, -0.00355260715683556, -0.0036003979944046,\n    -0.00364531686603512, -0.00368719775750284, -0.00372587379606085,\n    -0.00376117746165624, -0.00379294080266718, -0.00382099565588594,\n    -0.00384517387046395, -0.00386530753552598, -0.0038812292111516,\n    -0.00389277216241404, -0.00389977059615879, -0.00390205990019657,\n    -0.00389947688457888, -0.00389186002461753, -0.00387904970530374,\n    -0.00386088846677717, -0.00383722125049002, -0.00380789564570727,\n    -0.00377276213597999, -0.00373167434522583, -0.00368448928304747,\n    -0.00363106758891829, -0.00357127377486242, -0.00350497646625564,\n    -0.00343204864037311, -0.00335236786230991, -0.00326581651790142,\n    -0.00317228204327166, -0.00307165715063977, -0.00296384005001729,\n    -0.00284873466643215, -0.00272625085231876, -0.00259630459471808,\n    -0.00245881821693644, -0.0023137205743172, -0.00216094724378546,\n    -0.00200044070683266, -0.00183215052561509, -0.00165603351184777,\n    -0.00147205388818393, -0.00128018344177853, -0.00108040166974393,\n    -0.000872695916215616, -0.000657061500755791, -0.00043350183783405,\n    -0.000202028547135036, 3.73384455450693E-5, 0.000284570817039217,\n    0.000539631765400961, 0.000802475938547229, 0.00107304937313973,\n    0.00135128944387858, 0.00163712482336771, 0.00193047545269738,\n    0.00223125252287434, 0.00253935846721538, 0.0028546869648048,\n    0.00317712295510096, 0.00350654266376141, 0.00384281363974042,\n    0.00418579480369659, 0.00453533650773227, 0.00489128060647039,\n    0.00525346053945768, 0.00562170142486737, 0.00599582016445753,\n    0.00637562555972535, 0.00676091843918081, 0.00715149179664711,\n    0.00754713094047876, 0.00794761365357224, 0.00835271036402771,\n    0.00876218432630468, 0.00917579181269851, 0.00959328231494903,\n    0.0100143987557773, 0.0104388777101313, 0.0108664496359064,\n    0.0112968391138921, 0.011729765096682, 0.0121649411662697, 0.012602075800041,\n    0.0130408726448579, 0.0134810307989176, 0.0139222451010591,\n    0.0143642064271741, 0.0148066019933716, 0.0152491156655328, 0.01569142827488,\n    0.0161332179391791, 0.0165741603891789, 0.0170139292998864,\n    0.0174521966262677, 0.0178886329429541, 0.0183229077875298,\n    0.0187546900069669, 0.0191836481067704, 0.019609450602389,\n    0.0200317663724432, 0.0204502650133184, 0.020864617194666,\n    0.0212744950153552, 0.0216795723594125, 0.0220795252514893,\n    0.0224740322113904, 0.0228627746072046, 0.0232454370065709,\n    0.023621707525621, 0.0239912781751371, 0.0243538452034697, 0.024709109435759,\n    0.0250567766090132, 0.0253965577025959, 0.0257281692636831,\n    0.0260513337272578, 0.0263657797302108, 0.0266712424191306,\n    0.0269674637513685, 0.027254192788974, 0.0275311859851066, 0.027798207462537,\n    0.0280550292838636, 0.0283014317130783, 0.0285372034681286,\n    0.0287621419641341, 0.0289760535469288, 0.0291787537166112,\n    0.0293700673407995, 0.0295498288573027, 0.0297178824659314,\n    0.0298740823091876, 0.0300182926415878, 0.0301503879873876,\n    0.0302702532864951, 0.0303777840283714, 0.0304728863737374, 0.03055547726392,\n    0.0306254845176881, 0.0306828469154475, 0.030727514270677,\n    0.0307594474885113, 0.0307786186113878, 0.0307850108516965,\n    0.0307786186113878, 0.0307594474885113, 0.030727514270677,\n    0.0306828469154475, 0.0306254845176881, 0.03055547726392, 0.0304728863737374,\n    0.0303777840283714, 0.0302702532864951, 0.0301503879873876,\n    0.0300182926415878, 0.0298740823091876, 0.0297178824659314,\n    0.0295498288573027, 0.0293700673407995, 0.0291787537166112,\n    0.0289760535469288, 0.0287621419641341, 0.0285372034681286,\n    0.0283014317130783, 0.0280550292838636, 0.027798207462537,\n    0.0275311859851066, 0.027254192788974, 0.0269674637513685,\n    0.0266712424191306, 0.0263657797302108, 0.0260513337272578,\n    0.0257281692636831, 0.0253965577025959, 0.0250567766090132,\n    0.024709109435759, 0.0243538452034697, 0.0239912781751371, 0.023621707525621,\n    0.0232454370065709, 0.0228627746072046, 0.0224740322113904,\n    0.0220795252514893, 0.0216795723594125, 0.0212744950153552,\n    0.020864617194666, 0.0204502650133184, 0.0200317663724432, 0.019609450602389,\n    0.0191836481067704, 0.0187546900069669, 0.0183229077875298,\n    0.0178886329429541, 0.0174521966262677, 0.0170139292998864,\n    0.0165741603891789, 0.0161332179391791, 0.01569142827488, 0.0152491156655328,\n    0.0148066019933716, 0.0143642064271741, 0.0139222451010591,\n    0.0134810307989176, 0.0130408726448579, 0.012602075800041,\n    0.0121649411662697, 0.011729765096682, 0.0112968391138921,\n    0.0108664496359064, 0.0104388777101313, 0.0100143987557773,\n    0.00959328231494903, 0.00917579181269851, 0.00876218432630468,\n    0.00835271036402771, 0.00794761365357224, 0.00754713094047876,\n    0.00715149179664711, 0.00676091843918081, 0.00637562555972535,\n    0.00599582016445753, 0.00562170142486737, 0.00525346053945768,\n    0.00489128060647039, 0.00453533650773227, 0.00418579480369659,\n    0.00384281363974042, 0.00350654266376141, 0.00317712295510096,\n    0.0028546869648048, 0.00253935846721538, 0.00223125252287434,\n    0.00193047545269738, 0.00163712482336771, 0.00135128944387858,\n    0.00107304937313973, 0.000802475938547229, 0.000539631765400961,\n    0.000284570817039217, 3.73384455450693E-5, -0.000202028547135036,\n    -0.00043350183783405, -0.000657061500755791, -0.000872695916215616,\n    -0.00108040166974393, -0.00128018344177853, -0.00147205388818393,\n    -0.00165603351184777, -0.00183215052561509, -0.00200044070683266,\n    -0.00216094724378546, -0.0023137205743172, -0.00245881821693644,\n    -0.00259630459471808, -0.00272625085231876, -0.00284873466643215,\n    -0.00296384005001729, -0.00307165715063977, -0.00317228204327166,\n    -0.00326581651790142, -0.00335236786230991, -0.00343204864037311,\n    -0.00350497646625564, -0.00357127377486242, -0.00363106758891829,\n    -0.00368448928304747, -0.00373167434522583, -0.00377276213597999,\n    -0.00380789564570727, -0.00383722125049002, -0.00386088846677717,\n    -0.00387904970530374, -0.00389186002461753, -0.00389947688457888,\n    -0.00390205990019657, -0.00389977059615879, -0.00389277216241404,\n    -0.0038812292111516, -0.00386530753552598, -0.00384517387046395,\n    -0.00382099565588594, -0.00379294080266718, -0.00376117746165624,\n    -0.00372587379606085, -0.00368719775750284, -0.00364531686603512,\n    -0.0036003979944046, -0.00355260715683556, -0.00350210930259806,\n    -0.0034490681146158, -0.00339364581335732, -0.00333600296624359,\n    -0.00327629830279398, -0.00321468853572103, -0.00315132818817294,\n    -0.00308636942731078, -0.00301996190439523, -0.0029522526015455,\n    -0.00288338568532052, -0.00281350236726, -0.00274274077151004,\n    -0.00267123580964543, -0.00259911906278754, -0.00252651867110405,\n    -0.00245355923076355, -0.00238036169840505, -0.00230704330316955,\n    -0.00223371746632778, -0.00216049372852516, -0.00208747768465241,\n    -0.00201477092633729, -0.00194247099204039, -0.0018706713247254,\n    -0.00179946123706178, -0.00172892588410581, -0.00165914624339381,\n    -0.00159019910236961, -0.00152215705305684, -0.00145508849387536,\n    -0.00138905763848997, -0.00132412453156891, -0.0012603450713193,\n    -0.00119777103865641, -0.00113645013285391, -0.00107642601351286,\n    -0.00101773834867808, -0.000960422868921823, -0.000904511427206446,\n    -0.00085003206432969, -0.000797009079748875, -0.000745463107573071,\n    -0.000695411197505717, -0.000646866900513922, -0.000599840358994912,\n    -0.000554338401204762, -0.000510364639709676, -0.000467919573615688,\n    -0.000427000694328744, -0.00038760259459362, -0.000349717080557181,\n    -0.000313333286598986, -0.00027843779267018, -0.000245014743880103,\n    -0.000213045972068947, -0.000182511119104207, -0.000153387761638575,\n    -0.000125651537067215, -9.92762704232763E-5, -7.4234101951669E-5,\n    -5.04956151029706E-5, -2.80299646914686E-5, -6.8050049639818E-6,\n    1.32125826707841E-5, 3.2057162499137E-5, 4.97640181883689E-5,\n    6.63692275403348E-5, 8.1909538546389E-5, 9.64222469723577E-5,\n    0.000109945075696683, 0.000122516056019064, 0.000134173411150651,\n    0.000144955442090363, 0.000154900416084959, 0.000164046457863377,\n    0.000172431443828326, 0.000180092899380403, 0.00018706789954195,\n    0.000193392973039663, 0.000199104009996386, 0.000204236173373925,\n    0.000208823814299713, 0.000212900391401155, 0.000216498394262206,\n    0.000219649271107363, 0.00022238336080875, 0.000224729829302366,\n    0.000226716610489856, 0.000228370351692414, 0.000229716363713601,\n    0.000230778575557996, 0.000231579493842769, 0.000232140166929364,\n    0.000232480153792668, 0.00023261749763524, 0.000232568704244421,\n    0.000232348725080504, 0.000231970945074563, 0.000231447175105064,\n    0.000230787649113105, 0.000230001025806862, 0.000229094394896881,\n    0.000228073287794944, 0.0002269416927006, 0.000225702073991021 },\n\n  /* Expression: 1\n   * Referenced by: '<Root>/Discrete Filter'\n   */\n  1.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Discrete Filter'\n   */\n  0.0,\n\n  /* Expression: 0.5\n   * Referenced by: '<S10>/Constant1'\n   */\n  0.5,\n\n  /* Expression: 80\n   * Referenced by: '<S10>/Constant2'\n   */\n  80.0,\n\n  /* Expression: 2\n   * Referenced by: '<S10>/Constant5'\n   */\n  2.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Constant4'\n   */\n  0.0,\n\n  /* Expression: 1\n   * Referenced by: '<Root>/Constant2'\n   */\n  1.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Delay'\n   */\n  0.0,\n\n  /* Expression: 2\n   * Referenced by: '<Root>/Constant1'\n   */\n  2.0,\n\n  /* Expression: 1\n   * Referenced by: '<S9>/Constant'\n   */\n  1.0,\n\n  /* Expression: 0.002\n   * Referenced by: '<S9>/Constant1'\n   */\n  0.002,\n\n  /* Expression: 1\n   * Referenced by: '<Root>/Constant3'\n   */\n  1.0,\n\n  /* Computed Parameter: Digitalinput_P1_Size\n   * Referenced by: '<Root>/Digital input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parModuleId\n   * Referenced by: '<Root>/Digital input '\n   */\n  1.0,\n\n  /* Computed Parameter: Digitalinput_P2_Size\n   * Referenced by: '<Root>/Digital input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parSampleTime\n   * Referenced by: '<Root>/Digital input '\n   */\n  0.001,\n\n  /* Computed Parameter: Digitalinput_P3_Size\n   * Referenced by: '<Root>/Digital input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parPciSlot\n   * Referenced by: '<Root>/Digital input '\n   */\n  -1.0,\n\n  /* Computed Parameter: Digitalinput_P4_Size\n   * Referenced by: '<Root>/Digital input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parDiChannels\n   * Referenced by: '<Root>/Digital input '\n   */\n  14.0\n};\n\nJOLT_cal_type *JOLT_cal = &JOLT_cal_impl;\n"},{"name":"JOLT_cal.h","type":"header","group":"data","path":"/home/electro/Code_Repo/n-CORTEx/JOLT_slrealtime_rtw","tag":"","groupDisplay":"Data files","code":"#ifndef RTW_HEADER_JOLT_cal_h_\n#define RTW_HEADER_JOLT_cal_h_\n#include \"rtwtypes.h\"\n\n/* Storage class 'PageSwitching', for system '<Root>' */\nstruct JOLT_cal_type {\n  real_T T_npxls;                      /* Variable: T_npxls\n                                        * Referenced by: '<Root>/Npxls Trig'\n                                        */\n  real_T Memory2_InitialCondition;     /* Expression: 0\n                                        * Referenced by: '<Root>/Memory2'\n                                        */\n  real_T Setup_P1_Size[2];             /* Computed Parameter: Setup_P1_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P1;                     /* Expression: parPciSlot\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P2_Size[2];             /* Computed Parameter: Setup_P2_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P2;                     /* Expression: parModuleId\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P3_Size[2];             /* Computed Parameter: Setup_P3_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P3;                     /* Expression: parTriggerSignal\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P4_Size[2];             /* Computed Parameter: Setup_P4_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P4[2];                  /* Expression: parAdcChannels\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P5_Size[2];             /* Computed Parameter: Setup_P5_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P5;                     /* Expression: parAdcMode\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P6_Size[2];             /* Computed Parameter: Setup_P6_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P6[2];                  /* Expression: parAdcRanges\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P7_Size[2];             /* Computed Parameter: Setup_P7_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P7[2];                  /* Expression: parDacChannels\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P8_Size[2];             /* Computed Parameter: Setup_P8_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P8[2];                  /* Expression: parDacRanges\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P9_Size[2];             /* Computed Parameter: Setup_P9_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P9[8];                  /* Expression: parDioFirstControl\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Constant_Value;               /* Expression: 1\n                                        * Referenced by: '<Root>/Constant'\n                                        */\n  real_T Memory1_InitialCondition;     /* Expression: 0\n                                        * Referenced by: '<Root>/Memory1'\n                                        */\n  real_T NpxlsTrig_Amp;                /* Expression: 2.5\n                                        * Referenced by: '<Root>/Npxls Trig'\n                                        */\n  real_T NpxlsTrig_PhaseDelay;         /* Expression: 0\n                                        * Referenced by: '<Root>/Npxls Trig'\n                                        */\n  real_T Constant_Value_c;             /* Expression: 2.5\n                                        * Referenced by: '<S6>/Constant'\n                                        */\n  real_T Constant1_Value;              /* Expression: 8\n                                        * Referenced by: '<S6>/Constant1'\n                                        */\n  real_T Constant_Value_a;             /* Expression: 1\n                                        * Referenced by: '<S8>/Constant'\n                                        */\n  real_T Constant1_Value_p;            /* Expression: 4\n                                        * Referenced by: '<S8>/Constant1'\n                                        */\n  real_T Constant_Value_j;             /* Expression: 1\n                                        * Referenced by: '<S7>/Constant'\n                                        */\n  real_T Constant1_Value_k;            /* Expression: 1\n                                        * Referenced by: '<S7>/Constant1'\n                                        */\n  real_T Digitaloutput_P1_Size[2];  /* Computed Parameter: Digitaloutput_P1_Size\n                                     * Referenced by: '<Root>/Digital output '\n                                     */\n  real_T Digitaloutput_P1;             /* Expression: parModuleId\n                                        * Referenced by: '<Root>/Digital output '\n                                        */\n  real_T Digitaloutput_P2_Size[2];  /* Computed Parameter: Digitaloutput_P2_Size\n                                     * Referenced by: '<Root>/Digital output '\n                                     */\n  real_T Digitaloutput_P2;             /* Expression: parSampleTime\n                                        * Referenced by: '<Root>/Digital output '\n                                        */\n  real_T Digitaloutput_P3_Size[2];  /* Computed Parameter: Digitaloutput_P3_Size\n                                     * Referenced by: '<Root>/Digital output '\n                                     */\n  real_T Digitaloutput_P3;             /* Expression: parPciSlot\n                                        * Referenced by: '<Root>/Digital output '\n                                        */\n  real_T Digitaloutput_P4_Size[2];  /* Computed Parameter: Digitaloutput_P4_Size\n                                     * Referenced by: '<Root>/Digital output '\n                                     */\n  real_T Digitaloutput_P4[15];         /* Expression: parDoChannels\n                                        * Referenced by: '<Root>/Digital output '\n                                        */\n  real_T Digitaloutput_P5_Size[2];  /* Computed Parameter: Digitaloutput_P5_Size\n                                     * Referenced by: '<Root>/Digital output '\n                                     */\n  real_T Digitaloutput_P5[15];         /* Expression: parDoInitValues\n                                        * Referenced by: '<Root>/Digital output '\n                                        */\n  real_T Digitaloutput_P6_Size[2];  /* Computed Parameter: Digitaloutput_P6_Size\n                                     * Referenced by: '<Root>/Digital output '\n                                     */\n  real_T Digitaloutput_P6[15];         /* Expression: parDoResets\n                                        * Referenced by: '<Root>/Digital output '\n                                        */\n  real_T Analoginput_P1_Size[2];      /* Computed Parameter: Analoginput_P1_Size\n                                       * Referenced by: '<Root>/Analog input '\n                                       */\n  real_T Analoginput_P1;               /* Expression: parModuleId\n                                        * Referenced by: '<Root>/Analog input '\n                                        */\n  real_T Analoginput_P2_Size[2];      /* Computed Parameter: Analoginput_P2_Size\n                                       * Referenced by: '<Root>/Analog input '\n                                       */\n  real_T Analoginput_P2;               /* Expression: parSampleTime\n                                        * Referenced by: '<Root>/Analog input '\n                                        */\n  real_T Analoginput_P3_Size[2];      /* Computed Parameter: Analoginput_P3_Size\n                                       * Referenced by: '<Root>/Analog input '\n                                       */\n  real_T Analoginput_P3;               /* Expression: parPciSlot\n                                        * Referenced by: '<Root>/Analog input '\n                                        */\n  real_T Analoginput_P4_Size[2];      /* Computed Parameter: Analoginput_P4_Size\n                                       * Referenced by: '<Root>/Analog input '\n                                       */\n  real_T Analoginput_P4[2];            /* Expression: parAdcChannels\n                                        * Referenced by: '<Root>/Analog input '\n                                        */\n  real_T Analoginput_P5_Size[2];      /* Computed Parameter: Analoginput_P5_Size\n                                       * Referenced by: '<Root>/Analog input '\n                                       */\n  real_T Analoginput_P5;               /* Expression: parAdcMode\n                                        * Referenced by: '<Root>/Analog input '\n                                        */\n  real_T Analoginput_P6_Size[2];      /* Computed Parameter: Analoginput_P6_Size\n                                       * Referenced by: '<Root>/Analog input '\n                                       */\n  real_T Analoginput_P6;               /* Expression: parAdcRate\n                                        * Referenced by: '<Root>/Analog input '\n                                        */\n  real_T Analoginput_P7_Size[2];      /* Computed Parameter: Analoginput_P7_Size\n                                       * Referenced by: '<Root>/Analog input '\n                                       */\n  real_T Analoginput_P7[2];            /* Expression: parAdcRanges\n                                        * Referenced by: '<Root>/Analog input '\n                                        */\n  real_T Analoginput_P8_Size[2];      /* Computed Parameter: Analoginput_P8_Size\n                                       * Referenced by: '<Root>/Analog input '\n                                       */\n  real_T Analoginput_P8[2];            /* Expression: parAdcInitValues\n                                        * Referenced by: '<Root>/Analog input '\n                                        */\n  real_T Analoginput_P9_Size[2];      /* Computed Parameter: Analoginput_P9_Size\n                                       * Referenced by: '<Root>/Analog input '\n                                       */\n  real_T Analoginput_P9[2];            /* Expression: parAdcResets\n                                        * Referenced by: '<Root>/Analog input '\n                                        */\n  real_T Constant5_Value;              /* Expression: 1.5\n                                        * Referenced by: '<Root>/Constant5'\n                                        */\n  real_T DiscreteFilter_NumCoef[501];\n  /* Expression: [0.000225702073991021\t0.000226941692700600\t0.000228073287794944\t0.000229094394896881\t0.000230001025806862\t0.000230787649113105\t0.000231447175105064\t0.000231970945074563\t0.000232348725080504\t0.000232568704244421\t0.000232617497635240\t0.000232480153792668\t0.000232140166929364\t0.000231579493842769\t0.000230778575557996\t0.000229716363713601\t0.000228370351692414\t0.000226716610489856\t0.000224729829302366\t0.000222383360808750\t0.000219649271107363\t0.000216498394262206\t0.000212900391401155\t0.000208823814299713\t0.000204236173373925\t0.000199104009996386\t0.000193392973039663\t0.000187067899541950\t0.000180092899380403\t0.000172431443828326\t0.000164046457863377\t0.000154900416084959\t0.000144955442090363\t0.000134173411150651\t0.000122516056019064\t0.000109945075696683\t9.64222469723577e-05\t8.19095385463890e-05\t6.63692275403348e-05\t4.97640181883689e-05\t3.20571624991370e-05\t1.32125826707841e-05\t-6.80500496398180e-06\t-2.80299646914686e-05\t-5.04956151029706e-05\t-7.42341019516690e-05\t-9.92762704232763e-05\t-0.000125651537067215\t-0.000153387761638575\t-0.000182511119104207\t-0.000213045972068947\t-0.000245014743880103\t-0.000278437792670180\t-0.000313333286598986\t-0.000349717080557181\t-0.000387602594593620\t-0.000427000694328744\t-0.000467919573615688\t-0.000510364639709676\t-0.000554338401204762\t-0.000599840358994912\t-0.000646866900513922\t-0.000695411197505717\t-0.000745463107573071\t-0.000797009079748875\t-0.000850032064329690\t-0.000904511427206446\t-0.000960422868921823\t-0.00101773834867808\t-0.00107642601351286\t-0.00113645013285391\t-0.00119777103865641\t-0.00126034507131930\t-0.00132412453156891\t-0.00138905763848997\t-0.00145508849387536\t-0.00152215705305684\t-0.00159019910236961\t-0.00165914624339381\t-0.00172892588410581\t-0.00179946123706178\t-0.00187067132472540\t-0.00194247099204039\t-0.00201477092633729\t-0.00208747768465241\t-0.00216049372852516\t-0.00223371746632778\t-0.00230704330316955\t-0.00238036169840505\t-0.00245355923076355\t-0.00252651867110405\t-0.00259911906278754\t-0.00267123580964543\t-0.00274274077151004\t-0.00281350236726000\t-0.00288338568532052\t-0.00295225260154550\t-0.00301996190439523\t-0.00308636942731078\t-0.00315132818817294\t-0.00321468853572103\t-0.00327629830279398\t-0.00333600296624359\t-0.00339364581335732\t-0.00344906811461580\t-0.00350210930259806\t-0.00355260715683556\t-0.00360039799440460\t-0.00364531686603512\t-0.00368719775750284\t-0.00372587379606085\t-0.00376117746165624\t-0.00379294080266718\t-0.00382099565588594\t-0.00384517387046395\t-0.00386530753552598\t-0.00388122921115160\t-0.00389277216241404\t-0.00389977059615879\t-0.00390205990019657\t-0.00389947688457888\t-0.00389186002461753\t-0.00387904970530374\t-0.00386088846677717\t-0.00383722125049002\t-0.00380789564570727\t-0.00377276213597999\t-0.00373167434522583\t-0.00368448928304747\t-0.00363106758891829\t-0.00357127377486242\t-0.00350497646625564\t-0.00343204864037311\t-0.00335236786230991\t-0.00326581651790142\t-0.00317228204327166\t-0.00307165715063977\t-0.00296384005001729\t-0.00284873466643215\t-0.00272625085231876\t-0.00259630459471808\t-0.00245881821693644\t-0.00231372057431720\t-0.00216094724378546\t-0.00200044070683266\t-0.00183215052561509\t-0.00165603351184777\t-0.00147205388818393\t-0.00128018344177853\t-0.00108040166974393\t-0.000872695916215616\t-0.000657061500755791\t-0.000433501837834050\t-0.000202028547135036\t3.73384455450693e-05\t0.000284570817039217\t0.000539631765400961\t0.000802475938547229\t0.00107304937313973\t0.00135128944387858\t0.00163712482336771\t0.00193047545269738\t0.00223125252287434\t0.00253935846721538\t0.00285468696480480\t0.00317712295510096\t0.00350654266376141\t0.00384281363974042\t0.00418579480369659\t0.00453533650773227\t0.00489128060647039\t0.00525346053945768\t0.00562170142486737\t0.00599582016445753\t0.00637562555972535\t0.00676091843918081\t0.00715149179664711\t0.00754713094047876\t0.00794761365357224\t0.00835271036402771\t0.00876218432630468\t0.00917579181269851\t0.00959328231494903\t0.0100143987557773\t0.0104388777101313\t0.0108664496359064\t0.0112968391138921\t0.0117297650966820\t0.0121649411662697\t0.0126020758000410\t0.0130408726448579\t0.0134810307989176\t0.0139222451010591\t0.0143642064271741\t0.0148066019933716\t0.0152491156655328\t0.0156914282748800\t0.0161332179391791\t0.0165741603891789\t0.0170139292998864\t0.0174521966262677\t0.0178886329429541\t0.0183229077875298\t0.0187546900069669\t0.0191836481067704\t0.0196094506023890\t0.0200317663724432\t0.0204502650133184\t0.0208646171946660\t0.0212744950153552\t0.0216795723594125\t0.0220795252514893\t0.0224740322113904\t0.0228627746072046\t0.0232454370065709\t0.0236217075256210\t0.0239912781751371\t0.0243538452034697\t0.0247091094357590\t0.0250567766090132\t0.0253965577025959\t0.0257281692636831\t0.0260513337272578\t0.0263657797302108\t0.0266712424191306\t0.0269674637513685\t0.0272541927889740\t0.0275311859851066\t0.0277982074625370\t0.0280550292838636\t0.0283014317130783\t0.0285372034681286\t0.0287621419641341\t0.0289760535469288\t0.0291787537166112\t0.0293700673407995\t0.0295498288573027\t0.0297178824659314\t0.0298740823091876\t0.0300182926415878\t0.0301503879873876\t0.0302702532864951\t0.0303777840283714\t0.0304728863737374\t0.0305554772639200\t0.0306254845176881\t0.0306828469154475\t0.0307275142706770\t0.0307594474885113\t0.0307786186113878\t0.0307850108516965\t0.0307786186113878\t0.0307594474885113\t0.0307275142706770\t0.0306828469154475\t0.0306254845176881\t0.0305554772639200\t0.0304728863737374\t0.0303777840283714\t0.0302702532864951\t0.0301503879873876\t0.0300182926415878\t0.0298740823091876\t0.0297178824659314\t0.0295498288573027\t0.0293700673407995\t0.0291787537166112\t0.0289760535469288\t0.0287621419641341\t0.0285372034681286\t0.0283014317130783\t0.0280550292838636\t0.0277982074625370\t0.0275311859851066\t0.0272541927889740\t0.0269674637513685\t0.0266712424191306\t0.0263657797302108\t0.0260513337272578\t0.0257281692636831\t0.0253965577025959\t0.0250567766090132\t0.0247091094357590\t0.0243538452034697\t0.0239912781751371\t0.0236217075256210\t0.0232454370065709\t0.0228627746072046\t0.0224740322113904\t0.0220795252514893\t0.0216795723594125\t0.0212744950153552\t0.0208646171946660\t0.0204502650133184\t0.0200317663724432\t0.0196094506023890\t0.0191836481067704\t0.0187546900069669\t0.0183229077875298\t0.0178886329429541\t0.0174521966262677\t0.0170139292998864\t0.0165741603891789\t0.0161332179391791\t0.0156914282748800\t0.0152491156655328\t0.0148066019933716\t0.0143642064271741\t0.0139222451010591\t0.0134810307989176\t0.0130408726448579\t0.0126020758000410\t0.0121649411662697\t0.0117297650966820\t0.0112968391138921\t0.0108664496359064\t0.0104388777101313\t0.0100143987557773\t0.00959328231494903\t0.00917579181269851\t0.00876218432630468\t0.00835271036402771\t0.00794761365357224\t0.00754713094047876\t0.00715149179664711\t0.00676091843918081\t0.00637562555972535\t0.00599582016445753\t0.00562170142486737\t0.00525346053945768\t0.00489128060647039\t0.00453533650773227\t0.00418579480369659\t0.00384281363974042\t0.00350654266376141\t0.00317712295510096\t0.00285468696480480\t0.00253935846721538\t0.00223125252287434\t0.00193047545269738\t0.00163712482336771\t0.00135128944387858\t0.00107304937313973\t0.000802475938547229\t0.000539631765400961\t0.000284570817039217\t3.73384455450693e-05\t-0.000202028547135036\t-0.000433501837834050\t-0.000657061500755791\t-0.000872695916215616\t-0.00108040166974393\t-0.00128018344177853\t-0.00147205388818393\t-0.00165603351184777\t-0.00183215052561509\t-0.00200044070683266\t-0.00216094724378546\t-0.00231372057431720\t-0.00245881821693644\t-0.00259630459471808\t-0.00272625085231876\t-0.00284873466643215\t-0.00296384005001729\t-0.00307165715063977\t-0.00317228204327166\t-0.00326581651790142\t-0.00335236786230991\t-0.00343204864037311\t-0.00350497646625564\t-0.00357127377486242\t-0.00363106758891829\t-0.00368448928304747\t-0.00373167434522583\t-0.00377276213597999\t-0.00380789564570727\t-0.00383722125049002\t-0.00386088846677717\t-0.00387904970530374\t-0.00389186002461753\t-0.00389947688457888\t-0.00390205990019657\t-0.00389977059615879\t-0.00389277216241404\t-0.00388122921115160\t-0.00386530753552598\t-0.00384517387046395\t-0.00382099565588594\t-0.00379294080266718\t-0.00376117746165624\t-0.00372587379606085\t-0.00368719775750284\t-0.00364531686603512\t-0.00360039799440460\t-0.00355260715683556\t-0.00350210930259806\t-0.00344906811461580\t-0.00339364581335732\t-0.00333600296624359\t-0.00327629830279398\t-0.00321468853572103\t-0.00315132818817294\t-0.00308636942731078\t-0.00301996190439523\t-0.00295225260154550\t-0.00288338568532052\t-0.00281350236726000\t-0.00274274077151004\t-0.00267123580964543\t-0.00259911906278754\t-0.00252651867110405\t-0.00245355923076355\t-0.00238036169840505\t-0.00230704330316955\t-0.00223371746632778\t-0.00216049372852516\t-0.00208747768465241\t-0.00201477092633729\t-0.00194247099204039\t-0.00187067132472540\t-0.00179946123706178\t-0.00172892588410581\t-0.00165914624339381\t-0.00159019910236961\t-0.00152215705305684\t-0.00145508849387536\t-0.00138905763848997\t-0.00132412453156891\t-0.00126034507131930\t-0.00119777103865641\t-0.00113645013285391\t-0.00107642601351286\t-0.00101773834867808\t-0.000960422868921823\t-0.000904511427206446\t-0.000850032064329690\t-0.000797009079748875\t-0.000745463107573071\t-0.000695411197505717\t-0.000646866900513922\t-0.000599840358994912\t-0.000554338401204762\t-0.000510364639709676\t-0.000467919573615688\t-0.000427000694328744\t-0.000387602594593620\t-0.000349717080557181\t-0.000313333286598986\t-0.000278437792670180\t-0.000245014743880103\t-0.000213045972068947\t-0.000182511119104207\t-0.000153387761638575\t-0.000125651537067215\t-9.92762704232763e-05\t-7.42341019516690e-05\t-5.04956151029706e-05\t-2.80299646914686e-05\t-6.80500496398180e-06\t1.32125826707841e-05\t3.20571624991370e-05\t4.97640181883689e-05\t6.63692275403348e-05\t8.19095385463890e-05\t9.64222469723577e-05\t0.000109945075696683\t0.000122516056019064\t0.000134173411150651\t0.000144955442090363\t0.000154900416084959\t0.000164046457863377\t0.000172431443828326\t0.000180092899380403\t0.000187067899541950\t0.000193392973039663\t0.000199104009996386\t0.000204236173373925\t0.000208823814299713\t0.000212900391401155\t0.000216498394262206\t0.000219649271107363\t0.000222383360808750\t0.000224729829302366\t0.000226716610489856\t0.000228370351692414\t0.000229716363713601\t0.000230778575557996\t0.000231579493842769\t0.000232140166929364\t0.000232480153792668\t0.000232617497635240\t0.000232568704244421\t0.000232348725080504\t0.000231970945074563\t0.000231447175105064\t0.000230787649113105\t0.000230001025806862\t0.000229094394896881\t0.000228073287794944\t0.000226941692700600\t0.000225702073991021]\n   * Referenced by: '<Root>/Discrete Filter'\n   */\n  real_T DiscreteFilter_DenCoef;       /* Expression: 1\n                                        * Referenced by: '<Root>/Discrete Filter'\n                                        */\n  real_T DiscreteFilter_InitialStates; /* Expression: 0\n                                        * Referenced by: '<Root>/Discrete Filter'\n                                        */\n  real_T Constant1_Value_d;            /* Expression: 0.5\n                                        * Referenced by: '<S10>/Constant1'\n                                        */\n  real_T Constant2_Value;              /* Expression: 80\n                                        * Referenced by: '<S10>/Constant2'\n                                        */\n  real_T Constant5_Value_k;            /* Expression: 2\n                                        * Referenced by: '<S10>/Constant5'\n                                        */\n  real_T Constant4_Value;              /* Expression: 0\n                                        * Referenced by: '<Root>/Constant4'\n                                        */\n  real_T Constant2_Value_c;            /* Expression: 1\n                                        * Referenced by: '<Root>/Constant2'\n                                        */\n  real_T Delay_InitialCondition;       /* Expression: 0\n                                        * Referenced by: '<Root>/Delay'\n                                        */\n  real_T Constant1_Value_b;            /* Expression: 2\n                                        * Referenced by: '<Root>/Constant1'\n                                        */\n  real_T Constant_Value_n;             /* Expression: 1\n                                        * Referenced by: '<S9>/Constant'\n                                        */\n  real_T Constant1_Value_bz;           /* Expression: 0.002\n                                        * Referenced by: '<S9>/Constant1'\n                                        */\n  real_T Constant3_Value;              /* Expression: 1\n                                        * Referenced by: '<Root>/Constant3'\n                                        */\n  real_T Digitalinput_P1_Size[2];    /* Computed Parameter: Digitalinput_P1_Size\n                                      * Referenced by: '<Root>/Digital input '\n                                      */\n  real_T Digitalinput_P1;              /* Expression: parModuleId\n                                        * Referenced by: '<Root>/Digital input '\n                                        */\n  real_T Digitalinput_P2_Size[2];    /* Computed Parameter: Digitalinput_P2_Size\n                                      * Referenced by: '<Root>/Digital input '\n                                      */\n  real_T Digitalinput_P2;              /* Expression: parSampleTime\n                                        * Referenced by: '<Root>/Digital input '\n                                        */\n  real_T Digitalinput_P3_Size[2];    /* Computed Parameter: Digitalinput_P3_Size\n                                      * Referenced by: '<Root>/Digital input '\n                                      */\n  real_T Digitalinput_P3;              /* Expression: parPciSlot\n                                        * Referenced by: '<Root>/Digital input '\n                                        */\n  real_T Digitalinput_P4_Size[2];    /* Computed Parameter: Digitalinput_P4_Size\n                                      * Referenced by: '<Root>/Digital input '\n                                      */\n  real_T Digitalinput_P4;              /* Expression: parDiChannels\n                                        * Referenced by: '<Root>/Digital input '\n                                        */\n};\n\n/* Storage class 'PageSwitching' */\nextern JOLT_cal_type JOLT_cal_impl;\nextern JOLT_cal_type *JOLT_cal;\n\n#endif                                 /* RTW_HEADER_JOLT_cal_h_ */\n"},{"name":"multiword_types.h","type":"header","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/JOLT_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * multiword_types.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"JOLT\".\n *\n * Model version              : 1.375\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Fri Dec  1 17:02:18 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef MULTIWORD_TYPES_H\n#define MULTIWORD_TYPES_H\n#include \"rtwtypes.h\"\n\n/*\n * Definitions supporting external data access\n */\ntypedef int64_T chunk_T;\ntypedef uint64_T uchunk_T;\n\n/*\n * MultiWord supporting definitions\n */\ntypedef long long longlong_T;\n\n/*\n * MultiWord types\n */\ntypedef struct {\n  uint64_T chunks[2];\n} int128m_T;\n\ntypedef struct {\n  int128m_T re;\n  int128m_T im;\n} cint128m_T;\n\ntypedef struct {\n  uint64_T chunks[2];\n} uint128m_T;\n\ntypedef struct {\n  uint128m_T re;\n  uint128m_T im;\n} cuint128m_T;\n\ntypedef struct {\n  uint64_T chunks[3];\n} int192m_T;\n\ntypedef struct {\n  int192m_T re;\n  int192m_T im;\n} cint192m_T;\n\ntypedef struct {\n  uint64_T chunks[3];\n} uint192m_T;\n\ntypedef struct {\n  uint192m_T re;\n  uint192m_T im;\n} cuint192m_T;\n\ntypedef struct {\n  uint64_T chunks[4];\n} int256m_T;\n\ntypedef struct {\n  int256m_T re;\n  int256m_T im;\n} cint256m_T;\n\ntypedef struct {\n  uint64_T chunks[4];\n} uint256m_T;\n\ntypedef struct {\n  uint256m_T re;\n  uint256m_T im;\n} cuint256m_T;\n\ntypedef struct {\n  uint64_T chunks[5];\n} int320m_T;\n\ntypedef struct {\n  int320m_T re;\n  int320m_T im;\n} cint320m_T;\n\ntypedef struct {\n  uint64_T chunks[5];\n} uint320m_T;\n\ntypedef struct {\n  uint320m_T re;\n  uint320m_T im;\n} cuint320m_T;\n\ntypedef struct {\n  uint64_T chunks[6];\n} int384m_T;\n\ntypedef struct {\n  int384m_T re;\n  int384m_T im;\n} cint384m_T;\n\ntypedef struct {\n  uint64_T chunks[6];\n} uint384m_T;\n\ntypedef struct {\n  uint384m_T re;\n  uint384m_T im;\n} cuint384m_T;\n\ntypedef struct {\n  uint64_T chunks[7];\n} int448m_T;\n\ntypedef struct {\n  int448m_T re;\n  int448m_T im;\n} cint448m_T;\n\ntypedef struct {\n  uint64_T chunks[7];\n} uint448m_T;\n\ntypedef struct {\n  uint448m_T re;\n  uint448m_T im;\n} cuint448m_T;\n\ntypedef struct {\n  uint64_T chunks[8];\n} int512m_T;\n\ntypedef struct {\n  int512m_T re;\n  int512m_T im;\n} cint512m_T;\n\ntypedef struct {\n  uint64_T chunks[8];\n} uint512m_T;\n\ntypedef struct {\n  uint512m_T re;\n  uint512m_T im;\n} cuint512m_T;\n\ntypedef struct {\n  uint64_T chunks[9];\n} int576m_T;\n\ntypedef struct {\n  int576m_T re;\n  int576m_T im;\n} cint576m_T;\n\ntypedef struct {\n  uint64_T chunks[9];\n} uint576m_T;\n\ntypedef struct {\n  uint576m_T re;\n  uint576m_T im;\n} cuint576m_T;\n\ntypedef struct {\n  uint64_T chunks[10];\n} int640m_T;\n\ntypedef struct {\n  int640m_T re;\n  int640m_T im;\n} cint640m_T;\n\ntypedef struct {\n  uint64_T chunks[10];\n} uint640m_T;\n\ntypedef struct {\n  uint640m_T re;\n  uint640m_T im;\n} cuint640m_T;\n\ntypedef struct {\n  uint64_T chunks[11];\n} int704m_T;\n\ntypedef struct {\n  int704m_T re;\n  int704m_T im;\n} cint704m_T;\n\ntypedef struct {\n  uint64_T chunks[11];\n} uint704m_T;\n\ntypedef struct {\n  uint704m_T re;\n  uint704m_T im;\n} cuint704m_T;\n\ntypedef struct {\n  uint64_T chunks[12];\n} int768m_T;\n\ntypedef struct {\n  int768m_T re;\n  int768m_T im;\n} cint768m_T;\n\ntypedef struct {\n  uint64_T chunks[12];\n} uint768m_T;\n\ntypedef struct {\n  uint768m_T re;\n  uint768m_T im;\n} cuint768m_T;\n\ntypedef struct {\n  uint64_T chunks[13];\n} int832m_T;\n\ntypedef struct {\n  int832m_T re;\n  int832m_T im;\n} cint832m_T;\n\ntypedef struct {\n  uint64_T chunks[13];\n} uint832m_T;\n\ntypedef struct {\n  uint832m_T re;\n  uint832m_T im;\n} cuint832m_T;\n\ntypedef struct {\n  uint64_T chunks[14];\n} int896m_T;\n\ntypedef struct {\n  int896m_T re;\n  int896m_T im;\n} cint896m_T;\n\ntypedef struct {\n  uint64_T chunks[14];\n} uint896m_T;\n\ntypedef struct {\n  uint896m_T re;\n  uint896m_T im;\n} cuint896m_T;\n\ntypedef struct {\n  uint64_T chunks[15];\n} int960m_T;\n\ntypedef struct {\n  int960m_T re;\n  int960m_T im;\n} cint960m_T;\n\ntypedef struct {\n  uint64_T chunks[15];\n} uint960m_T;\n\ntypedef struct {\n  uint960m_T re;\n  uint960m_T im;\n} cuint960m_T;\n\ntypedef struct {\n  uint64_T chunks[16];\n} int1024m_T;\n\ntypedef struct {\n  int1024m_T re;\n  int1024m_T im;\n} cint1024m_T;\n\ntypedef struct {\n  uint64_T chunks[16];\n} uint1024m_T;\n\ntypedef struct {\n  uint1024m_T re;\n  uint1024m_T im;\n} cuint1024m_T;\n\ntypedef struct {\n  uint64_T chunks[17];\n} int1088m_T;\n\ntypedef struct {\n  int1088m_T re;\n  int1088m_T im;\n} cint1088m_T;\n\ntypedef struct {\n  uint64_T chunks[17];\n} uint1088m_T;\n\ntypedef struct {\n  uint1088m_T re;\n  uint1088m_T im;\n} cuint1088m_T;\n\ntypedef struct {\n  uint64_T chunks[18];\n} int1152m_T;\n\ntypedef struct {\n  int1152m_T re;\n  int1152m_T im;\n} cint1152m_T;\n\ntypedef struct {\n  uint64_T chunks[18];\n} uint1152m_T;\n\ntypedef struct {\n  uint1152m_T re;\n  uint1152m_T im;\n} cuint1152m_T;\n\ntypedef struct {\n  uint64_T chunks[19];\n} int1216m_T;\n\ntypedef struct {\n  int1216m_T re;\n  int1216m_T im;\n} cint1216m_T;\n\ntypedef struct {\n  uint64_T chunks[19];\n} uint1216m_T;\n\ntypedef struct {\n  uint1216m_T re;\n  uint1216m_T im;\n} cuint1216m_T;\n\ntypedef struct {\n  uint64_T chunks[20];\n} int1280m_T;\n\ntypedef struct {\n  int1280m_T re;\n  int1280m_T im;\n} cint1280m_T;\n\ntypedef struct {\n  uint64_T chunks[20];\n} uint1280m_T;\n\ntypedef struct {\n  uint1280m_T re;\n  uint1280m_T im;\n} cuint1280m_T;\n\ntypedef struct {\n  uint64_T chunks[21];\n} int1344m_T;\n\ntypedef struct {\n  int1344m_T re;\n  int1344m_T im;\n} cint1344m_T;\n\ntypedef struct {\n  uint64_T chunks[21];\n} uint1344m_T;\n\ntypedef struct {\n  uint1344m_T re;\n  uint1344m_T im;\n} cuint1344m_T;\n\ntypedef struct {\n  uint64_T chunks[22];\n} int1408m_T;\n\ntypedef struct {\n  int1408m_T re;\n  int1408m_T im;\n} cint1408m_T;\n\ntypedef struct {\n  uint64_T chunks[22];\n} uint1408m_T;\n\ntypedef struct {\n  uint1408m_T re;\n  uint1408m_T im;\n} cuint1408m_T;\n\ntypedef struct {\n  uint64_T chunks[23];\n} int1472m_T;\n\ntypedef struct {\n  int1472m_T re;\n  int1472m_T im;\n} cint1472m_T;\n\ntypedef struct {\n  uint64_T chunks[23];\n} uint1472m_T;\n\ntypedef struct {\n  uint1472m_T re;\n  uint1472m_T im;\n} cuint1472m_T;\n\ntypedef struct {\n  uint64_T chunks[24];\n} int1536m_T;\n\ntypedef struct {\n  int1536m_T re;\n  int1536m_T im;\n} cint1536m_T;\n\ntypedef struct {\n  uint64_T chunks[24];\n} uint1536m_T;\n\ntypedef struct {\n  uint1536m_T re;\n  uint1536m_T im;\n} cuint1536m_T;\n\ntypedef struct {\n  uint64_T chunks[25];\n} int1600m_T;\n\ntypedef struct {\n  int1600m_T re;\n  int1600m_T im;\n} cint1600m_T;\n\ntypedef struct {\n  uint64_T chunks[25];\n} uint1600m_T;\n\ntypedef struct {\n  uint1600m_T re;\n  uint1600m_T im;\n} cuint1600m_T;\n\ntypedef struct {\n  uint64_T chunks[26];\n} int1664m_T;\n\ntypedef struct {\n  int1664m_T re;\n  int1664m_T im;\n} cint1664m_T;\n\ntypedef struct {\n  uint64_T chunks[26];\n} uint1664m_T;\n\ntypedef struct {\n  uint1664m_T re;\n  uint1664m_T im;\n} cuint1664m_T;\n\ntypedef struct {\n  uint64_T chunks[27];\n} int1728m_T;\n\ntypedef struct {\n  int1728m_T re;\n  int1728m_T im;\n} cint1728m_T;\n\ntypedef struct {\n  uint64_T chunks[27];\n} uint1728m_T;\n\ntypedef struct {\n  uint1728m_T re;\n  uint1728m_T im;\n} cuint1728m_T;\n\ntypedef struct {\n  uint64_T chunks[28];\n} int1792m_T;\n\ntypedef struct {\n  int1792m_T re;\n  int1792m_T im;\n} cint1792m_T;\n\ntypedef struct {\n  uint64_T chunks[28];\n} uint1792m_T;\n\ntypedef struct {\n  uint1792m_T re;\n  uint1792m_T im;\n} cuint1792m_T;\n\ntypedef struct {\n  uint64_T chunks[29];\n} int1856m_T;\n\ntypedef struct {\n  int1856m_T re;\n  int1856m_T im;\n} cint1856m_T;\n\ntypedef struct {\n  uint64_T chunks[29];\n} uint1856m_T;\n\ntypedef struct {\n  uint1856m_T re;\n  uint1856m_T im;\n} cuint1856m_T;\n\ntypedef struct {\n  uint64_T chunks[30];\n} int1920m_T;\n\ntypedef struct {\n  int1920m_T re;\n  int1920m_T im;\n} cint1920m_T;\n\ntypedef struct {\n  uint64_T chunks[30];\n} uint1920m_T;\n\ntypedef struct {\n  uint1920m_T re;\n  uint1920m_T im;\n} cuint1920m_T;\n\ntypedef struct {\n  uint64_T chunks[31];\n} int1984m_T;\n\ntypedef struct {\n  int1984m_T re;\n  int1984m_T im;\n} cint1984m_T;\n\ntypedef struct {\n  uint64_T chunks[31];\n} uint1984m_T;\n\ntypedef struct {\n  uint1984m_T re;\n  uint1984m_T im;\n} cuint1984m_T;\n\ntypedef struct {\n  uint64_T chunks[32];\n} int2048m_T;\n\ntypedef struct {\n  int2048m_T re;\n  int2048m_T im;\n} cint2048m_T;\n\ntypedef struct {\n  uint64_T chunks[32];\n} uint2048m_T;\n\ntypedef struct {\n  uint2048m_T re;\n  uint2048m_T im;\n} cuint2048m_T;\n\n#endif                                 /* MULTIWORD_TYPES_H */\n"},{"name":"rtGetInf.cpp","type":"source","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/JOLT_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetInf.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"JOLT\".\n *\n * Model version              : 1.375\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Fri Dec  1 17:02:18 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"rtwtypes.h\"\n\nextern \"C\"\n{\n\n#include \"rtGetInf.h\"\n\n}\n\n#include <stddef.h>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#define NumBitsPerChar                 8U\n\nextern \"C\"\n{\n  /*\n   * Initialize rtInf needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real_T rtGetInf(void)\n  {\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n    real_T inf = 0.0;\n    if (bitsPerReal == 32U) {\n      inf = rtGetInfF();\n    } else {\n      uint16_T one = 1U;\n      enum {\n        LittleEndian,\n        BigEndian\n      } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\n      switch (machByteOrder) {\n       case LittleEndian:\n        {\n          union {\n            LittleEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0x7FF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          inf = tmpVal.fltVal;\n          break;\n        }\n\n       case BigEndian:\n        {\n          union {\n            BigEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0x7FF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          inf = tmpVal.fltVal;\n          break;\n        }\n      }\n    }\n\n    return inf;\n  }\n\n  /*\n   * Initialize rtInfF needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real32_T rtGetInfF(void)\n  {\n    IEEESingle infF;\n    infF.wordL.wordLuint = 0x7F800000U;\n    return infF.wordL.wordLreal;\n  }\n\n  /*\n   * Initialize rtMinusInf needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real_T rtGetMinusInf(void)\n  {\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n    real_T minf = 0.0;\n    if (bitsPerReal == 32U) {\n      minf = rtGetMinusInfF();\n    } else {\n      uint16_T one = 1U;\n      enum {\n        LittleEndian,\n        BigEndian\n      } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\n      switch (machByteOrder) {\n       case LittleEndian:\n        {\n          union {\n            LittleEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0xFFF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          minf = tmpVal.fltVal;\n          break;\n        }\n\n       case BigEndian:\n        {\n          union {\n            BigEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0xFFF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          minf = tmpVal.fltVal;\n          break;\n        }\n      }\n    }\n\n    return minf;\n  }\n\n  /*\n   * Initialize rtMinusInfF needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real32_T rtGetMinusInfF(void)\n  {\n    IEEESingle minfF;\n    minfF.wordL.wordLuint = 0xFF800000U;\n    return minfF.wordL.wordLreal;\n  }\n}\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/JOLT_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetInf.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"JOLT\".\n *\n * Model version              : 1.375\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Fri Dec  1 17:02:18 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rtGetInf_h_\n#define RTW_HEADER_rtGetInf_h_\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#include \"rtwtypes.h\"\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern real_T rtGetInf(void);\n  extern real32_T rtGetInfF(void);\n  extern real_T rtGetMinusInf(void);\n  extern real32_T rtGetMinusInfF(void);\n\n#ifdef __cplusplus\n\n}                                      /* extern \"C\" */\n\n#endif\n#endif                                 /* RTW_HEADER_rtGetInf_h_ */\n"},{"name":"rtGetNaN.cpp","type":"source","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/JOLT_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetNaN.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"JOLT\".\n *\n * Model version              : 1.375\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Fri Dec  1 17:02:18 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"rtwtypes.h\"\n\nextern \"C\"\n{\n\n#include \"rtGetNaN.h\"\n\n}\n\n#include <stddef.h>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#define NumBitsPerChar                 8U\n\nextern \"C\"\n{\n  /*\n   * Initialize rtNaN needed by the generated code.\n   * NaN is initialized as non-signaling. Assumes IEEE.\n   */\n  real_T rtGetNaN(void)\n  {\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n    real_T nan = 0.0;\n    if (bitsPerReal == 32U) {\n      nan = rtGetNaNF();\n    } else {\n      uint16_T one = 1U;\n      enum {\n        LittleEndian,\n        BigEndian\n      } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\n      switch (machByteOrder) {\n       case LittleEndian:\n        {\n          union {\n            LittleEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0xFFF80000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          nan = tmpVal.fltVal;\n          break;\n        }\n\n       case BigEndian:\n        {\n          union {\n            BigEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0x7FFFFFFFU;\n          tmpVal.bitVal.words.wordL = 0xFFFFFFFFU;\n          nan = tmpVal.fltVal;\n          break;\n        }\n      }\n    }\n\n    return nan;\n  }\n\n  /*\n   * Initialize rtNaNF needed by the generated code.\n   * NaN is initialized as non-signaling. Assumes IEEE.\n   */\n  real32_T rtGetNaNF(void)\n  {\n    IEEESingle nanF = { { 0.0F } };\n\n    uint16_T one = 1U;\n    enum {\n      LittleEndian,\n      BigEndian\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\n    switch (machByteOrder) {\n     case LittleEndian:\n      {\n        nanF.wordL.wordLuint = 0xFFC00000U;\n        break;\n      }\n\n     case BigEndian:\n      {\n        nanF.wordL.wordLuint = 0x7FFFFFFFU;\n        break;\n      }\n    }\n\n    return nanF.wordL.wordLreal;\n  }\n}\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/JOLT_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetNaN.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"JOLT\".\n *\n * Model version              : 1.375\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Fri Dec  1 17:02:18 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rtGetNaN_h_\n#define RTW_HEADER_rtGetNaN_h_\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#include \"rtwtypes.h\"\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern real_T rtGetNaN(void);\n  extern real32_T rtGetNaNF(void);\n\n#ifdef __cplusplus\n\n}                                      /* extern \"C\" */\n\n#endif\n#endif                                 /* RTW_HEADER_rtGetNaN_h_ */\n"},{"name":"rt_nonfinite.cpp","type":"source","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/JOLT_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rt_nonfinite.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"JOLT\".\n *\n * Model version              : 1.375\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Fri Dec  1 17:02:18 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\nextern \"C\"\n{\n\n#include \"rtGetNaN.h\"\n\n}\n\nextern \"C\"\n{\n\n#include \"rtGetInf.h\"\n\n}\n\n#include <stddef.h>\n#include \"rtwtypes.h\"\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#define NumBitsPerChar                 8U\n\nextern \"C\"\n{\n  real_T rtInf;\n  real_T rtMinusInf;\n  real_T rtNaN;\n  real32_T rtInfF;\n  real32_T rtMinusInfF;\n  real32_T rtNaNF;\n}\n\nextern \"C\"\n{\n  /*\n   * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\n   * generated code. NaN is initialized as non-signaling. Assumes IEEE.\n   */\n  void rt_InitInfAndNaN(size_t realSize)\n  {\n    (void) (realSize);\n    rtNaN = rtGetNaN();\n    rtNaNF = rtGetNaNF();\n    rtInf = rtGetInf();\n    rtInfF = rtGetInfF();\n    rtMinusInf = rtGetMinusInf();\n    rtMinusInfF = rtGetMinusInfF();\n  }\n\n  /* Test if value is infinite */\n  boolean_T rtIsInf(real_T value)\n  {\n    return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\n  }\n\n  /* Test if single-precision value is infinite */\n  boolean_T rtIsInfF(real32_T value)\n  {\n    return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\n  }\n\n  /* Test if value is not a number */\n  boolean_T rtIsNaN(real_T value)\n  {\n    boolean_T result = (boolean_T) 0;\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n    if (bitsPerReal == 32U) {\n      result = rtIsNaNF((real32_T)value);\n    } else {\n      union {\n        LittleEndianIEEEDouble bitVal;\n        real_T fltVal;\n      } tmpVal;\n\n      tmpVal.fltVal = value;\n      result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) ==\n                           0x7FF00000 &&\n                           ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\n                            (tmpVal.bitVal.words.wordL != 0) ));\n    }\n\n    return result;\n  }\n\n  /* Test if single-precision value is not a number */\n  boolean_T rtIsNaNF(real32_T value)\n  {\n    IEEESingle tmp;\n    tmp.wordL.wordLreal = value;\n    return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\n                       (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\n  }\n}\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/JOLT_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rt_nonfinite.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"JOLT\".\n *\n * Model version              : 1.375\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Fri Dec  1 17:02:18 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rt_nonfinite_h_\n#define RTW_HEADER_rt_nonfinite_h_\n#include <stddef.h>\n#include \"rtwtypes.h\"\n#define NOT_USING_NONFINITE_LITERALS   1\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern real_T rtInf;\n  extern real_T rtMinusInf;\n  extern real_T rtNaN;\n  extern real32_T rtInfF;\n  extern real32_T rtMinusInfF;\n  extern real32_T rtNaNF;\n  extern void rt_InitInfAndNaN(size_t realSize);\n  extern boolean_T rtIsInf(real_T value);\n  extern boolean_T rtIsInfF(real32_T value);\n  extern boolean_T rtIsNaN(real_T value);\n  extern boolean_T rtIsNaNF(real32_T value);\n  struct BigEndianIEEEDouble {\n    struct {\n      uint32_T wordH;\n      uint32_T wordL;\n    } words;\n  };\n\n  struct LittleEndianIEEEDouble {\n    struct {\n      uint32_T wordL;\n      uint32_T wordH;\n    } words;\n  };\n\n  struct IEEESingle {\n    union {\n      real32_T wordLreal;\n      uint32_T wordLuint;\n    } wordL;\n  };\n\n#ifdef __cplusplus\n\n}                                      /* extern \"C\" */\n\n#endif\n#endif                                 /* RTW_HEADER_rt_nonfinite_h_ */\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/JOLT_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtwtypes.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"JOLT\".\n *\n * Model version              : 1.375\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Fri Dec  1 17:02:18 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTWTYPES_H\n#define RTWTYPES_H\n#include \"tmwtypes.h\"\n#ifndef POINTER_T\n#define POINTER_T\n\ntypedef void * pointer_T;\n\n#endif\n\n/* Logical type definitions */\n#if (!defined(__cplusplus))\n#ifndef false\n#define false                          (0U)\n#endif\n\n#ifndef true\n#define true                           (1U)\n#endif\n#endif\n\n#ifndef INT64_T\n#define INT64_T\n\ntypedef long int64_T;\n\n#define MAX_int64_T                    ((int64_T)(9223372036854775807L))\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807L-1L))\n#endif\n\n#ifndef UINT64_T\n#define UINT64_T\n\ntypedef unsigned long uint64_T;\n\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFUL))\n#endif\n\n/*===========================================================================*\n * Additional complex number type definitions                                           *\n *===========================================================================*/\n#ifndef CINT64_T\n#define CINT64_T\n\ntypedef struct {\n  int64_T re;\n  int64_T im;\n} cint64_T;\n\n#endif\n\n#ifndef CUINT64_T\n#define CUINT64_T\n\ntypedef struct {\n  uint64_T re;\n  uint64_T im;\n} cuint64_T;\n\n#endif\n#endif                                 /* RTWTYPES_H */\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"/home/electro/Code_Repo/n-CORTEx/JOLT_slrealtime_rtw","tag":"","groupDisplay":"Interface files","code":"/*\n *  rtmodel.h:\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"JOLT\".\n *\n * Model version              : 1.375\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Fri Dec  1 17:02:18 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rtmodel_h_\n#define RTW_HEADER_rtmodel_h_\n#include \"JOLT.h\"\n#define GRTINTERFACE                   0\n#endif                                 /* RTW_HEADER_rtmodel_h_ */\n"},{"name":"sg_IO191_ad_s.c","type":"source","group":"interface","path":"/home/electro/Code_Repo/n-CORTEx/JOLT_slrealtime_rtw/../../../.speedgoat/speedgoatlib/R2023a/9.6.1.1_4/sg_blocks/analog","tag":"","groupDisplay":"Interface files","code":"// Copyright 2006-2023 Speedgoat GmbH\r\n\r\n#define S_FUNCTION_LEVEL    (0xd87+330-0xecf)\r\n#undef S_FUNCTION_NAME\r\n#define S_FUNCTION_NAME     sg_IO191_ad_s\r\n#include \"sg_IO191.h\"\r\n#ifndef MATLAB_MEX_FILE\r\n#include \"sg_printf.h\"\r\n#include \"sg_common.h\"\r\nvoid readPciBar(sg_PCIDevice*z7c46aa329e,int16_t bus,int16_t slot,int16_t z1e0fd5210f);\r\n#else\r\n#include \"mex.h\"\r\n#endif\r\n#include \"sg_callback.h\"\r\n#define ze13f49a01f           ssGetSFcnParam(S, (0x1421+4652-0x264d))\r\n#define z3832b85a32           ssGetSFcnParam(S, (0x82d+2280-0x1114))\r\n#define z702a26a5e9                ssGetSFcnParam(S, (0x141f+3266-0x20df))\r\n#define z3644586f49         ssGetSFcnParam(S, (0x6bc+3711-0x1538))\r\n#define z8d5c288b32         ssGetSFcnParam(S, (0x1a40+450-0x1bfe))\r\n#define zb66856d060         ssGetSFcnParam(S, (0x20ad+932-0x244c))\r\n#define z9876548c58         ssGetSFcnParam(S, (0x303+2144-0xb5d))\r\n#define zb093e77094      ssGetSFcnParam(S, (0x1650+3950-0x25b7))\r\n#define z2948f18e24        ssGetSFcnParam(S, (0x1310+1501-0x18e5))\r\n#define zdf24515981                           ((0x92c+2706-0x13b5))\r\n#define z7e2eeaa57c          ((0x1dfc+2294-0x26f2))\r\n#define zc0ced48ecf              ((0x770+2705-0x1200))\r\n#define z2e6483d505              ((0x110a+5601-0x26e9))\r\n#define zc5ce4cb81a              ((0x40d+302-0x53b))\r\n#define z0194338df7         ((0x21a0+274-0x22b2))\r\n#define z2b17e2ee3b              ((0x44b+4814-0x1718))\r\nstatic double zfc19727a48(uint32_t zf4d6a48e37);static char msg[z71934bf57c];static void mdlInitializeSizes(SimStruct*S){uint16_t i;ssSetNumSFcnParams(S,zdf24515981);if(ssGetNumSFcnParams(S)!=ssGetSFcnParamsCount(S)){sprintf(msg,\"\\x57\\x72\\x6f\\x6e\\x67\\x20\\x6e\\x75\\x6d\\x62\\x65\\x72\\x20\\x6f\\x66\\x20\\x69\\x6e\\x70\\x75\\x74\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x70\\x61\\x73\\x73\\x65\\x64\\x2e\" \"\\n\" \"\\x25\\x64\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x61\\x72\\x65\\x20\\x65\\x78\\x70\\x65\\x63\\x74\\x65\\x64\" \"\\n\",zdf24515981);ssSetErrorStatus(S,msg);return;}ssSetNumContStates(S,(0x49a+6035-0x1c2d));ssSetNumDiscStates(S,(0xbbd+3468-0x1949));if(!ssSetNumInputPorts(S,(0xebf+491-0x10aa)))return;if(!ssSetNumOutputPorts(S,(int)mxGetN(z3644586f49)))return;for(i=(0x26b+6461-0x1ba8);i<(int)mxGetN(z3644586f49);i++){ssSetOutputPortWidth(S,i,(0xdf5+2237-0x16b1));}ssSetNumSampleTimes(S,(0x5af+2164-0xe22));ssSetNumRWork(S,zc5ce4cb81a);ssSetNumIWork(S,z2e6483d505);ssSetNumPWork(S,z2b17e2ee3b);ssSetNumModes(S,(0x130+4427-0x127b));ssSetNumNonsampledZCs(S,(0x486+1293-0x993));for(i=(0x135a+368-0x14ca);i<zdf24515981;i++){ssSetSFcnParamTunable(S,i,(0x5eb+5912-0x1d03));}ssSetOptions(S,SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME|SS_OPTION_EXCEPTION_FREE_CODE|SS_OPTION_RUNTIME_EXCEPTION_FREE_CODE);}static void mdlInitializeSampleTimes(SimStruct*S){if(mxGetPr(z3832b85a32)[(0xbc9+611-0xe2c)]==-1.0){ssSetSampleTime(S,(0xf9d+3333-0x1ca2),INHERITED_SAMPLE_TIME);ssSetOffsetTime(S,(0xa0f+3396-0x1753),FIXED_IN_MINOR_STEP_OFFSET);}else{ssSetSampleTime(S,(0x2e3+889-0x65c),mxGetPr(z3832b85a32)[(0xb5d+6245-0x23c2)]);ssSetOffsetTime(S,(0xa80+96-0xae0),0.0);}ssSetModelReferenceSampleTimeDefaultInheritance(S);}\r\n#ifndef MATLAB_MEX_FILE\r\nstatic void sg_ModelLoad(SimStruct*S){}static void sg_ModelStart(SimStruct*S){sg_PCIDevice zeccbadd9b3;uint32_t bus,slot,za0d38ae598,ze5e89e1937,i;uint16_t z4e3026977c,zf91d71c6d9;volatile uint32_t*z27fd94ac66;if(mxGetN(z702a26a5e9)==(0x11b2+4500-0x2345)){bus=(0x8f8+5136-0x1d08);slot=(uint32_t)mxGetPr(z702a26a5e9)[(0xbc2+6909-0x26bf)];}else{bus=(uint32_t)mxGetPr(z702a26a5e9)[(0x730+109-0x79d)];slot=(uint32_t)mxGetPr(z702a26a5e9)[(0x17e1+1839-0x1f0f)];}za0d38ae598=((uint32_t)mxGetPr(ze13f49a01f)[(0x1cb2+361-0x1e1b)]);if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,za1afbacc4a,z78f5b4c5a6,z2bc00458b9,za0d38ae598,bus,slot)!=(0x3a8+8380-0x2464)){if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,zb765876dc5,z44a525e63d,za64fcbac7d,za0d38ae598,bus,slot)!=(0x83f+3255-0x14f6)){ssSetErrorStatus(S,pSgErrorStr);return;}}\r\n#ifdef _MSC_BUILD\r\nreadPciBar(&zeccbadd9b3,zeccbadd9b3.bus,zeccbadd9b3.slot,(0x6c4+3428-0x1428));\r\n#endif\r\nz27fd94ac66=(volatile uint32_t*)sg_mapMemory(&zeccbadd9b3,(0x168a+226-0x176a));zf91d71c6d9=(uint16_t)mxGetN(z3644586f49);ssSetPWorkValue(S,z0194338df7,(uint32_t*)z27fd94ac66);ssSetIWorkValue(S,z7e2eeaa57c,zf91d71c6d9);if(z27fd94ac66[REVISION]<zb5135f698e){sprintf(msg,\"\\x25\\x73\\x20\\x4d\\x6f\\x64\\x75\\x6c\\x65\\x20\\x49\\x44\\x20\\x25\\x64\\x20\\x46\\x69\\x72\\x6d\\x77\\x61\\x72\\x65\\x20\\x30\\x78\\x25\\x58\\x20\\x69\\x73\\x20\\x6f\\x75\\x74\\x64\\x61\\x74\\x65\\x64\\x2c\\x20\\x70\\x6c\\x65\\x61\\x73\\x65\\x20\\x63\\x6f\\x6e\\x74\\x61\\x63\\x74\\x20\\x53\\x70\\x65\\x65\\x64\\x67\\x6f\\x61\\x74\\x20\\x73\\x75\\x70\\x70\\x6f\\x72\\x74\\x2e\" \"\\n\",DEVNAME,za0d38ae598,z27fd94ac66[REVISION]);ssSetErrorStatus(S,msg);return;}z27fd94ac66[BRP]=((0x1ffa+403-0x218c)<<zbef81c3fd0);z27fd94ac66[z469883b65e]=(0x1175+2396-0x1ad1);z27fd94ac66[zfcd2c661f6]=(uint32_t)(z27fd94ac66[z24765e17f8]/z1a910f8330);SG_PRINTF_DEBUG(\"\\x41\\x44\\x43\\x5f\\x53\\x43\\x41\\x4e\\x5f\\x52\\x41\\x54\\x45\\x20\\x25\\x58\" \"\\n\",z27fd94ac66[zfcd2c661f6]);ze5e89e1937=(0x10f5+710-0x13bb);for(i=(0x7b8+7005-0x2315);i<zf91d71c6d9;i++){z4e3026977c=(uint16_t)mxGetPr(z3644586f49)[i]-(0x1eb+1714-0x89c);switch((uint16_t)mxGetPr(z9876548c58)[i]){case(0x7c7+6388-0x20ba):ze5e89e1937|=(z4eb3456176<<(z4e3026977c*(0x696+4149-0x16c7)));break;case(0x13bc+3824-0x22aa):ze5e89e1937|=(z7239c371e4<<(z4e3026977c*(0x95c+3508-0x170c)));break;case(0x7e9+429-0x993):ze5e89e1937|=(z65195ba21a<<(z4e3026977c*(0x10d6+3390-0x1e10)));break;case(0xb1b+1951-0x12b6):ze5e89e1937|=(z769e3cf99a<<(z4e3026977c*(0x10a3+377-0x1218)));break;case(0xd84+3455-0x1afe):ze5e89e1937|=(zad88ee04d7<<(z4e3026977c*(0x53d+7502-0x2287)));break;case(0x17d2+2662-0x2232):ze5e89e1937|=(z04726aa6f4<<(z4e3026977c*(0xb6f+4410-0x1ca5)));break;case(0x602+7248-0x224b):ze5e89e1937|=(zca8a2e109e<<(z4e3026977c*(0x9d4+6839-0x2487)));break;default:sprintf(msg,\"\\x41\\x6e\\x61\\x6c\\x6f\\x67\\x20\\x49\\x6e\\x70\\x75\\x74\\x73\\x20\\x75\\x6e\\x6b\\x6e\\x6f\\x77\\x6e\\x20\\x76\\x6f\\x6c\\x74\\x61\\x67\\x65\");ssSetErrorStatus(S,msg);break;}}z27fd94ac66[z3f2dd8a551]=ze5e89e1937;SG_PRINTF_DEBUG(\"\\x47\\x61\\x69\\x6e\\x20\\x72\\x65\\x67\\x69\\x73\\x74\\x65\\x72\\x3a\\x20\\x25\\x58\\x20\" \"\\n\",ze5e89e1937);ssSetIWorkValue(S,zc0ced48ecf,(0xfab+4387-0x20cd));}static void sg_ModelStep(SimStruct*S){uint16_t zf91d71c6d9=ssGetIWorkValue(S,z7e2eeaa57c);uint16_t z4d3816b14e=(uint16_t)mxGetPr(z3644586f49)[zf91d71c6d9-(0xd9+7701-0x1eed)]-(0x2211+510-0x240e);volatile uint32_t*z27fd94ac66=ssGetPWorkValue(S,z0194338df7);uint32_t ze77fa94a00=(uint32_t)mxGetPr(z8d5c288b32)[(0x8bb+460-0xa87)]-(0x1035+2325-0x1949);uint32_t i,z812c65ff2f,z297b36fb23,z41c8844f54;double*y;if((uint16_t)ssGetIWorkValue(S,zc0ced48ecf)==(0x2208+15-0x2216)){z27fd94ac66[z75b6a00559]=393322|((z4d3816b14e&(0x1666+1643-0x1cca))<<z690b1cd3dc)|(ze77fa94a00<<z0a8926012b)|((0xd23+2873-0x185b)<<z55588371ab);for(i=(0x19ec+199-0x1ab3);(z27fd94ac66[z75b6a00559]>>(0x29a+8557-0x23f7))>(0x46c+1030-0x86e);i++){if(i>1193000.0*1.0){sprintf(msg,\"\\x25\\x73\\x20\\x66\\x61\\x69\\x6c\\x65\\x64\\x20\\x74\\x6f\\x20\\x63\\x6f\\x6e\\x66\\x69\\x67\\x20\\x41\\x6e\\x61\\x6c\\x6f\\x67\\x20\\x69\\x6e\\x70\\x75\\x74\\x20\\x72\\x65\\x67\\x20\\x30\\x78\\x25\\x78\",DEVNAME,z27fd94ac66[z75b6a00559]>>(0x49a+8581-0x260f));ssSetErrorStatus(S,msg);return;}}ssSetIWorkValue(S,zc0ced48ecf,(0xf36+511-0x1135));}z41c8844f54=z27fd94ac66[zee1550bec3];for(i=(0x1c4+4708-0x1428);z41c8844f54<zf91d71c6d9;i++){if(i>1193000.0*2.0){sprintf(msg,\"\\x25\\x73\\x20\\x66\\x61\\x69\\x6c\\x65\\x64\\x20\\x74\\x6f\\x20\\x73\\x74\\x61\\x72\\x74\\x20\\x41\\x6e\\x61\\x6c\\x6f\\x67\\x20\\x69\\x6e\\x70\\x75\\x74\",DEVNAME);ssSetErrorStatus(S,msg);return;}z41c8844f54=z27fd94ac66[zee1550bec3];}for(i=(0x1db1+843-0x20fc);i<=z41c8844f54;i++){z297b36fb23=z27fd94ac66[zceb273b472];if(!(z297b36fb23&((0xbdf+1279-0x10dd)<<(0x256+8210-0x2249)))){for(z812c65ff2f=(0x18ba+2896-0x240a);z812c65ff2f<zf91d71c6d9;z812c65ff2f++){if(((uint16_t)mxGetPr(z3644586f49)[z812c65ff2f]-(0x854+693-0xb08))==(uint16_t)((z297b36fb23>>z09b806e22a)&(0x658+4661-0x1886))){y=ssGetOutputPortSignal(S,z812c65ff2f);y[(0x15ac+4118-0x25c2)]=zfc19727a48(z297b36fb23);break;}}}}z27fd94ac66[z75b6a00559]=393322|((z4d3816b14e&(0x3ea+1890-0xb45))<<z690b1cd3dc)|(ze77fa94a00<<z0a8926012b)|((0x303+95-0x361)<<\r\nz55588371ab);}static void sg_ModelStop(SimStruct*S){volatile uint32_t*z27fd94ac66=ssGetPWorkValue(S,z0194338df7);z27fd94ac66[BRP]=((0xb2b+1334-0x1060)<<zbef81c3fd0);}\r\n#endif  \r\nstatic double zfc19727a48(uint32_t zf4d6a48e37){double ze485f859ed;uint16_t z1044b54040=(zf4d6a48e37>>z2d5a35d68d)&(0x460+7091-0x200c);const double z3dec4d2bb3[(0xbf5+6672-0x25fd)]={24.576/32768,10.24/32768,5.12/32768,2.56/32768,1.28/32768,0.64/32768,65535,20.48/32768};if(((zf4d6a48e37>>z2858a50a43)&(0x1c5a+2555-0x2654))>(0x161d+1278-0x1b1b)){ze485f859ed=((((double)(zf4d6a48e37&65535))-z7935114df5)*z3dec4d2bb3[z1044b54040]);}else{ze485f859ed=(((double)(zf4d6a48e37&65535))*z3dec4d2bb3[z1044b54040]);}return ze485f859ed;}\r\n#include \"sg_sfcn_glue.h\"   \r\n\r\n"},{"name":"sg_IO191_di_s.c","type":"source","group":"interface","path":"/home/electro/Code_Repo/n-CORTEx/JOLT_slrealtime_rtw/../../../.speedgoat/speedgoatlib/R2023a/9.6.1.1_4/sg_blocks/analog","tag":"","groupDisplay":"Interface files","code":"// Copyright 2006-2023 Speedgoat GmbH\r\n\r\n#define S_FUNCTION_LEVEL    (0x490+2482-0xe40)\r\n#undef S_FUNCTION_NAME\r\n#define S_FUNCTION_NAME     sg_IO191_di_s\r\n#include \"sg_IO191.h\"\r\n#ifndef MATLAB_MEX_FILE\r\n#include \"sg_printf.h\"\r\n#include \"sg_common.h\"\r\nvoid readPciBar(sg_PCIDevice*z7c46aa329e,int16_t bus,int16_t slot,int16_t z1e0fd5210f);\r\n#else\r\n#include \"mex.h\"\r\n#endif\r\n#include \"sg_callback.h\"\r\n#define ze13f49a01f           ssGetSFcnParam(S, (0x1759+2617-0x2192))\r\n#define z3832b85a32           ssGetSFcnParam(S, (0x5f8+3193-0x1270))\r\n#define z702a26a5e9                ssGetSFcnParam(S, (0x2c5+4208-0x1333))\r\n#define zb18e38a301           ssGetSFcnParam(S, (0xa61+4466-0x1bd0))\r\n#define zdf24515981                           ((0x16f8+3286-0x23ca))\r\n#define z2e6483d505              ((0x26a+8085-0x21ff))\r\n#define zc5ce4cb81a              ((0x11f5+4924-0x2531))\r\n#define z0194338df7         ((0x3c2+703-0x681))\r\n#define z2b17e2ee3b              ((0x147c+2948-0x1fff))\r\nstatic char msg[z71934bf57c];static void mdlInitializeSizes(SimStruct*S){uint16_t i;ssSetNumSFcnParams(S,zdf24515981);if(ssGetNumSFcnParams(S)!=ssGetSFcnParamsCount(S)){sprintf(msg,\"\\x57\\x72\\x6f\\x6e\\x67\\x20\\x6e\\x75\\x6d\\x62\\x65\\x72\\x20\\x6f\\x66\\x20\\x69\\x6e\\x70\\x75\\x74\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x70\\x61\\x73\\x73\\x65\\x64\\x2e\" \"\\n\" \"\\x25\\x64\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x61\\x72\\x65\\x20\\x65\\x78\\x70\\x65\\x63\\x74\\x65\\x64\" \"\\n\",zdf24515981);ssSetErrorStatus(S,msg);return;}ssSetNumContStates(S,(0xc7b+5592-0x2253));ssSetNumDiscStates(S,(0x1185+3229-0x1e22));if(!ssSetNumInputPorts(S,(0xb62+481-0xd43)))return;if(!ssSetNumOutputPorts(S,(int)mxGetN(zb18e38a301)))return;for(i=(0x1d13+145-0x1da4);i<(int)mxGetN(zb18e38a301);i++){ssSetOutputPortWidth(S,i,(0x486+5466-0x19df));ssSetOutputPortDataType(S,(0x56c+6929-0x207d),SS_DOUBLE);}ssSetNumSampleTimes(S,(0x1a08+2901-0x255c));ssSetNumRWork(S,zc5ce4cb81a);ssSetNumIWork(S,z2e6483d505);ssSetNumPWork(S,z2b17e2ee3b);ssSetNumModes(S,(0x1aad+2738-0x255f));ssSetNumNonsampledZCs(S,(0x1482+3272-0x214a));for(i=(0xd05+5164-0x2131);i<zdf24515981;i++){ssSetSFcnParamTunable(S,i,(0x12db+3246-0x1f89));}ssSetOptions(S,SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME|SS_OPTION_EXCEPTION_FREE_CODE|SS_OPTION_RUNTIME_EXCEPTION_FREE_CODE);}static void mdlInitializeSampleTimes(SimStruct*S){if(mxGetPr(z3832b85a32)[(0x2cd+619-0x538)]==-1.0){ssSetSampleTime(S,(0x136d+3208-0x1ff5),INHERITED_SAMPLE_TIME);ssSetOffsetTime(S,(0x19a0+2894-0x24ee),FIXED_IN_MINOR_STEP_OFFSET);}else{ssSetSampleTime(S,(0x574+6180-0x1d98),mxGetPr(z3832b85a32)[(0x662+3656-0x14aa)]);ssSetOffsetTime(S,(0xbd9+2070-0x13ef),0.0);}ssSetModelReferenceSampleTimeDefaultInheritance(S);}\r\n#ifndef MATLAB_MEX_FILE\r\nstatic void sg_ModelLoad(SimStruct*S){}static void sg_ModelStart(SimStruct*S){sg_PCIDevice zeccbadd9b3;uint32_t bus,slot,za0d38ae598;volatile uint32_t*z27fd94ac66;if(mxGetN(z702a26a5e9)==(0xb62+5554-0x2113)){bus=(0x10ed+5301-0x25a2);slot=(uint32_t)mxGetPr(z702a26a5e9)[(0x874+6135-0x206b)];}else{bus=(uint32_t)mxGetPr(z702a26a5e9)[(0xadd+5988-0x2241)];slot=(uint32_t)mxGetPr(z702a26a5e9)[(0x8cd+1253-0xdb1)];}za0d38ae598=((uint32_t)mxGetPr(ze13f49a01f)[(0x1749+1291-0x1c54)]);if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,za1afbacc4a,z78f5b4c5a6,z2bc00458b9,za0d38ae598,bus,slot)!=(0xf55+4351-0x2054)){if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,zb765876dc5,z44a525e63d,za64fcbac7d,za0d38ae598,bus,slot)!=(0x594+130-0x616)){ssSetErrorStatus(S,pSgErrorStr);return;}}\r\n#ifdef _MSC_BUILD\r\nreadPciBar(&zeccbadd9b3,zeccbadd9b3.bus,zeccbadd9b3.slot,(0x1252+4672-0x2492));\r\n#endif\r\nz27fd94ac66=(volatile uint32_t*)sg_mapMemory(&zeccbadd9b3,(0x189+4706-0x13e9));ssSetPWorkValue(S,z0194338df7,(uint32_t*)z27fd94ac66);}static void sg_ModelStep(SimStruct*S){volatile uint32_t*za42cf7dd4a=ssGetPWorkValue(S,z0194338df7);uint32_t i,input,z4e3026977c;double*y;input=za42cf7dd4a[z52eac5d033];for(i=(0x180b+74-0x1855);i<(uint32_t)mxGetN(zb18e38a301);i++){z4e3026977c=(uint32_t)mxGetPr(zb18e38a301)[i]-(0x2c4+612-0x527);y=ssGetOutputPortSignal(S,i);if(input&((0x2149+672-0x23e8)<<z4e3026977c)){y[(0x1c4c+1042-0x205e)]=(0x60f+1538-0xc10);}else{y[(0xcf3+2372-0x1637)]=(0xc11+4873-0x1f1a);}}}static void sg_ModelStop(SimStruct*S){}\r\n#endif  \r\n#include \"sg_sfcn_glue.h\"   \r\n\r\n"},{"name":"sg_IO191_do_s.c","type":"source","group":"interface","path":"/home/electro/Code_Repo/n-CORTEx/JOLT_slrealtime_rtw/../../../.speedgoat/speedgoatlib/R2023a/9.6.1.1_4/sg_blocks/analog","tag":"","groupDisplay":"Interface files","code":"// Copyright 2006-2023 Speedgoat GmbH\r\n\r\n#define S_FUNCTION_LEVEL    (0x5bf+2361-0xef6)\r\n#undef S_FUNCTION_NAME\r\n#define S_FUNCTION_NAME     sg_IO191_do_s\r\n#include \"sg_IO191.h\"\r\n#ifndef MATLAB_MEX_FILE\r\n#include \"sg_printf.h\"\r\n#include \"sg_common.h\"\r\nvoid readPciBar(sg_PCIDevice*z7c46aa329e,int16_t bus,int16_t slot,int16_t z1e0fd5210f);\r\n#else\r\n#include \"mex.h\"\r\n#endif\r\n#include \"sg_callback.h\"\r\n#define ze13f49a01f           ssGetSFcnParam(S, (0x13e0+4526-0x258e))\r\n#define z3832b85a32           ssGetSFcnParam(S, (0x182+5115-0x157c))\r\n#define z702a26a5e9                ssGetSFcnParam(S, (0xc01+464-0xdcf))\r\n#define z5bc3ce0d50           ssGetSFcnParam(S, (0x776+1601-0xdb4))\r\n#define z2d8f240c11           ssGetSFcnParam(S, (0x1772+625-0x19df))\r\n#define z1f9bebb47b             ssGetSFcnParam(S, (0x1683+2315-0x1f89))\r\n#define zdf24515981                           ((0xf52+4685-0x2199))\r\n#define z2e6483d505              ((0x9a8+3518-0x1766))\r\n#define zc5ce4cb81a              ((0x1263+4888-0x257b))\r\n#define z0194338df7         ((0x1786+2885-0x22cb))\r\n#define z2b17e2ee3b              ((0x17e9+3860-0x26fc))\r\n#define THRESHOLD               0.5\r\nstatic char msg[z71934bf57c];static void mdlInitializeSizes(SimStruct*S){uint16_t i;ssSetNumSFcnParams(S,zdf24515981);if(ssGetNumSFcnParams(S)!=ssGetSFcnParamsCount(S)){sprintf(msg,\"\\x57\\x72\\x6f\\x6e\\x67\\x20\\x6e\\x75\\x6d\\x62\\x65\\x72\\x20\\x6f\\x66\\x20\\x69\\x6e\\x70\\x75\\x74\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x70\\x61\\x73\\x73\\x65\\x64\\x2e\" \"\\n\" \"\\x25\\x64\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x61\\x72\\x65\\x20\\x65\\x78\\x70\\x65\\x63\\x74\\x65\\x64\" \"\\n\",zdf24515981);ssSetErrorStatus(S,msg);return;}ssSetNumContStates(S,(0x140a+1006-0x17f8));ssSetNumDiscStates(S,(0x1616+685-0x18c3));if(!ssSetNumOutputPorts(S,(0x13da+1201-0x188b)))return;if(!ssSetNumInputPorts(S,(int)mxGetN(z5bc3ce0d50)))return;for(i=(0x46b+7087-0x201a);i<(int)mxGetN(z5bc3ce0d50);i++){ssSetInputPortWidth(S,i,(0xe05+6052-0x25a8));ssSetInputPortDirectFeedThrough(S,i,(0xed2+5455-0x2420));ssSetInputPortRequiredContiguous(S,i,(0x12af+3337-0x1fb7));}ssSetNumSampleTimes(S,(0x1528+613-0x178c));ssSetNumRWork(S,zc5ce4cb81a);ssSetNumIWork(S,z2e6483d505);ssSetNumPWork(S,z2b17e2ee3b);ssSetNumModes(S,(0x4cd+6065-0x1c7e));ssSetNumNonsampledZCs(S,(0x117a+4372-0x228e));for(i=(0xf68+410-0x1102);i<zdf24515981;i++){ssSetSFcnParamTunable(S,i,(0x3d8+8140-0x23a4));}ssSetOptions(S,SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME|SS_OPTION_EXCEPTION_FREE_CODE|SS_OPTION_RUNTIME_EXCEPTION_FREE_CODE);}static void mdlInitializeSampleTimes(SimStruct*S){if(mxGetPr(z3832b85a32)[(0x9fa+5271-0x1e91)]==-1.0){ssSetSampleTime(S,(0x11bd+334-0x130b),INHERITED_SAMPLE_TIME);ssSetOffsetTime(S,(0x1899+3649-0x26da),FIXED_IN_MINOR_STEP_OFFSET);}else{ssSetSampleTime(S,(0x136d+1483-0x1938),mxGetPr(z3832b85a32)[(0xbe9+1888-0x1349)]);ssSetOffsetTime(S,(0x46+6698-0x1a70),0.0);}ssSetModelReferenceSampleTimeDefaultInheritance(S);}\r\n#ifndef MATLAB_MEX_FILE\r\nstatic void sg_ModelLoad(SimStruct*S){}static void sg_ModelStart(SimStruct*S){sg_PCIDevice zeccbadd9b3;uint32_t zf91d71c6d9=(uint32_t)mxGetN(z5bc3ce0d50);volatile uint32_t*z27fd94ac66;uint32_t bus,slot,za0d38ae598,zcb341ffb0e,i;if(mxGetN(z702a26a5e9)==(0x9d9+408-0xb70)){bus=(0x149+2546-0xb3b);slot=(uint32_t)mxGetPr(z702a26a5e9)[(0x140a+3821-0x22f7)];}else{bus=(uint32_t)mxGetPr(z702a26a5e9)[(0x7c+6885-0x1b61)];slot=(uint32_t)mxGetPr(z702a26a5e9)[(0x3d3+2043-0xbcd)];}za0d38ae598=((uint32_t)mxGetPr(ze13f49a01f)[(0x1799+3688-0x2601)]);if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,za1afbacc4a,z78f5b4c5a6,z2bc00458b9,za0d38ae598,bus,slot)!=(0x662+3015-0x1229)){if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,zb765876dc5,z44a525e63d,za64fcbac7d,za0d38ae598,bus,slot)!=(0x69c+69-0x6e1)){ssSetErrorStatus(S,pSgErrorStr);return;}}\r\n#ifdef _MSC_BUILD\r\nreadPciBar(&zeccbadd9b3,zeccbadd9b3.bus,zeccbadd9b3.slot,(0xe31+1798-0x1537));\r\n#endif\r\nz27fd94ac66=(volatile uint32_t*)sg_mapMemory(&zeccbadd9b3,(0xd58+5538-0x22f8));ssSetPWorkValue(S,z0194338df7,(uint32_t*)z27fd94ac66);zcb341ffb0e=z27fd94ac66[z52eac5d033];for(i=(0xb41+4562-0x1d13);i<zf91d71c6d9;i++){if((int)mxGetPr(z2d8f240c11)[i]>THRESHOLD){zcb341ffb0e|=((0xda2+5684-0x23d5)<<((uint32_t)mxGetPr(z5bc3ce0d50)[i]-(0x157d+4050-0x254e)));}else{zcb341ffb0e&=~((0x2d6+837-0x61a)<<((uint32_t)mxGetPr(z5bc3ce0d50)[i]-(0x153f+221-0x161b)));}}z27fd94ac66[z52eac5d033]=zcb341ffb0e;}static void sg_ModelStep(SimStruct*S){volatile uint32_t*z27fd94ac66=ssGetPWorkValue(S,z0194338df7);uint16_t z344fcf0ef3;uint32_t i,zcb341ffb0e;double output;double*zc7fdaf6331;z344fcf0ef3=(uint16_t)mxGetN(z5bc3ce0d50);zcb341ffb0e=(0x4fa+3413-0x124f);for(i=(0x36+8129-0x1ff7);i<z344fcf0ef3;i++){zc7fdaf6331=(double*)ssGetInputPortRealSignal(S,i);output=zc7fdaf6331[(0x19e1+2812-0x24dd)];if(output>THRESHOLD){zcb341ffb0e|=((0x671+3271-0x1337)<<((uint16_t)mxGetPr(z5bc3ce0d50)[i]-(0xab+1594-0x6e4)));}}z27fd94ac66[z52eac5d033]=zcb341ffb0e;}static void sg_ModelStop(SimStruct*S){volatile uint32_t*z27fd94ac66=ssGetPWorkValue(S,z0194338df7);uint32_t zf91d71c6d9=(uint32_t)mxGetN(z5bc3ce0d50);uint32_t i,zcb341ffb0e;zcb341ffb0e=z27fd94ac66[z52eac5d033];for(i=(0x651+2318-0xf5f);i<zf91d71c6d9;i++){if((int)mxGetPr(z1f9bebb47b)[i]==(0x127d+4999-0x2603)){if((int)mxGetPr(z2d8f240c11)[i]>THRESHOLD){zcb341ffb0e|=((0x11fa+1665-0x187a)<<((uint32_t)mxGetPr(z5bc3ce0d50)[i]-(0x996+7480-0x26cd)));}else{zcb341ffb0e&=~((0x1a70+576-0x1caf)<<((uint32_t)mxGetPr(z5bc3ce0d50)[i]-(0x85f+5265-0x1cef)));}}}z27fd94ac66[z52eac5d033]=zcb341ffb0e;}\r\n#endif  \r\n#include \"sg_sfcn_glue.h\"   \r\n\r\n"},{"name":"sg_IO191_setup_s.c","type":"source","group":"interface","path":"/home/electro/Code_Repo/n-CORTEx/JOLT_slrealtime_rtw/../../../.speedgoat/speedgoatlib/R2023a/9.6.1.1_4/sg_blocks/analog","tag":"","groupDisplay":"Interface files","code":"// Copyright 2006-2023 Speedgoat GmbH\r\n\r\n#define S_FUNCTION_LEVEL    (0x10cb+2737-0x1b7a)\r\n#undef S_FUNCTION_NAME\r\n#define S_FUNCTION_NAME     sg_IO191_setup_s\r\n#include \"sg_IO191.h\"\r\n#ifndef MATLAB_MEX_FILE\r\n#include \"sg_printf.h\"\r\n#include \"sg_common.h\"\r\nvoid readPciBar(sg_PCIDevice*z7c46aa329e,int16_t bus,int16_t slot,int16_t z1e0fd5210f);\r\n#else\r\n#include \"mex.h\"\r\n#endif\r\n#include \"sg_callback.h\"\r\n#define z702a26a5e9                ssGetSFcnParam(S, (0x154+6099-0x1927))\r\n#define ze13f49a01f           ssGetSFcnParam(S, (0xaa2+2017-0x1282))\r\n#define z1e0b67709d       ssGetSFcnParam(S, (0x7b7+749-0xaa2))\r\n#define z3644586f49         ssGetSFcnParam(S, (0x1a0c+2186-0x2293))\r\n#define z8d5c288b32         ssGetSFcnParam(S, (0x42b+217-0x500))\r\n#define z9876548c58         ssGetSFcnParam(S, (0xff7+3171-0x1c55))\r\n#define zfa79626a1f        ssGetSFcnParam(S, (0xb19+229-0xbf8))\r\n#define z832477988f        ssGetSFcnParam(S, (0xcbc+1663-0x1334))\r\n#define z4526a8632b         ssGetSFcnParam(S, (0xc27+2227-0x14d2))\r\n#define zdf24515981                           ((0xe83+6110-0x2658))\r\n#define z2e6483d505              ((0x1e94+1092-0x22d8))\r\n#define z8caad2a8e6              ((0x551+1754-0xc2b))\r\n#define z5bfe7a2613            ((0x1341+4557-0x250d))\r\n#define zc5ce4cb81a              ((0x1152+4077-0x213d))\r\n#define z0194338df7         ((0x841+6504-0x21a9))\r\n#define z2b17e2ee3b              ((0x1e5+7568-0x1f74))\r\nstatic char msg[z71934bf57c];static void mdlInitializeSizes(SimStruct*S){uint16_t i;ssSetNumSFcnParams(S,zdf24515981);if(ssGetNumSFcnParams(S)!=ssGetSFcnParamsCount(S)){sprintf(msg,\"\\x57\\x72\\x6f\\x6e\\x67\\x20\\x6e\\x75\\x6d\\x62\\x65\\x72\\x20\\x6f\\x66\\x20\\x69\\x6e\\x70\\x75\\x74\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x70\\x61\\x73\\x73\\x65\\x64\\x2e\" \"\\n\" \"\\x25\\x64\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x61\\x72\\x65\\x20\\x65\\x78\\x70\\x65\\x63\\x74\\x65\\x64\" \"\\n\",zdf24515981);ssSetErrorStatus(S,msg);return;}ssSetNumContStates(S,(0x2e0+9175-0x26b7));ssSetNumDiscStates(S,(0xa2b+4369-0x1b3c));if(!ssSetNumInputPorts(S,(0x2070+1166-0x24fe)))return;if(!ssSetNumOutputPorts(S,(0x46+573-0x283)))return;ssSetNumSampleTimes(S,(0x16a5+3548-0x2480));ssSetNumRWork(S,zc5ce4cb81a);ssSetNumIWork(S,z2e6483d505);ssSetNumPWork(S,z2b17e2ee3b);ssSetNumModes(S,(0xecd+231-0xfb4));ssSetNumNonsampledZCs(S,(0x147f+2175-0x1cfe));for(i=(0x8c2+6705-0x22f3);i<zdf24515981;i++){ssSetSFcnParamTunable(S,i,(0x72d+7595-0x24d8));}ssSetOptions(S,SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME|SS_OPTION_EXCEPTION_FREE_CODE|SS_OPTION_RUNTIME_EXCEPTION_FREE_CODE|SS_OPTION_PLACE_ASAP);}static void mdlInitializeSampleTimes(SimStruct*S){ssSetSampleTime(S,(0x21b6+431-0x2365),INHERITED_SAMPLE_TIME);ssSetOffsetTime(S,(0xc59+5933-0x2386),FIXED_IN_MINOR_STEP_OFFSET);ssSetModelReferenceSampleTimeDefaultInheritance(S);}\r\n#ifndef MATLAB_MEX_FILE\r\nstatic void sg_ModelLoad(SimStruct*S){}static void sg_ModelStart(SimStruct*S){sg_PCIDevice zeccbadd9b3;uint32_t bus,slot,za0d38ae598,i;uint16_t z4e3026977c,z0e26ef1137;volatile uint32_t*z27fd94ac66;if(mxGetN(z702a26a5e9)==(0x2413+265-0x251b)){bus=(0x1286+3641-0x20bf);slot=(uint32_t)mxGetPr(z702a26a5e9)[(0xb13+5593-0x20ec)];}else{bus=(uint32_t)mxGetPr(z702a26a5e9)[(0x1ea3+159-0x1f42)];slot=(uint32_t)mxGetPr(z702a26a5e9)[(0x9dd+2573-0x13e9)];}za0d38ae598=((uint32_t)mxGetPr(ze13f49a01f)[(0xba+8255-0x20f9)]);if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,za1afbacc4a,z78f5b4c5a6,z2bc00458b9,za0d38ae598,bus,slot)!=(0x1bed+1278-0x20eb)){if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,zb765876dc5,z44a525e63d,za64fcbac7d,za0d38ae598,bus,slot)!=(0x160+861-0x4bd)){ssSetErrorStatus(S,pSgErrorStr);return;}}\r\n#ifdef _MSC_BUILD\r\nreadPciBar(&zeccbadd9b3,zeccbadd9b3.bus,zeccbadd9b3.slot,(0x3bb+8030-0x2319));\r\n#endif\r\nz27fd94ac66=(volatile uint32_t*)sg_mapMemory(&zeccbadd9b3,(0x1017+4953-0x236e));ssSetPWorkValue(S,z0194338df7,(uint32_t*)z27fd94ac66);SG_PRINTF_DEBUG(\"\\x25\\x73\\x3a\\x20\\x46\\x50\\x47\\x41\\x20\\x72\\x65\\x76\\x20\\x30\\x78\\x25\\x58\" \"\\n\",DEVNAME,z27fd94ac66[REVISION]);z0e26ef1137=(0x3d2+7874-0x2294);for(i=(0xf05+2232-0x17bd);i<(uint32_t)mxGetN(z4526a8632b);i++){z4e3026977c=(uint32_t)mxGetPr(z4526a8632b)[i];if(z4e3026977c==(0xdb5+5768-0x243c)){z0e26ef1137=(0x21f3+336-0x2342);}else{z0e26ef1137|=((0xf52+2401-0x18b2)<<(z4e3026977c+(0x145c+4654-0x2684)));}}z27fd94ac66[zef0a03cb9f]=z0e26ef1137;}static void sg_ModelStep(SimStruct*S){}static void sg_ModelStop(SimStruct*S){}\r\n#endif  \r\n#include \"sg_sfcn_glue.h\"   \r\n\r\n"},{"name":"main.cpp","type":"source","group":"legacy","path":"/home/electro/Code_Repo/n-CORTEx/JOLT_slrealtime_rtw","tag":"","groupDisplay":"Other files","code":"/* Main generated for Simulink Real-Time model JOLT */\n#include <ModelInfo.hpp>\n#include <utilities.hpp>\n#include \"JOLT.h\"\n#include \"rte_JOLT_parameters.h\"\n\n/* Task descriptors */\nslrealtime::TaskInfo task_1( 0u, std::bind(JOLT_step), slrealtime::TaskInfo::PERIODIC, 0.001, 0, 40);\n\n/* Executable base address for XCP */\n#ifdef __linux__\nextern char __executable_start;\nstatic uintptr_t const base_address = reinterpret_cast<uintptr_t>(&__executable_start);\n#else\n/* Set 0 as placeholder, to be parsed later from /proc filesystem */\nstatic uintptr_t const base_address = 0;\n#endif\n\n/* Model descriptor */\nslrealtime::ModelInfo JOLT_Info =\n{\n    \"JOLT\",\n    JOLT_initialize,\n    JOLT_terminate,\n    []()->char const*& { return JOLT_M->errorStatus; },\n    []()->unsigned char& { return JOLT_M->Timing.stopRequestedFlag; },\n    { task_1 },\n    slrealtime::getSegmentVector()\n};\n\nint main(int argc, char *argv[]) {\n    slrealtime::BaseAddress::set(base_address);\n    return slrealtime::runModel(argc, argv, JOLT_Info);\n}\n"},{"name":"rt_matrx.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2023a/rtw/c/src","tag":"","groupDisplay":"Other files","code":"/* File    : rt_matrx.c\n * Abstract:\n *      Implements stand alone matrix access and creation routines.\n *\tThere are two types of MATLAB objects which can be \"passed\" to\n *\tthe generated code, a 2D real matrix and a string. Strings are\n *\tpassed as 2D real matrices. The first two elements of an S-function\n *\tparameters are the row and column (m and n) dimensions respectively.\n *\tThese are followed by the matrix data.\n */\n\n\n\n/*\n * Copyright 1994-2022 The MathWorks, Inc.\n */\n\n/*==========*\n * Includes *\n *==========*/\n\n#if defined(MDL_REF_SIM_TGT)\n#undef MATLAB_MEX_FILE\n#endif\n\n#if defined(MATLAB_MEX_FILE)\n# error \"rt_matrix cannot be used within a mex file. It is for codegen only.\"\n#endif\n\n#include <string.h>    /* for strlen */\n#include \"rt_matrx.h\"\n\n#include <stddef.h> /* needed for size_t and NULL */\n#include <float.h>  /* needed for definition of eps */\n\n/*==========*\n * Typedefs *\n *==========*/\n\n#ifndef rt_typedefs_h\n#define rt_typedefs_h\n\n#if !defined(TYPEDEF_MX_ARRAY)\n# define TYPEDEF_MX_ARRAY\n  typedef real_T mxArray;\n#endif\n\ntypedef real_T mxChar;\n\n#if !defined(TMW_NAME_LENGTH_MAX)\n#define TMW_NAME_LENGTH_MAX 64\n#endif\n#define mxMAXNAM  TMW_NAME_LENGTH_MAX\t/* maximum name length */\n\ntypedef enum {\n    mxREAL,\n    mxCOMPLEX\n} mxComplexity;\n\n#endif /* rt_typedefs_h */\n\n/*==================*\n * Extern variables *\n *==================*/\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nextern real_T rtInf;\nextern real_T rtMinusInf;\nextern real_T rtNaN;\n\n#ifdef __cplusplus\n}\n#endif\n\n/*=======================================*\n * Defines for mx Routines and constants *\n *=======================================*/\n\n\n#define mxCalloc(n,size) \\\n        calloc(n,size)\n\n#define mxCreateCharArray(ndim, dims) \\\n        mxCreateNumericArray(ndim, dims, mxCHAR_CLASS);\n\n#define mxDestroyArray(pa) \\\n        if (pa) free(pa)\n\n/* NOTE: You cannot mxFree(mxGetPr(pa)) !!! */\n#define mxFree(ptr) \\\n        if(ptr)free(ptr)\n\n#define mxGetClassID(pa) \\\n        mxDOUBLE_CLASS\n\n/* NOTE: mxGetClassName(pa) returns \"double\" even on a character array */\n#define mxGetClassName(pa) \\\n        \"double\"\n\n#define mxGetData(pa) \\\n        ((void *)(&((pa)[2])))\n\n#define mxGetElementSize(pa) \\\n        (sizeof(real_T))\n\n#define mxGetInf() \\\n        rtInf\n\n#define mxGetM(pa) \\\n        ((size_t) ((pa)[0]))\n#define mxGetN(pa) \\\n        ((size_t) ((pa)[1]))\n\n#define mxGetNaN() \\\n        rtNaN\n\n#define mxGetNumberOfDimensions(pa) \\\n        (2)\n#define mxGetNumberOfElements(pa) \\\n        (mxGetM(pa)*mxGetN(pa))\n\n/* NOTE: mxGetPr() of an empty matrix does NOT return NULL */\n#define mxGetPr(pa) \\\n        ( &((pa)[2]) )\n\n/* NOTE: mxGetDoubles() of an empty matrix does NOT return NULL */\n#define mxGetDoubles(pa) \\\n        ( &((pa)[2]) )\n\n#define mxGetScalar(pa) \\\n        ((pa)[2])\n\n#define mxIsComplex(pa) \\\n        false\n\n#define mxIsDouble(pa) \\\n        true\n\n#define mxIsEmpty(pa) \\\n        (mxGetM(pa)==0 || mxGetN(pa)==0)\n\n#define mxIsFinite(r) \\\n        ((r)>rtMinusInf && (r)<rtInf)\n\n#define mxIsInf(r) \\\n        ((r)==rtInf || (r)==rtMinusInf)\n\n#define mxIsInt16(pa) \\\n        false\n\n#define mxIsInt32(pa) \\\n        false\n\n#define mxIsInt8(pa) \\\n        false\n\n#define mxIsLogical(pa) \\\n        false\n\n#define mxIsNumeric(pa) \\\n        true\n\n#define mxIsSingle(pa) \\\n        false\n\n#define mxIsSparse(pa) \\\n        false\n\n#define mxIsStruct(pa) \\\n        false\n\n#define mxIsUint16(pa) \\\n        false\n\n#define mxIsUint32(pa) \\\n        false\n\n#define mxIsUint8(pa) \\\n        false\n\n#define mxMalloc(n) \\\n        malloc(n)\n\n#define mxRealloc(p,n) \\\n        realloc(p,n)\n\n/*==============*\n * Local macros *\n *==============*/\n#define _mxSetM(pa,m) \\\n        (pa)[0] = ((int)(m))\n\n#define _mxSetN(pa,n) \\\n        (pa)[1] = ((int)(n))\n\n\n/*==========================*\n * Visible/extern functions *\n *=========================*/\n\n/* Function: mxCreateCharMatrixFromStrings ====================================\n * Abstract:\n *\tCreate a string array initialized to the strings in str.\n */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nmxArray *rt_mxCreateCharMatrixFromStrings(int_T m, const char_T **str)\n{\n    int_T nchars;\n    int_T i, n;\n    mxArray *pa;\n\n    n = 0;\n    for (i = 0; i < m; ++i) {\n\tnchars = (int_T)strlen(str[i]);\n\tif (nchars > n) {\n\t    n = nchars;\n\t}\n    }\n\n    pa = (mxArray *)malloc((m*n+2)*sizeof(real_T));\n    if(pa!=NULL) {\n\tmxChar *chars;\n\tint_T  j;\n\t_mxSetM(pa, m);\n\t_mxSetN(pa, n);\n\tchars = mxGetPr(pa);\n\tfor (j = 0; j < m; ++j) {\n\t    const char_T *src  = str[j];\n\t    mxChar *dest = chars + j;\n\n\t    nchars = (int_T)strlen(src);\n\t    i = nchars;\n\t    while (i--) {\n\t\t*dest = *src++;\n\t\t dest += m;\n\t    }\n\t    i = n - nchars;\n\t    while (i--) {\n\t\t*dest = 0.0;\n\t\tdest += m;\n\t    }\n\t}\n    }\n    return pa;\n} /* end mxCreateCharMatrixFromStrings */\n\n#ifdef __cplusplus\n}\n#endif\n\n/* Function: mxCreateString ===================================================\n * Abstract:\n *\tCreate a 1-by-n string array initialized to null terminated string\n *\twhere n is the length of the string.\n */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nmxArray *rt_mxCreateString(const char *str)\n{\n    int_T   len = (int_T)strlen(str);\n\n    mxArray *pa = (mxArray *)malloc((len+2)*sizeof(real_T));\n\n    if(pa!=NULL) {\n\treal_T *pr;\n\tconst unsigned char *ustr_ptr = (const unsigned char *) str;\n\n\t_mxSetM(pa, 1);\n\t_mxSetN(pa, len);\n\tpr = mxGetPr(pa);\n\twhile (len--) {\n            *pr++ = (real_T)*ustr_ptr++;\n        }\n    }\n    return(pa);\n\n} /* end mxCreateString */\n\n#ifdef __cplusplus\n}\n#endif\n\n/* Function: mxCreateDoubleMatrix =============================================\n * Abstract:\n *\tCreate a two-dimensional array to hold real_T data,\n *\tinitialize each data element to 0.\n */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nmxArray *rt_mxCreateDoubleMatrix(int m, int n, mxComplexity flag)\n{\n    if (flag == mxREAL) {\n        mxArray *pa = (mxArray *)calloc(m*n+2, sizeof(real_T));\n        if(pa!=NULL) {\n            _mxSetM(pa, m);\n            _mxSetN(pa, n);\n        }\n        return(pa);\n    } else {\n        return(NULL);\n    }\n\n} /* end mxCreateDoubleMatrix */\n\n#ifdef __cplusplus\n}\n#endif\n\n/* Function: mxCreateNumericArray =============================================\n * Abstract:\n *\tCreate a numeric array and initialize all its data elements to 0.\n */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nmxArray *rt_mxCreateNumericArray(int_T ndims, const mwSize *dims, \n                                        mxClassID classid, mxComplexity flag)\n{\n    if (ndims == 2 && classid==mxDOUBLE_CLASS) {\n        return(rt_mxCreateDoubleMatrix((int)(dims[0]), (int)(dims[1]), flag));\n    } else {\n        return(NULL);\n    }\n\n} /* end mxCreateNumericArray */\n\n#ifdef __cplusplus\n}\n#endif\n\n/* Function: mxDuplicateArray =================================================\n * Abstract:\n *\tMake a deep copy of an array, return a pointer to the copy.\n */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nmxArray *rt_mxDuplicateArray(const mxArray *pa)\n{\n\n    size_t   nbytes = (mxGetNumberOfElements(pa)+2)*mxGetElementSize(pa);\n    mxArray *pcopy = (mxArray *)malloc(nbytes);\n\n    if (pcopy!=NULL) {\n\t(void)memcpy(pcopy, pa, nbytes);\n    }\n    return(pcopy);\n\n} /* end mxDuplicateArray */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n/* Function: mxGetDimensions ==================================================\n * Abstract:\n *\tGet pointer to dimension array\n */\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nconst mwSize *rt_mxGetDimensions(const mxArray *pa)\n{\n    static mwSize dims[2];\n    dims[0] = mxGetM(pa);\n    dims[1] = mxGetN(pa);\n    return dims;\n} /* end mxGetDimensions */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n/* Function: mxGetEps =========================================================\n * Abstract:\n *\tReturn eps, the difference between 1.0 and the least value\n *\tgreater than 1.0 that is representable as a real_T.\n */\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nreal_T rt_mxGetEps(void)\n{\n    return (sizeof(double)==sizeof(real_T)) ? DBL_EPSILON : FLT_EPSILON;\n}\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n/* Function: mxGetString ======================================================\n * Abstract:\n *\tConverts a string array to a C-style string.\n */\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nint_T rt_mxGetString(const mxArray *pa, char_T *buf, int_T buflen)\n{\n    int_T        nchars;\n    const real_T *pr;\n    char_T       *pc;\n    int_T        truncate = 0;\n\n    nchars = (int_T)mxGetNumberOfElements(pa);\n    if (nchars >= buflen) {\n\t/* leave room for null byte */\n\tnchars = buflen - 1;\n\ttruncate = 1;\n    }\n    pc = buf;\n    pr = mxGetPr(pa);\n    while (nchars--) {\n\t*pc++ = (char) (*pr++ + .5);\n    }\n    *pc = '\\0';\n    return truncate;\n} /* end mxGetString */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n#define mxCreateCharMatrixFromStrings(m, str) \\\n        rt_mxCreateCharMatrixFromStrings(m, str)\n\n#define mxCreateString(str) \\\n        rt_mxCreateString(str) \n\n#define mxCreateDoubleMatrix(m, n, flag) \\\n        rt_mxCreateDoubleMatrix(m, n, flag)\n\n#define mxCreateNumericArray(ndims, dims, classid, flag) \\\n        rt_mxCreateNumericArray(ndims, dims, classid, flag)\n\n#define mxDuplicateArray(pa) \\\n        rt_mxDuplicateArray(pa)\n\n#define mxGetDimensions(pa) \\\n        rt_mxGetDimensions(pa)\n\n#define mxGetEps() \\\n        rt_mxGetEps()\n\n#define mxGetString(pa, buf, buflen) \\\n        rt_mxGetString(pa, buf, buflen)\n\n/*=========================*\n * Unsupported mx Routines *\n *=========================*/\n\n#define mxCalcSingleSubscript(pa,nsubs,subs) \\\n        mxCalcSingleSubscript_is_not_supported_in_Simulink_Coder\n\n#define mxCreateCellArray(ndim,dims) \\\n        mxCreateCellArray_is_not_supported_in_Simulink_Coder\n\n#define mxCreateCellMatrix(m,n) \\\n        mxCreateCellMatrix_is_not_supported_in_Simulink_Coder\n\n#define mxCreateSparse(pm,pn,pnzmax,pcmplx_flg) \\\n        mxCreateSparse_is_not_supported_in_Simulink_Coder\n\n#define mxCreateStructArray(ndim,dims,nfields,fieldnames) \\\n        mxCreateStructArray_is_not_supported_in_Simulink_Coder\n\n#define mxCreateStructMatrix(m,n,nfields,fieldnames) \\\n        mxCreateStructMatrix_is_not_supported_in_Simulink_Coder\n\n#define mxGetCell(pa,i) \\\n        mxGetCell_is_not_supported_in_Simulink_Coder\n\n#define mxGetField(pa,i,fieldname) \\\n        mxGetField_is_not_supported_in_Simulink_Coder\n\n#define mxGetFieldByNumber(s,i,fieldnum) \\\n        mxGetFieldByNumber_is_not_supported_in_Simulink_Coder\n\n#define mxGetFieldNameByNumber(pa,n) \\\n        mxGetFieldNameByNumber_is_not_supported_in_Simulink_Coder\n\n#define mxGetFieldNumber(pa,fieldname) \\\n        mxGetFieldNumber_is_not_supported_in_Simulink_Coder\n\n#define mxGetImagData(pa) \\\n        mxGetImagData_is_not_supported_in_Simulink_Coder\n\n#define mxGetIr(ppa) \\\n        mxGetIr_is_not_supported_in_Simulink_Coder\n\n#define mxGetJc(ppa) \\\n        mxGetJc_is_not_supported_in_Simulink_Coder\n\n#define mxGetNumberOfFields(pa) \\\n        mxGetNumberOfFields_is_not_supported_in_Simulink_Coder\n\n#define mxGetNzmax(pa) \\\n        mxGetNzmax_is_not_supported_in_Simulink_Coder\n\n#define mxGetPi(pa) \\\n        mxGetPi_is_not_supported_in_Simulink_Coder\n\n#define mxIsFromGlobalWS(pa) \\\n        mxIsFromGlobalWS_is_not_supported_in_Simulink_Coder\n\n#define mxIsNaN(r) \\\n        mxIsNaN_is_not_supported_in_Simulink_Coder\n\n#define mxIsChar(pa) \\\n        mxIsChar_is_not_supported_in_Simulink_Coder\n\n#define mxIsClass(pa,class) \\\n        mxIsClass_is_not_supported_in_Simulink_Coder\n\n#define mxIsCell(pa) \\\n        mxIsCell_is_not_supported_in_Simulink_Coder\n\n#define mxSetCell(pa,i,value) \\\n        mxSetCell_is_not_supported_in_Simulink_Coder\n\n#define mxSetClassName(pa,classname) \\\n        mxSetClassName_is_not_supported_in_Simulink_Coder\n\n#define mxSetData(pa,pr) \\\n        mxSetData_is_not_supported_in_Simulink_Coder\n\n#define mxSetDimensions(pa, size, ndims) \\\n        mxSetDimensions_is_not_supported_in_Simulink_Coder\n\n#define mxSetField(pa,i,fieldname,value) \\\n        mxSetField_is_not_supported_in_Simulink_Coder\n\n#define mxSetFieldByNumber(pa, index, fieldnum, value) \\\n        mxSetFieldByNumber_is_not_supported_in_Simulink_Coder\n\n#define mxSetFromGlobalWS(pa,global) \\\n        mxSetFromGlobalWS_is_not_supported_in_Simulink_Coder\n\n#define mxSetImagData(pa,pv) \\\n        mxSetImagData_is_not_supported_in_Simulink_Coder\n\n#define mxSetIr(ppa,ir) \\\n        mxSetIr_is_not_supported_in_Simulink_Coder\n\n#define mxSetJc(ppa,jc) \\\n        mxSetJc_is_not_supported_in_Simulink_Coder\n\n#define mxSetM(pa, m) \\\n        mxSetM_is_not_supported_in_Simulink_Coder\n\n#define mxSetN(pa, m) \\\n        mxSetN_is_not_supported_in_Simulink_Coder\n\n#define mxSetPr(pa,pr) \\\n        mxSetPr_is_not_supported_in_Simulink_Coder\n\n#define mxSetNzmax(pa,nzmax) \\\n        mxSetNzmax_is_not_supported_in_Simulink_Coder\n\n#define mxSetPi(pa,pv) \\\n        mxSetPi_is_not_supported_in_Simulink_Coder\n\n\n\n/*==========================*\n * Unsupported mex routines *\n *==========================*/\n\n#define mexPrintAssertion(test,fname,linenum,message) \\\n        mexPrintAssertion_is_not_supported_by_Simulink_Coder\n\n#define mexEvalString(str) \\\n        mexEvalString_is_not_supported_by_Simulink_Coder\n\n#define mexErrMsgTxt(str) \\\n        mexErrMsgTxt_is_not_supported_by_Simulink_Coder\n\n#define mexWarnMsgTxt(warning_msg) \\\n        mexWarnMsgTxt_is_not_supported_by_Simulink_Coder\n\n#define mexPrintf \\\n        mexPrintf_is_not_supported_by_Simulink_Coder\n\n#define mexMakeArrayPersistent(pa) \\\n        mexMakeArrayPersistent_is_not_supported_by_Simulink_Coder\n\n#define mexMakeMemoryPersistent(ptr) \\\n        mexMakeMemoryPersistent_is_not_supported_by_Simulink_Coder\n\n#define mexLock() \\\n        mexLock_is_not_supported_by_Simulink_Coder\n\n#define mexUnlock() \\\n        mexUnlock_is_not_supported_by_Simulink_Coder\n\n#define mexFunctionName() \\\n        mexFunctionName_is_not_supported_by_Simulink_Coder\n\n#define mexIsLocked() \\\n        mexIsLocked_is_not_supported_by_Simulink_Coder\n\n#define mexGetFunctionHandle() \\\n        mexGetFunctionHandle_is_not_supported_by_Simulink_Coder\n\n#define mexCallMATLABFunction() \\\n        mexCallMATLABFunction_is_not_supported_by_Simulink_Coder\n\n#define mexRegisterFunction() \\\n        mexRegisterFunction_is_not_supported_by_Simulink_Coder\n\n#define mexSet(handle,property,value) \\\n        mexSet_is_not_supported_by_Simulink_Coder\n\n#define mexGet(handle,property) \\\n        mexGet_is_not_supported_by_Simulink_Coder\n\n#define mexCallMATLAB(nlhs,plhs,nrhs,prhs,fcn) \\\n        mexCallMATLAB_is_not_supported_by_Simulink_Coder\n\n#define mexSetTrapFlag(flag) \\\n        mexSetTrapFlag_is_not_supported_by_Simulink_Coder\n\n#define mexUnlink(a) \\\n        mexUnlink_is_not_supported_by_Simulink_Coderw\n\n#define mexSubsAssign(plhs,sub,nsubs,prhs) \\\n        mexSubsAssign_is_not_supported_by_Simulink_Coder\n\n#define mexSubsReference(prhs,subs,nsubs) \\\n        mexSubsReference_is_not_supported_by_Simulink_Coder\n\n#define mexPrintAssertion(test,fname,linenum,message) \\\n        mexPrintAssertion_is_not_supported_by_Simulink_Coder\n\n#define mexAddFlops(count) \\\n        mexAddFlops_is_not_supported_by_Simulink_Coder\n\n#define mexIsGlobal(pa) \\\n        mexIsGlobal_is_not_supported_by_Simulink_Coder\n\n#define mexAtExit(fcn) \\\n        mexAtExit_is_not_supported_by_Simulink_Coder\n\n/* [EOF] rt_matrx.c */\n"},{"name":"rt_printf.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2023a/rtw/c/src","tag":"","groupDisplay":"Other files","code":"/* Copyright 1994-2015 The MathWorks, Inc.\n *\n * File: rt_printf.c\n *\n * Abstract:\n *      Stub I/O printf facility for systems which don't have stdio.\n *\n */\n\n\n\n/* Function: rtPrintfNoOp ======================================================\n * Abstract:\n *      Maps ssPrintf to rtPrintfNoOp if HAVESTDIO is not defined (see\n *      simstruct.h\n */\nint rtPrintfNoOp(const char *fmt, ...)\n{\n    /* do nothing */\n    return(fmt == (const char *)0); /* use fmt to quiet unused var warning */\n}\n\n\n/* [eof] rt_printf.c */\n"},{"name":"rte_JOLT_parameters.cpp","type":"source","group":"legacy","path":"/home/electro/Code_Repo/n-CORTEx/JOLT_slrealtime_rtw","tag":"","groupDisplay":"Other files","code":"#include \"rte_JOLT_parameters.h\"\n#include \"JOLT.h\"\n#include \"JOLT_cal.h\"\n\nextern JOLT_cal_type JOLT_cal_impl;\nnamespace slrealtime\n{\n  /* Description of SEGMENTS */\n  SegmentVector segmentInfo {\n    { (void*)&JOLT_cal_impl, (void**)&JOLT_cal, sizeof(JOLT_cal_type), 2 }\n  };\n\n  SegmentVector &getSegmentVector(void)\n  {\n    return segmentInfo;\n  }\n}                                      // slrealtime\n"},{"name":"rte_JOLT_parameters.h","type":"header","group":"other","path":"/home/electro/Code_Repo/n-CORTEx/JOLT_slrealtime_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef _RTE_JOLT_PARAMETERS_H\n#define _RTE_JOLT_PARAMETERS_H\n#include \"rtwtypes.h\"\n#include \"SegmentInfo.hpp\"\n\nnamespace slrealtime\n{\n  SegmentVector &getSegmentVector(void);\n}                                      // slrealtime\n\n#endif\n"},{"name":"slrealtime_datatype_ground.cpp","type":"source","group":"legacy","path":"/home/electro/Code_Repo/n-CORTEx/JOLT_slrealtime_rtw","tag":"","groupDisplay":"Other files","code":"#include \"slrtdatatypes.h\"\n\nconst serialfifoptr serialfifoground = { 0, 0, 0 };\n\nconst bcmsglist1553 bcmsg1553ground = { 0, 0, 0, 0 };\n\nconst bcstatus1553 bcstatground = { 0, 0, 0, 0, 0, 0 };\n\nconst bmmsglist1553 bmmsg1553ground = { 0, 0, 0, 0 };\n"}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true}};