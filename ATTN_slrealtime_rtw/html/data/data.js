var dataJson = {"arch":{"ispc":false,"isunix":true,"ismac":false},"build":"ATTN","ref":false,"files":[{"name":"ATTN.cpp","type":"source","group":"model","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * ATTN.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.506\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Tue Dec 12 16:07:50 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"ATTN.h\"\n#include \"rtwtypes.h\"\n#include \"ATTN_private.h\"\n#include \"ATTN_cal.h\"\n#include <cstring>\n#include <cmath>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n/* Named constants for MATLAB Function: '<S3>/MATLAB Function2' */\nconst int32_T ATTN_CALL_EVENT = -1;\n\n/* Named constants for MATLAB Function: '<Root>/MATLAB Function' */\nconst int32_T ATTN_CALL_EVENT_n = -1;\nconst real_T ATTN_RGND = 0.0;          /* real_T ground */\n\n/* Block signals (default storage) */\nB_ATTN_T ATTN_B;\n\n/* Block states (default storage) */\nDW_ATTN_T ATTN_DW;\n\n/* Real-time model */\nRT_MODEL_ATTN_T ATTN_M_ = RT_MODEL_ATTN_T();\nRT_MODEL_ATTN_T *const ATTN_M = &ATTN_M_;\n\n/* Forward declaration for local functions */\nstatic real_T ATTN_rand(void);\n\n/*\n * System initialize for atomic system:\n *    '<S3>/MATLAB Function2'\n *    '<S4>/MATLAB Function1'\n */\nvoid ATTN_MATLABFunction2_Init(DW_MATLABFunction2_ATTN_T *localDW)\n{\n  localDW->sfEvent = ATTN_CALL_EVENT;\n  localDW->t0_not_empty = false;\n  localDW->y0_not_empty = false;\n  localDW->is_active_c3_ATTN = 0U;\n}\n\n/*\n * Output and update for atomic system:\n *    '<S3>/MATLAB Function2'\n *    '<S4>/MATLAB Function1'\n */\nvoid ATTN_MATLABFunction2(real_T rtu_trigger, real_T rtu_duration, real_T\n  rtu_amp, real_T rtu_t, B_MATLABFunction2_ATTN_T *localB,\n  DW_MATLABFunction2_ATTN_T *localDW)\n{\n  real_T increment;\n  localDW->sfEvent = ATTN_CALL_EVENT;\n  increment = rtu_amp / (rtu_duration * 1000.0 / 2.0);\n  if (rtu_trigger != 0.0) {\n    localDW->t0 = rtu_t;\n    localDW->t0_not_empty = true;\n    localB->y = 0.0;\n    localDW->y0 = 0.0;\n    localDW->y0_not_empty = true;\n  } else if (localDW->t0_not_empty) {\n    real_T tmp;\n    tmp = rtu_t - localDW->t0;\n    if (tmp <= rtu_duration / 2.0) {\n      localB->y = localDW->y0 + increment;\n      localDW->y0 = localB->y;\n    } else if (tmp <= rtu_duration) {\n      localB->y = localDW->y0 - increment;\n      increment = localB->y;\n      if (increment > 0.0) {\n        localB->y = increment;\n      } else {\n        localB->y = 0.0;\n      }\n\n      localDW->y0 = localB->y;\n    } else {\n      localB->y = 0.0;\n    }\n  } else {\n    localB->y = 0.0;\n  }\n}\n\n/* Function for MATLAB Function: '<Root>/MATLAB Function' */\nstatic real_T ATTN_rand(void)\n{\n  real_T r;\n  uint32_T u[2];\n  if (ATTN_DW.method == 4U) {\n    int32_T k;\n    uint32_T mti;\n    uint32_T y;\n    k = static_cast<int32_T>(ATTN_DW.state / 127773U);\n    mti = (ATTN_DW.state - static_cast<uint32_T>(k) * 127773U) * 16807U;\n    y = 2836U * static_cast<uint32_T>(k);\n    if (mti < y) {\n      mti = ~(y - mti) & 2147483647U;\n    } else {\n      mti -= y;\n    }\n\n    r = static_cast<real_T>(mti) * 4.6566128752457969E-10;\n    ATTN_DW.state = mti;\n  } else if (ATTN_DW.method == 5U) {\n    uint32_T mti;\n    uint32_T y;\n    mti = 69069U * ATTN_DW.state_p[0] + 1234567U;\n    y = ATTN_DW.state_p[1] << 13 ^ ATTN_DW.state_p[1];\n    y ^= y >> 17;\n    y ^= y << 5;\n    ATTN_DW.state_p[0] = mti;\n    ATTN_DW.state_p[1] = y;\n    r = static_cast<real_T>(mti + y) * 2.328306436538696E-10;\n  } else {\n    /* ========================= COPYRIGHT NOTICE ============================ */\n    /*  This is a uniform (0,1) pseudorandom number generator based on:        */\n    /*                                                                         */\n    /*  A C-program for MT19937, with initialization improved 2002/1/26.       */\n    /*  Coded by Takuji Nishimura and Makoto Matsumoto.                        */\n    /*                                                                         */\n    /*  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,      */\n    /*  All rights reserved.                                                   */\n    /*                                                                         */\n    /*  Redistribution and use in source and binary forms, with or without     */\n    /*  modification, are permitted provided that the following conditions     */\n    /*  are met:                                                               */\n    /*                                                                         */\n    /*    1. Redistributions of source code must retain the above copyright    */\n    /*       notice, this list of conditions and the following disclaimer.     */\n    /*                                                                         */\n    /*    2. Redistributions in binary form must reproduce the above copyright */\n    /*       notice, this list of conditions and the following disclaimer      */\n    /*       in the documentation and/or other materials provided with the     */\n    /*       distribution.                                                     */\n    /*                                                                         */\n    /*    3. The names of its contributors may not be used to endorse or       */\n    /*       promote products derived from this software without specific      */\n    /*       prior written permission.                                         */\n    /*                                                                         */\n    /*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    */\n    /*  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT      */\n    /*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  */\n    /*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT  */\n    /*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  */\n    /*  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT       */\n    /*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  */\n    /*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  */\n    /*  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    */\n    /*  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE */\n    /*  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */\n    /*                                                                         */\n    /* =============================   END   ================================= */\n    int32_T exitg1;\n    do {\n      int32_T k;\n      uint32_T mti;\n      exitg1 = 0;\n      for (k = 0; k < 2; k++) {\n        uint32_T y;\n        mti = ATTN_DW.state_k[624] + 1U;\n        if (mti >= 625U) {\n          for (int32_T kk = 0; kk < 227; kk++) {\n            mti = (ATTN_DW.state_k[kk + 1] & 2147483647U) | (ATTN_DW.state_k[kk]\n              & 2147483648U);\n            if ((mti & 1U) == 0U) {\n              mti >>= 1U;\n            } else {\n              mti = mti >> 1U ^ 2567483615U;\n            }\n\n            ATTN_DW.state_k[kk] = ATTN_DW.state_k[kk + 397] ^ mti;\n          }\n\n          for (int32_T kk = 0; kk < 396; kk++) {\n            mti = (ATTN_DW.state_k[kk + 227] & 2147483648U) |\n              (ATTN_DW.state_k[kk + 228] & 2147483647U);\n            if ((mti & 1U) == 0U) {\n              mti >>= 1U;\n            } else {\n              mti = mti >> 1U ^ 2567483615U;\n            }\n\n            ATTN_DW.state_k[kk + 227] = ATTN_DW.state_k[kk] ^ mti;\n          }\n\n          mti = (ATTN_DW.state_k[623] & 2147483648U) | (ATTN_DW.state_k[0] &\n            2147483647U);\n          if ((mti & 1U) == 0U) {\n            mti >>= 1U;\n          } else {\n            mti = mti >> 1U ^ 2567483615U;\n          }\n\n          ATTN_DW.state_k[623] = ATTN_DW.state_k[396] ^ mti;\n          mti = 1U;\n        }\n\n        y = ATTN_DW.state_k[static_cast<int32_T>(mti) - 1];\n        ATTN_DW.state_k[624] = mti;\n        y ^= y >> 11U;\n        y ^= y << 7U & 2636928640U;\n        y ^= y << 15U & 4022730752U;\n        u[k] = y >> 18U ^ y;\n      }\n\n      r = (static_cast<real_T>(u[0] >> 5U) * 6.7108864E+7 + static_cast<real_T>\n           (u[1] >> 6U)) * 1.1102230246251565E-16;\n      if (r == 0.0) {\n        boolean_T b_isvalid;\n        if ((ATTN_DW.state_k[624] >= 1U) && (ATTN_DW.state_k[624] < 625U)) {\n          boolean_T exitg2;\n          b_isvalid = false;\n          k = 1;\n          exitg2 = false;\n          while ((!exitg2) && (k < 625)) {\n            if (ATTN_DW.state_k[k - 1] == 0U) {\n              k++;\n            } else {\n              b_isvalid = true;\n              exitg2 = true;\n            }\n          }\n        } else {\n          b_isvalid = false;\n        }\n\n        if (!b_isvalid) {\n          mti = 5489U;\n          ATTN_DW.state_k[0] = 5489U;\n          for (k = 0; k < 623; k++) {\n            mti = ((mti >> 30U ^ mti) * 1812433253U + static_cast<uint32_T>(k))\n              + 1U;\n            ATTN_DW.state_k[k + 1] = mti;\n          }\n\n          ATTN_DW.state_k[624] = 624U;\n        }\n      } else {\n        exitg1 = 1;\n      }\n    } while (exitg1 == 0);\n  }\n\n  return r;\n}\n\n/* Model step function */\nvoid ATTN_step(void)\n{\n  real_T b_y1;\n  real_T random_number;\n  int32_T cff;\n  int32_T j;\n\n  /* Memory: '<Root>/Memory8' */\n  ATTN_B.Memory8 = ATTN_DW.Memory8_PreviousInput;\n\n  /* Memory: '<Root>/Memory2' */\n  ATTN_B.Memory2 = ATTN_DW.Memory2_PreviousInput;\n\n  /* Memory: '<Root>/Memory1' */\n  ATTN_B.Memory1 = ATTN_DW.Memory1_PreviousInput;\n\n  /* Memory: '<Root>/Memory' */\n  ATTN_B.Memory = ATTN_DW.Memory_PreviousInput;\n\n  /* S-Function (sg_IO191_setup_s): '<Root>/Setup ' */\n\n  /* Level2 S-Function Block: '<Root>/Setup ' (sg_IO191_setup_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[0];\n    sfcnOutputs(rts,0);\n  }\n\n  /* S-Function (sg_IO191_ad_s): '<Root>/Analog input ' */\n\n  /* Level2 S-Function Block: '<Root>/Analog input ' (sg_IO191_ad_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[1];\n    sfcnOutputs(rts,0);\n  }\n\n  /* DiscreteFir: '<Root>/Discrete FIR Filter1' */\n  cff = 1;\n  b_y1 = ATTN_B.lickometer_piezo * ATTN_cal->DiscreteFIRFilter1_Coefficients[0];\n  for (j = ATTN_DW.DiscreteFIRFilter1_circBuf; j < 1500; j++) {\n    random_number = ATTN_DW.DiscreteFIRFilter1_states[j] *\n      ATTN_cal->DiscreteFIRFilter1_Coefficients[cff];\n    b_y1 += random_number;\n    cff++;\n  }\n\n  for (j = 0; j < ATTN_DW.DiscreteFIRFilter1_circBuf; j++) {\n    random_number = ATTN_DW.DiscreteFIRFilter1_states[j] *\n      ATTN_cal->DiscreteFIRFilter1_Coefficients[cff];\n    b_y1 += random_number;\n    cff++;\n  }\n\n  /* DiscreteFir: '<Root>/Discrete FIR Filter1' */\n  ATTN_B.filtered_lickometer = b_y1;\n\n  /* Memory: '<Root>/Memory11' */\n  ATTN_B.Memory11 = ATTN_DW.Memory11_PreviousInput;\n\n  /* Memory: '<Root>/Memory7' */\n  ATTN_B.Memory7 = ATTN_DW.Memory7_PreviousInput;\n\n  /* MATLAB Function: '<Root>/MATLAB Function1' incorporates:\n   *  Constant: '<Root>/Thrd'\n   */\n  ATTN_DW.sfEvent_b = ATTN_CALL_EVENT_n;\n  if (std::abs(ATTN_B.filtered_lickometer) > ATTN_cal->Thrd_Value) {\n    b_y1 = ATTN_B.Memory11 + 1.0;\n    ATTN_B.y2 = ATTN_B.Memory7;\n  } else {\n    b_y1 = 0.0;\n    ATTN_B.y2 = 0.0;\n  }\n\n  if ((b_y1 > 20.0) && (ATTN_B.Memory7 == 0.0)) {\n    ATTN_B.Lick = 1.0;\n    ATTN_B.y2 = 1.0;\n  } else {\n    ATTN_B.Lick = 0.0;\n  }\n\n  ATTN_B.y1 = b_y1;\n\n  /* End of MATLAB Function: '<Root>/MATLAB Function1' */\n\n  /* Clock: '<Root>/Clock' */\n  ATTN_B.clock_time = ATTN_M->Timing.t[0];\n\n  /* Memory: '<Root>/Memory3' */\n  ATTN_B.Memory3 = ATTN_DW.Memory3_PreviousInput;\n\n  /* Memory: '<Root>/Memory4' */\n  ATTN_B.Memory4 = ATTN_DW.Memory4_PreviousInput;\n\n  /* Memory: '<Root>/Memory9' */\n  ATTN_B.Memory9 = ATTN_DW.Memory9_PreviousInput;\n\n  /* Memory: '<Root>/Memory5' */\n  ATTN_B.Memory5 = ATTN_DW.Memory5_PreviousInput;\n\n  /* Memory: '<Root>/Memory6' */\n  ATTN_B.Memory6 = ATTN_DW.Memory6_PreviousInput;\n\n  /* Memory: '<Root>/Memory10' */\n  ATTN_B.Memory10 = ATTN_DW.Memory10_PreviousInput;\n\n  /* MATLAB Function: '<Root>/MATLAB Function' incorporates:\n   *  Constant: '<Root>/rewardDuration'\n   *  Constant: '<Root>/targetSide'\n   *  Constant: '<Root>/trainingStage'\n   *  Constant: '<Root>/triangleDuration'\n   */\n  ATTN_DW.sfEvent_e = ATTN_CALL_EVENT_n;\n  ATTN_B.counter_out = ATTN_B.Memory4 + 1.0;\n  switch (static_cast<int32_T>(ATTN_cal->trainingStage)) {\n   case 1:\n    switch (static_cast<int32_T>(ATTN_B.Memory2)) {\n     case 1:\n      ATTN_B.npxlsAcq_out = 1.0;\n      ATTN_B.state_out = 2.0;\n      ATTN_B.localTime_out = 1.0;\n      ATTN_B.trialNum_out = 1.0;\n      ATTN_B.right_trigger_out = 0.0;\n      ATTN_B.left_trigger_out = 0.0;\n      b_y1 = 0.0;\n      random_number = 4.0;\n      while ((random_number >= 9.0) || (random_number <= 5.0)) {\n        random_number = ATTN_rand();\n        random_number = std::log(random_number);\n        random_number *= -7.0;\n      }\n\n      ATTN_B.delay_out = ATTN_B.clock_time + random_number;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = 0.0;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 2:\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n      } else {\n        ATTN_B.state_out = 3.0;\n      }\n\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      b_y1 = ATTN_B.Memory9;\n      ATTN_B.delay_out = ATTN_B.Memory5;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 3:\n      if (ATTN_rand() <= 0.8) {\n        if (ATTN_cal->targetSide != 0.0) {\n          ATTN_B.right_trigger_out = 1.0;\n          ATTN_B.left_trigger_out = 0.0;\n        } else {\n          ATTN_B.left_trigger_out = 1.0;\n          ATTN_B.right_trigger_out = 0.0;\n        }\n\n        ATTN_B.was_target_out = 0.0;\n      } else {\n        if (ATTN_cal->targetSide != 0.0) {\n          ATTN_B.left_trigger_out = 1.0;\n          ATTN_B.right_trigger_out = 0.0;\n        } else {\n          ATTN_B.right_trigger_out = 1.0;\n          ATTN_B.left_trigger_out = 0.0;\n        }\n\n        ATTN_B.was_target_out = 1.0;\n      }\n\n      ATTN_B.state_out = 4.0;\n      ATTN_B.delay_out = ATTN_B.clock_time + 0.2;\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      b_y1 = ATTN_B.Memory9;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 4:\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n        ATTN_B.delay_out = ATTN_B.Memory5;\n      } else if (ATTN_B.Memory10 != 0.0) {\n        ATTN_B.state_out = 5.0;\n        ATTN_B.delay_out = ATTN_B.clock_time + 1.0;\n      } else {\n        ATTN_B.state_out = 6.0;\n        ATTN_B.delay_out = ATTN_B.clock_time + 1.0;\n      }\n\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.left_trigger_out = 0.0;\n      ATTN_B.right_trigger_out = 0.0;\n      b_y1 = ATTN_B.Memory9;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 5:\n      ATTN_B.reward_trigger_out = 1.0;\n      ATTN_B.state_out = 6.0;\n      ATTN_B.delay_out = ATTN_B.Memory5;\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      b_y1 = ATTN_B.Memory9;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 6:\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n      } else {\n        ATTN_B.state_out = 1.0;\n      }\n\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      b_y1 = ATTN_B.Memory9;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.delay_out = ATTN_B.Memory5;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     default:\n      ATTN_B.state_out = ATTN_B.Memory2;\n      ATTN_B.localTime_out = ATTN_B.Memory1;\n      ATTN_B.trialNum_out = ATTN_B.Memory;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      b_y1 = ATTN_B.Memory9;\n      ATTN_B.delay_out = ATTN_B.Memory5;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n    }\n    break;\n\n   case 2:\n    switch (static_cast<int32_T>(ATTN_B.Memory2)) {\n     case 1:\n      ATTN_B.npxlsAcq_out = 1.0;\n      ATTN_B.state_out = 2.0;\n      ATTN_B.localTime_out = 1.0;\n      ATTN_B.trialNum_out = 1.0;\n      ATTN_B.right_trigger_out = 0.0;\n      ATTN_B.left_trigger_out = 0.0;\n      b_y1 = 0.0;\n      random_number = 4.0;\n      while ((random_number >= 9.0) || (random_number <= 5.0)) {\n        random_number = ATTN_rand();\n        random_number = std::log(random_number);\n        random_number *= -7.0;\n      }\n\n      ATTN_B.delay_out = ATTN_B.clock_time + random_number;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 2:\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n      } else {\n        ATTN_B.state_out = 3.0;\n      }\n\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      b_y1 = ATTN_B.Memory9;\n      ATTN_B.delay_out = ATTN_B.Memory5;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 3:\n      if (ATTN_rand() <= 0.8) {\n        if (ATTN_cal->targetSide != 0.0) {\n          ATTN_B.right_trigger_out = 1.0;\n          ATTN_B.left_trigger_out = 0.0;\n        } else {\n          ATTN_B.left_trigger_out = 1.0;\n          ATTN_B.right_trigger_out = 0.0;\n        }\n\n        ATTN_B.was_target_out = 0.0;\n      } else {\n        if (ATTN_cal->targetSide != 0.0) {\n          ATTN_B.left_trigger_out = 1.0;\n          ATTN_B.right_trigger_out = 0.0;\n        } else {\n          ATTN_B.right_trigger_out = 1.0;\n          ATTN_B.left_trigger_out = 0.0;\n        }\n\n        ATTN_B.was_target_out = 1.0;\n      }\n\n      ATTN_B.state_out = 4.0;\n      ATTN_B.delay_out = ATTN_B.clock_time + 0.2;\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      b_y1 = ATTN_B.Memory9;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 4:\n      if (ATTN_B.Lick != 0.0) {\n        b_y1 = ATTN_B.Memory9 + 1.0;\n      } else {\n        b_y1 = ATTN_B.Memory9;\n      }\n\n      if (b_y1 != 0.0) {\n        ATTN_B.state_out = 7.0;\n        ATTN_B.delay_out = ATTN_B.clock_time + 2.0;\n      } else if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n        ATTN_B.delay_out = ATTN_B.Memory5;\n      } else {\n        ATTN_B.state_out = 5.0;\n        ATTN_B.delay_out = ATTN_B.clock_time + 1.5;\n      }\n\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.left_trigger_out = 0.0;\n      ATTN_B.right_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 5:\n      if (ATTN_B.Lick != 0.0) {\n        b_y1 = ATTN_B.Memory9 + 1.0;\n      } else {\n        b_y1 = ATTN_B.Memory9;\n      }\n\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n        ATTN_B.delay_out = ATTN_B.Memory5;\n      } else if ((ATTN_B.Memory9 != 0.0) && (ATTN_B.Memory10 != 0.0)) {\n        ATTN_B.state_out = 6.0;\n        ATTN_B.delay_out = ATTN_B.Memory5;\n      } else {\n        ATTN_B.state_out = 7.0;\n        ATTN_B.delay_out = ATTN_B.clock_time + 0.5;\n      }\n\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 6:\n      ATTN_B.reward_trigger_out = 1.0;\n      ATTN_B.state_out = 7.0;\n      ATTN_B.delay_out = ATTN_B.clock_time + 0.5;\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      b_y1 = ATTN_B.Memory9;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 7:\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n      } else {\n        ATTN_B.state_out = 1.0;\n      }\n\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      b_y1 = ATTN_B.Memory9;\n      ATTN_B.delay_out = ATTN_B.Memory5;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     default:\n      ATTN_B.state_out = ATTN_B.Memory2;\n      ATTN_B.localTime_out = ATTN_B.Memory1;\n      ATTN_B.trialNum_out = ATTN_B.Memory;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      b_y1 = ATTN_B.Memory9;\n      ATTN_B.delay_out = ATTN_B.Memory5;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n    }\n    break;\n\n   case 3:\n    switch (static_cast<int32_T>(ATTN_B.Memory2)) {\n     case 1:\n      ATTN_B.npxlsAcq_out = 1.0;\n      ATTN_B.state_out = 2.0;\n      ATTN_B.localTime_out = 1.0;\n      ATTN_B.trialNum_out = 1.0;\n      ATTN_B.right_trigger_out = 0.0;\n      ATTN_B.left_trigger_out = 0.0;\n      if ((!(ATTN_B.Memory10 != 0.0)) && (!(ATTN_B.Memory9 != 0.0))) {\n        b_y1 = 1.0;\n        while ((b_y1 >= 4.0) || (b_y1 <= 2.0)) {\n          b_y1 = ATTN_rand();\n          b_y1 = std::log(b_y1);\n          b_y1 *= -3.0;\n        }\n\n        ATTN_B.delay_out = ATTN_B.clock_time + b_y1;\n      } else {\n        b_y1 = 4.0;\n        while ((b_y1 >= 9.0) || (b_y1 <= 5.0)) {\n          b_y1 = ATTN_rand();\n          b_y1 = std::log(b_y1);\n          b_y1 *= -7.0;\n        }\n\n        ATTN_B.delay_out = ATTN_B.clock_time + b_y1;\n      }\n\n      b_y1 = 0.0;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = 0.0;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 2:\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n      } else {\n        ATTN_B.state_out = 3.0;\n      }\n\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      b_y1 = ATTN_B.Memory9;\n      ATTN_B.delay_out = ATTN_B.Memory5;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 3:\n      if (ATTN_rand() <= 0.8) {\n        if (ATTN_cal->targetSide != 0.0) {\n          ATTN_B.right_trigger_out = 1.0;\n          ATTN_B.left_trigger_out = 0.0;\n        } else {\n          ATTN_B.left_trigger_out = 1.0;\n          ATTN_B.right_trigger_out = 0.0;\n        }\n\n        ATTN_B.was_target_out = 0.0;\n      } else {\n        if (ATTN_cal->targetSide != 0.0) {\n          ATTN_B.left_trigger_out = 1.0;\n          ATTN_B.right_trigger_out = 0.0;\n        } else {\n          ATTN_B.right_trigger_out = 1.0;\n          ATTN_B.left_trigger_out = 0.0;\n        }\n\n        ATTN_B.was_target_out = 1.0;\n      }\n\n      ATTN_B.state_out = 4.0;\n      ATTN_B.delay_out = ATTN_B.clock_time + 0.2;\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      b_y1 = ATTN_B.Memory9;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 4:\n      if (ATTN_B.Lick != 0.0) {\n        b_y1 = ATTN_B.Memory9 + 1.0;\n      } else {\n        b_y1 = ATTN_B.Memory9;\n      }\n\n      if (b_y1 != 0.0) {\n        ATTN_B.state_out = 7.0;\n        ATTN_B.delay_out = ATTN_B.clock_time + 1.5;\n      } else if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n        ATTN_B.delay_out = ATTN_B.Memory5;\n      } else {\n        ATTN_B.state_out = 5.0;\n        ATTN_B.delay_out = ATTN_B.clock_time + 1.0;\n      }\n\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      b_y1 = ATTN_B.Memory9;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.left_trigger_out = 0.0;\n      ATTN_B.right_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 5:\n      if (ATTN_B.Lick != 0.0) {\n        b_y1 = ATTN_B.Memory9 + 1.0;\n      } else {\n        b_y1 = ATTN_B.Memory9;\n      }\n\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n        ATTN_B.delay_out = ATTN_B.Memory5;\n      } else if ((ATTN_B.Memory9 != 0.0) && (ATTN_B.Memory10 != 0.0)) {\n        ATTN_B.state_out = 6.0;\n        ATTN_B.delay_out = ATTN_B.Memory5;\n      } else {\n        ATTN_B.state_out = 7.0;\n        ATTN_B.delay_out = ATTN_B.clock_time + 0.5;\n      }\n\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 6:\n      ATTN_B.reward_trigger_out = 1.0;\n      ATTN_B.state_out = 7.0;\n      ATTN_B.delay_out = ATTN_B.clock_time + 0.5;\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      b_y1 = ATTN_B.Memory9;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 7:\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n      } else {\n        ATTN_B.state_out = 1.0;\n      }\n\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      b_y1 = ATTN_B.Memory9;\n      ATTN_B.delay_out = ATTN_B.Memory5;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     default:\n      ATTN_B.state_out = ATTN_B.Memory2;\n      ATTN_B.localTime_out = ATTN_B.Memory1;\n      ATTN_B.trialNum_out = ATTN_B.Memory;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      b_y1 = ATTN_B.Memory9;\n      ATTN_B.delay_out = ATTN_B.Memory5;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n    }\n    break;\n\n   case 111:\n    if (static_cast<int32_T>(ATTN_B.Memory2) == 1) {\n      ATTN_B.npxlsAcq_out = 0.0;\n      ATTN_B.localTime_out = 1.0;\n      ATTN_B.trialNum_out = 1.0;\n      ATTN_B.right_trigger_out = 0.0;\n      ATTN_B.left_trigger_out = 0.0;\n      ATTN_B.delay_out = ATTN_B.clock_time + 1.0;\n      b_y1 = 0.0;\n      ATTN_B.reward_trigger_out = 1.0;\n      ATTN_B.was_target_out = 0.0;\n      ATTN_B.reward_duration_out = 0.02;\n      ATTN_B.state_out = 2.0;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n    } else {\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n        ATTN_B.reward_trigger_out = 0.0;\n        ATTN_B.delay_out = ATTN_B.Memory5;\n        ATTN_B.reward_duration_out = 0.02;\n      } else {\n        ATTN_B.state_out = ATTN_B.Memory2 + 1.0;\n        ATTN_B.reward_trigger_out = 1.0;\n        ATTN_B.delay_out = ATTN_B.clock_time + 1.0;\n        ATTN_B.reward_duration_out = 0.02;\n      }\n\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      b_y1 = ATTN_B.Memory9;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n    }\n    break;\n\n   case 222:\n    if (static_cast<int32_T>(ATTN_B.Memory2) == 1) {\n      ATTN_B.npxlsAcq_out = 0.0;\n      ATTN_B.localTime_out = 1.0;\n      ATTN_B.trialNum_out = 1.0;\n      if (ATTN_cal->targetSide != 0.0) {\n        ATTN_B.right_trigger_out = 1.0;\n        ATTN_B.left_trigger_out = 0.0;\n      } else {\n        ATTN_B.left_trigger_out = 1.0;\n        ATTN_B.right_trigger_out = 0.0;\n      }\n\n      ATTN_B.delay_out = ATTN_B.clock_time + 1.0;\n      b_y1 = 0.0;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = 0.0;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.state_out = 2.0;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n    } else {\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n        ATTN_B.delay_out = ATTN_B.Memory5;\n        ATTN_B.left_trigger_out = 0.0;\n        ATTN_B.right_trigger_out = 0.0;\n      } else {\n        ATTN_B.state_out = ATTN_B.Memory2 + 1.0;\n        ATTN_B.delay_out = ATTN_B.clock_time + 1.0;\n        if (ATTN_cal->targetSide != 0.0) {\n          ATTN_B.right_trigger_out = 1.0;\n          ATTN_B.left_trigger_out = 0.0;\n        } else {\n          ATTN_B.left_trigger_out = 1.0;\n          ATTN_B.right_trigger_out = 0.0;\n        }\n      }\n\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      b_y1 = ATTN_B.Memory9;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n    }\n    break;\n\n   default:\n    if (static_cast<int32_T>(ATTN_B.Memory2) == 1) {\n      ATTN_B.npxlsAcq_out = 0.0;\n      ATTN_B.localTime_out = 1.0;\n      ATTN_B.trialNum_out = 1.0;\n      if (ATTN_cal->targetSide != 0.0) {\n        ATTN_B.right_trigger_out = 1.0;\n        ATTN_B.left_trigger_out = 0.0;\n      } else {\n        ATTN_B.left_trigger_out = 1.0;\n        ATTN_B.right_trigger_out = 0.0;\n      }\n\n      ATTN_B.delay_out = ATTN_B.clock_time + 10.0;\n      b_y1 = 0.0;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = 0.0;\n      ATTN_B.stim_duration_out = 0.05;\n      ATTN_B.state_out = 2.0;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n    } else {\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n        ATTN_B.delay_out = ATTN_B.Memory5;\n        ATTN_B.left_trigger_out = 0.0;\n        ATTN_B.right_trigger_out = 0.0;\n        ATTN_B.stim_duration_out = (ATTN_B.Memory2 - 1.0) * 0.05;\n      } else {\n        ATTN_B.state_out = ATTN_B.Memory2 + 1.0;\n        ATTN_B.delay_out = ATTN_B.clock_time + 10.0;\n        if (ATTN_cal->targetSide != 0.0) {\n          ATTN_B.right_trigger_out = 1.0;\n          ATTN_B.left_trigger_out = 0.0;\n        } else {\n          ATTN_B.left_trigger_out = 1.0;\n          ATTN_B.right_trigger_out = 0.0;\n        }\n\n        ATTN_B.stim_duration_out = 0.05 * ATTN_B.Memory2;\n      }\n\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      b_y1 = ATTN_B.Memory9;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n    }\n    break;\n  }\n\n  ATTN_B.numLicks_out = b_y1;\n\n  /* End of MATLAB Function: '<Root>/MATLAB Function' */\n\n  /* Clock: '<S4>/Clock1' */\n  ATTN_B.Clock1 = ATTN_M->Timing.t[0];\n\n  /* MATLAB Function: '<S4>/MATLAB Function1' incorporates:\n   *  Constant: '<Root>/triangleAmplitude'\n   */\n  ATTN_MATLABFunction2(ATTN_B.Memory8, ATTN_B.stim_duration_out,\n                       ATTN_cal->triangleAmplitude, ATTN_B.Clock1,\n                       &ATTN_B.sf_MATLABFunction1_d,\n                       &ATTN_DW.sf_MATLABFunction1_d);\n\n  /* Clock: '<S3>/Clock2' */\n  ATTN_B.Clock2 = ATTN_M->Timing.t[0];\n\n  /* MATLAB Function: '<S3>/MATLAB Function2' incorporates:\n   *  Constant: '<Root>/triangleAmplitude'\n   */\n  ATTN_MATLABFunction2(ATTN_B.Memory6, ATTN_B.stim_duration_out,\n                       ATTN_cal->triangleAmplitude, ATTN_B.Clock2,\n                       &ATTN_B.sf_MATLABFunction2, &ATTN_DW.sf_MATLABFunction2);\n\n  /* S-Function (sg_IO191_da_s): '<Root>/Analog output ' */\n\n  /* Level2 S-Function Block: '<Root>/Analog output ' (sg_IO191_da_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[2];\n    sfcnOutputs(rts,0);\n  }\n\n  /* DiscretePulseGenerator: '<Root>/Whisker Trig' */\n  b_y1 = ATTN_cal->T_whisk / 2.0;\n\n  /* DiscretePulseGenerator: '<Root>/Whisker Trig' */\n  ATTN_B.whiskCam_trig = (ATTN_DW.clockTickCounter < b_y1) &&\n    (ATTN_DW.clockTickCounter >= 0) ? ATTN_cal->WhiskerTrig_Amp : 0.0;\n\n  /* DiscretePulseGenerator: '<Root>/Whisker Trig' */\n  if (ATTN_DW.clockTickCounter >= ATTN_cal->T_whisk - 1.0) {\n    ATTN_DW.clockTickCounter = 0;\n  } else {\n    ATTN_DW.clockTickCounter++;\n  }\n\n  /* DiscretePulseGenerator: '<Root>/Npxls Trig' */\n  b_y1 = ATTN_cal->T_npxls / 2.0;\n\n  /* DiscretePulseGenerator: '<Root>/Npxls Trig' */\n  ATTN_B.npxls_trig = (ATTN_DW.clockTickCounter_n < b_y1) &&\n    (ATTN_DW.clockTickCounter_n >= 0) ? ATTN_cal->NpxlsTrig_Amp : 0.0;\n\n  /* DiscretePulseGenerator: '<Root>/Npxls Trig' */\n  if (ATTN_DW.clockTickCounter_n >= ATTN_cal->T_npxls - 1.0) {\n    ATTN_DW.clockTickCounter_n = 0;\n  } else {\n    ATTN_DW.clockTickCounter_n++;\n  }\n\n  /* DiscretePulseGenerator: '<Root>/Pupil Trig' */\n  b_y1 = ATTN_cal->T_pupil / 2.0;\n\n  /* DiscretePulseGenerator: '<Root>/Pupil Trig' */\n  ATTN_B.pupilCam_trig = (ATTN_DW.clockTickCounter_c < b_y1) &&\n    (ATTN_DW.clockTickCounter_c >= 0) ? ATTN_cal->PupilTrig_Amp : 0.0;\n\n  /* DiscretePulseGenerator: '<Root>/Pupil Trig' */\n  if (ATTN_DW.clockTickCounter_c >= ATTN_cal->T_pupil - 1.0) {\n    ATTN_DW.clockTickCounter_c = 0;\n  } else {\n    ATTN_DW.clockTickCounter_c++;\n  }\n\n  /* Clock: '<S5>/Clock1' */\n  ATTN_B.Clock1_b = ATTN_M->Timing.t[0];\n\n  /* MATLAB Function: '<S5>/MATLAB Function1' incorporates:\n   *  Constant: '<S5>/Constant4'\n   */\n  ATTN_DW.sfEvent_a = ATTN_CALL_EVENT_n;\n  if (ATTN_B.reward_trigger_out != 0.0) {\n    ATTN_DW.t0_p = ATTN_B.Clock1_b;\n    ATTN_DW.t0_not_empty_p = true;\n    ATTN_B.y = ATTN_cal->Constant4_Value;\n  } else if (ATTN_DW.t0_not_empty_p) {\n    if (ATTN_B.Clock1_b - ATTN_DW.t0_p <= ATTN_B.reward_duration_out) {\n      ATTN_B.y = ATTN_cal->Constant4_Value;\n    } else {\n      ATTN_B.y = 0.0;\n    }\n  } else {\n    ATTN_B.y = 0.0;\n  }\n\n  /* End of MATLAB Function: '<S5>/MATLAB Function1' */\n\n  /* Clock: '<S6>/Clock1' */\n  ATTN_B.Clock1_l = ATTN_M->Timing.t[0];\n\n  /* MATLAB Function: '<S6>/MATLAB Function1' */\n  ATTN_DW.sfEvent = ATTN_CALL_EVENT_n;\n  if (ATTN_B.onsetTone_trig != 0.0) {\n    ATTN_B.tonePulse = 1.0;\n    ATTN_DW.t0 = ATTN_B.Clock1_l;\n    ATTN_DW.t0_not_empty = true;\n  } else if (ATTN_DW.t0_not_empty) {\n    ATTN_B.tonePulse = (ATTN_B.Clock1_l - ATTN_DW.t0 < 1.5);\n  } else {\n    ATTN_B.tonePulse = 0.0;\n  }\n\n  /* End of MATLAB Function: '<S6>/MATLAB Function1' */\n\n  /* S-Function (sg_IO191_do_s): '<Root>/Digital output ' */\n\n  /* Level2 S-Function Block: '<Root>/Digital output ' (sg_IO191_do_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[3];\n    sfcnOutputs(rts,0);\n  }\n\n  /* S-Function (sg_IO191_di_s): '<Root>/Digital input ' */\n\n  /* Level2 S-Function Block: '<Root>/Digital input ' (sg_IO191_di_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[4];\n    sfcnOutputs(rts,0);\n  }\n\n  /* RateTransition generated from: '<Root>/Digital input ' */\n  ATTN_B.HiddenRateTransitionForToWks_In = ATTN_B.PulseGen1Hz;\n\n  /* RelationalOperator: '<Root>/Relational Operator' incorporates:\n   *  Constant: '<Root>/Constant'\n   */\n  ATTN_B.RelationalOperator = (ATTN_B.counter_out >= ATTN_cal->maxFrame);\n\n  /* Stop: '<Root>/Stop Simulation' */\n  if (ATTN_B.RelationalOperator) {\n    rtmSetStopRequested(ATTN_M, 1);\n  }\n\n  /* End of Stop: '<Root>/Stop Simulation' */\n\n  /* Update for Memory: '<Root>/Memory8' */\n  ATTN_DW.Memory8_PreviousInput = ATTN_B.right_trigger_out;\n\n  /* Update for Memory: '<Root>/Memory2' */\n  ATTN_DW.Memory2_PreviousInput = ATTN_B.state_out;\n\n  /* Update for Memory: '<Root>/Memory1' */\n  ATTN_DW.Memory1_PreviousInput = ATTN_B.localTime_out;\n\n  /* Update for Memory: '<Root>/Memory' */\n  ATTN_DW.Memory_PreviousInput = ATTN_B.trialNum_out;\n\n  /* Update for DiscreteFir: '<Root>/Discrete FIR Filter1' */\n  /* Update circular buffer index */\n  ATTN_DW.DiscreteFIRFilter1_circBuf--;\n  if (ATTN_DW.DiscreteFIRFilter1_circBuf < 0) {\n    ATTN_DW.DiscreteFIRFilter1_circBuf = 1499;\n  }\n\n  /* Update circular buffer */\n  ATTN_DW.DiscreteFIRFilter1_states[ATTN_DW.DiscreteFIRFilter1_circBuf] =\n    ATTN_B.lickometer_piezo;\n\n  /* End of Update for DiscreteFir: '<Root>/Discrete FIR Filter1' */\n\n  /* Update for Memory: '<Root>/Memory11' */\n  ATTN_DW.Memory11_PreviousInput = ATTN_B.y1;\n\n  /* Update for Memory: '<Root>/Memory7' */\n  ATTN_DW.Memory7_PreviousInput = ATTN_B.y2;\n\n  /* Update for Memory: '<Root>/Memory3' */\n  ATTN_DW.Memory3_PreviousInput = ATTN_B.npxlsAcq_out;\n\n  /* Update for Memory: '<Root>/Memory4' */\n  ATTN_DW.Memory4_PreviousInput = ATTN_B.counter_out;\n\n  /* Update for Memory: '<Root>/Memory9' */\n  ATTN_DW.Memory9_PreviousInput = ATTN_B.numLicks_out;\n\n  /* Update for Memory: '<Root>/Memory5' */\n  ATTN_DW.Memory5_PreviousInput = ATTN_B.delay_out;\n\n  /* Update for Memory: '<Root>/Memory6' */\n  ATTN_DW.Memory6_PreviousInput = ATTN_B.left_trigger_out;\n\n  /* Update for Memory: '<Root>/Memory10' */\n  ATTN_DW.Memory10_PreviousInput = ATTN_B.was_target_out;\n\n  /* Update absolute time for base rate */\n  /* The \"clockTick0\" counts the number of times the code of this task has\n   * been executed. The absolute time is the multiplication of \"clockTick0\"\n   * and \"Timing.stepSize0\". Size of \"clockTick0\" ensures timer will not\n   * overflow during the application lifespan selected.\n   * Timer of this task consists of two 32 bit unsigned integers.\n   * The two integers represent the low bits Timing.clockTick0 and the high bits\n   * Timing.clockTickH0. When the low bit overflows to 0, the high bits increment.\n   */\n  if (!(++ATTN_M->Timing.clockTick0)) {\n    ++ATTN_M->Timing.clockTickH0;\n  }\n\n  ATTN_M->Timing.t[0] = ATTN_M->Timing.clockTick0 * ATTN_M->Timing.stepSize0 +\n    ATTN_M->Timing.clockTickH0 * ATTN_M->Timing.stepSize0 * 4294967296.0;\n\n  {\n    /* Update absolute timer for sample time: [0.001s, 0.0s] */\n    /* The \"clockTick1\" counts the number of times the code of this task has\n     * been executed. The absolute time is the multiplication of \"clockTick1\"\n     * and \"Timing.stepSize1\". Size of \"clockTick1\" ensures timer will not\n     * overflow during the application lifespan selected.\n     * Timer of this task consists of two 32 bit unsigned integers.\n     * The two integers represent the low bits Timing.clockTick1 and the high bits\n     * Timing.clockTickH1. When the low bit overflows to 0, the high bits increment.\n     */\n    if (!(++ATTN_M->Timing.clockTick1)) {\n      ++ATTN_M->Timing.clockTickH1;\n    }\n\n    ATTN_M->Timing.t[1] = ATTN_M->Timing.clockTick1 * ATTN_M->Timing.stepSize1 +\n      ATTN_M->Timing.clockTickH1 * ATTN_M->Timing.stepSize1 * 4294967296.0;\n  }\n}\n\n/* Model initialize function */\nvoid ATTN_initialize(void)\n{\n  /* Registration code */\n\n  /* initialize non-finites */\n  rt_InitInfAndNaN(sizeof(real_T));\n\n  {\n    /* Setup solver object */\n    rtsiSetSimTimeStepPtr(&ATTN_M->solverInfo, &ATTN_M->Timing.simTimeStep);\n    rtsiSetTPtr(&ATTN_M->solverInfo, &rtmGetTPtr(ATTN_M));\n    rtsiSetStepSizePtr(&ATTN_M->solverInfo, &ATTN_M->Timing.stepSize0);\n    rtsiSetErrorStatusPtr(&ATTN_M->solverInfo, (&rtmGetErrorStatus(ATTN_M)));\n    rtsiSetRTModelPtr(&ATTN_M->solverInfo, ATTN_M);\n  }\n\n  rtsiSetSimTimeStep(&ATTN_M->solverInfo, MAJOR_TIME_STEP);\n  rtsiSetSolverName(&ATTN_M->solverInfo,\"FixedStepDiscrete\");\n  ATTN_M->solverInfoPtr = (&ATTN_M->solverInfo);\n\n  /* Initialize timing info */\n  {\n    int_T *mdlTsMap = ATTN_M->Timing.sampleTimeTaskIDArray;\n    mdlTsMap[0] = 0;\n    mdlTsMap[1] = 1;\n\n    /* polyspace +2 MISRA2012:D4.1 [Justified:Low] \"ATTN_M points to\n       static memory which is guaranteed to be non-NULL\" */\n    ATTN_M->Timing.sampleTimeTaskIDPtr = (&mdlTsMap[0]);\n    ATTN_M->Timing.sampleTimes = (&ATTN_M->Timing.sampleTimesArray[0]);\n    ATTN_M->Timing.offsetTimes = (&ATTN_M->Timing.offsetTimesArray[0]);\n\n    /* task periods */\n    ATTN_M->Timing.sampleTimes[0] = (0.0);\n    ATTN_M->Timing.sampleTimes[1] = (0.001);\n\n    /* task offsets */\n    ATTN_M->Timing.offsetTimes[0] = (0.0);\n    ATTN_M->Timing.offsetTimes[1] = (0.0);\n  }\n\n  rtmSetTPtr(ATTN_M, &ATTN_M->Timing.tArray[0]);\n\n  {\n    int_T *mdlSampleHits = ATTN_M->Timing.sampleHitArray;\n    mdlSampleHits[0] = 1;\n    mdlSampleHits[1] = 1;\n    ATTN_M->Timing.sampleHits = (&mdlSampleHits[0]);\n  }\n\n  rtmSetTFinal(ATTN_M, -1);\n  ATTN_M->Timing.stepSize0 = 0.001;\n  ATTN_M->Timing.stepSize1 = 0.001;\n  ATTN_M->solverInfoPtr = (&ATTN_M->solverInfo);\n  ATTN_M->Timing.stepSize = (0.001);\n  rtsiSetFixedStepSize(&ATTN_M->solverInfo, 0.001);\n  rtsiSetSolverMode(&ATTN_M->solverInfo, SOLVER_MODE_SINGLETASKING);\n\n  /* block I/O */\n  (void) std::memset((static_cast<void *>(&ATTN_B)), 0,\n                     sizeof(B_ATTN_T));\n\n  /* states (dwork) */\n  (void) std::memset(static_cast<void *>(&ATTN_DW), 0,\n                     sizeof(DW_ATTN_T));\n\n  /* child S-Function registration */\n  {\n    RTWSfcnInfo *sfcnInfo = &ATTN_M->NonInlinedSFcns.sfcnInfo;\n    ATTN_M->sfcnInfo = (sfcnInfo);\n    rtssSetErrorStatusPtr(sfcnInfo, (&rtmGetErrorStatus(ATTN_M)));\n    ATTN_M->Sizes.numSampTimes = (2);\n    rtssSetNumRootSampTimesPtr(sfcnInfo, &ATTN_M->Sizes.numSampTimes);\n    ATTN_M->NonInlinedSFcns.taskTimePtrs[0] = (&rtmGetTPtr(ATTN_M)[0]);\n    ATTN_M->NonInlinedSFcns.taskTimePtrs[1] = (&rtmGetTPtr(ATTN_M)[1]);\n    rtssSetTPtrPtr(sfcnInfo,ATTN_M->NonInlinedSFcns.taskTimePtrs);\n    rtssSetTStartPtr(sfcnInfo, &rtmGetTStart(ATTN_M));\n    rtssSetTFinalPtr(sfcnInfo, &rtmGetTFinal(ATTN_M));\n    rtssSetTimeOfLastOutputPtr(sfcnInfo, &rtmGetTimeOfLastOutput(ATTN_M));\n    rtssSetStepSizePtr(sfcnInfo, &ATTN_M->Timing.stepSize);\n    rtssSetStopRequestedPtr(sfcnInfo, &rtmGetStopRequested(ATTN_M));\n    rtssSetDerivCacheNeedsResetPtr(sfcnInfo, &ATTN_M->derivCacheNeedsReset);\n    rtssSetZCCacheNeedsResetPtr(sfcnInfo, &ATTN_M->zCCacheNeedsReset);\n    rtssSetContTimeOutputInconsistentWithStateAtMajorStepPtr(sfcnInfo,\n      &ATTN_M->CTOutputIncnstWithState);\n    rtssSetSampleHitsPtr(sfcnInfo, &ATTN_M->Timing.sampleHits);\n    rtssSetPerTaskSampleHitsPtr(sfcnInfo, &ATTN_M->Timing.perTaskSampleHits);\n    rtssSetSimModePtr(sfcnInfo, &ATTN_M->simMode);\n    rtssSetSolverInfoPtr(sfcnInfo, &ATTN_M->solverInfoPtr);\n  }\n\n  ATTN_M->Sizes.numSFcns = (5);\n\n  /* register each child */\n  {\n    (void) std::memset(static_cast<void *>\n                       (&ATTN_M->NonInlinedSFcns.childSFunctions[0]), 0,\n                       5*sizeof(SimStruct));\n    ATTN_M->childSfunctions = (&ATTN_M->NonInlinedSFcns.childSFunctionPtrs[0]);\n\n    {\n      int_T i;\n      for (i = 0; i < 5; i++) {\n        ATTN_M->childSfunctions[i] = (&ATTN_M->NonInlinedSFcns.childSFunctions[i]);\n      }\n    }\n\n    /* Level2 S-Function Block: ATTN/<Root>/Setup  (sg_IO191_setup_s) */\n    {\n      SimStruct *rts = ATTN_M->childSfunctions[0];\n\n      /* timing info */\n      time_T *sfcnPeriod = ATTN_M->NonInlinedSFcns.Sfcn0.sfcnPeriod;\n      time_T *sfcnOffset = ATTN_M->NonInlinedSFcns.Sfcn0.sfcnOffset;\n      int_T *sfcnTsMap = ATTN_M->NonInlinedSFcns.Sfcn0.sfcnTsMap;\n      (void) std::memset(static_cast<void*>(sfcnPeriod), 0,\n                         sizeof(time_T)*1);\n      (void) std::memset(static_cast<void*>(sfcnOffset), 0,\n                         sizeof(time_T)*1);\n      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);\n      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);\n      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);\n\n      {\n        ssSetBlkInfo2Ptr(rts, &ATTN_M->NonInlinedSFcns.blkInfo2[0]);\n      }\n\n      _ssSetBlkInfo2PortInfo2Ptr(rts,\n        &ATTN_M->NonInlinedSFcns.inputOutputPortInfo2[0]);\n\n      /* Set up the mdlInfo pointer */\n      ssSetRTWSfcnInfo(rts, ATTN_M->sfcnInfo);\n\n      /* Allocate memory of model methods 2 */\n      {\n        ssSetModelMethods2(rts, &ATTN_M->NonInlinedSFcns.methods2[0]);\n      }\n\n      /* Allocate memory of model methods 3 */\n      {\n        ssSetModelMethods3(rts, &ATTN_M->NonInlinedSFcns.methods3[0]);\n      }\n\n      /* Allocate memory of model methods 4 */\n      {\n        ssSetModelMethods4(rts, &ATTN_M->NonInlinedSFcns.methods4[0]);\n      }\n\n      /* Allocate memory for states auxilliary information */\n      {\n        ssSetStatesInfo2(rts, &ATTN_M->NonInlinedSFcns.statesInfo2[0]);\n        ssSetPeriodicStatesInfo(rts, &ATTN_M->\n          NonInlinedSFcns.periodicStatesInfo[0]);\n      }\n\n      /* path info */\n      ssSetModelName(rts, \"Setup \");\n      ssSetPath(rts, \"ATTN/Setup \");\n      ssSetRTModel(rts,ATTN_M);\n      ssSetParentSS(rts, (NULL));\n      ssSetRootSS(rts, rts);\n      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);\n\n      /* parameters */\n      {\n        mxArray **sfcnParams = (mxArray **)\n          &ATTN_M->NonInlinedSFcns.Sfcn0.params;\n        ssSetSFcnParamsCount(rts, 9);\n        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);\n        ssSetSFcnParam(rts, 0, (mxArray*)ATTN_cal->Setup_P1_Size);\n        ssSetSFcnParam(rts, 1, (mxArray*)ATTN_cal->Setup_P2_Size);\n        ssSetSFcnParam(rts, 2, (mxArray*)ATTN_cal->Setup_P3_Size);\n        ssSetSFcnParam(rts, 3, (mxArray*)ATTN_cal->Setup_P4_Size);\n        ssSetSFcnParam(rts, 4, (mxArray*)ATTN_cal->Setup_P5_Size);\n        ssSetSFcnParam(rts, 5, (mxArray*)ATTN_cal->Setup_P6_Size);\n        ssSetSFcnParam(rts, 6, (mxArray*)ATTN_cal->Setup_P7_Size);\n        ssSetSFcnParam(rts, 7, (mxArray*)ATTN_cal->Setup_P8_Size);\n        ssSetSFcnParam(rts, 8, (mxArray*)ATTN_cal->Setup_P9_Size);\n      }\n\n      /* work vectors */\n      ssSetRWork(rts, (real_T *) &ATTN_DW.Setup_RWORK[0]);\n      ssSetPWork(rts, (void **) &ATTN_DW.Setup_PWORK);\n\n      {\n        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)\n          &ATTN_M->NonInlinedSFcns.Sfcn0.dWork;\n        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)\n          &ATTN_M->NonInlinedSFcns.Sfcn0.dWorkAux;\n        ssSetSFcnDWork(rts, dWorkRecord);\n        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);\n        ssSetNumDWorkAsInt(rts, 2);\n\n        /* RWORK */\n        ssSetDWorkWidthAsInt(rts, 0, 2);\n        ssSetDWorkDataType(rts, 0,SS_DOUBLE);\n        ssSetDWorkComplexSignal(rts, 0, 0);\n        ssSetDWork(rts, 0, &ATTN_DW.Setup_RWORK[0]);\n\n        /* PWORK */\n        ssSetDWorkWidthAsInt(rts, 1, 1);\n        ssSetDWorkDataType(rts, 1,SS_POINTER);\n        ssSetDWorkComplexSignal(rts, 1, 0);\n        ssSetDWork(rts, 1, &ATTN_DW.Setup_PWORK);\n      }\n\n      /* registration */\n      sg_IO191_setup_s(rts);\n      sfcnInitializeSizes(rts);\n      sfcnInitializeSampleTimes(rts);\n\n      /* adjust sample time */\n      ssSetSampleTime(rts, 0, 0.001);\n      ssSetOffsetTime(rts, 0, 0.0);\n      sfcnTsMap[0] = 1;\n\n      /* set compiled values of dynamic vector attributes */\n      ssSetNumNonsampledZCsAsInt(rts, 0);\n\n      /* Update connectivity flags for each port */\n      /* Update the BufferDstPort flags for each input port */\n    }\n\n    /* Level2 S-Function Block: ATTN/<Root>/Analog input  (sg_IO191_ad_s) */\n    {\n      SimStruct *rts = ATTN_M->childSfunctions[1];\n\n      /* timing info */\n      time_T *sfcnPeriod = ATTN_M->NonInlinedSFcns.Sfcn1.sfcnPeriod;\n      time_T *sfcnOffset = ATTN_M->NonInlinedSFcns.Sfcn1.sfcnOffset;\n      int_T *sfcnTsMap = ATTN_M->NonInlinedSFcns.Sfcn1.sfcnTsMap;\n      (void) std::memset(static_cast<void*>(sfcnPeriod), 0,\n                         sizeof(time_T)*1);\n      (void) std::memset(static_cast<void*>(sfcnOffset), 0,\n                         sizeof(time_T)*1);\n      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);\n      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);\n      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);\n\n      {\n        ssSetBlkInfo2Ptr(rts, &ATTN_M->NonInlinedSFcns.blkInfo2[1]);\n      }\n\n      _ssSetBlkInfo2PortInfo2Ptr(rts,\n        &ATTN_M->NonInlinedSFcns.inputOutputPortInfo2[1]);\n\n      /* Set up the mdlInfo pointer */\n      ssSetRTWSfcnInfo(rts, ATTN_M->sfcnInfo);\n\n      /* Allocate memory of model methods 2 */\n      {\n        ssSetModelMethods2(rts, &ATTN_M->NonInlinedSFcns.methods2[1]);\n      }\n\n      /* Allocate memory of model methods 3 */\n      {\n        ssSetModelMethods3(rts, &ATTN_M->NonInlinedSFcns.methods3[1]);\n      }\n\n      /* Allocate memory of model methods 4 */\n      {\n        ssSetModelMethods4(rts, &ATTN_M->NonInlinedSFcns.methods4[1]);\n      }\n\n      /* Allocate memory for states auxilliary information */\n      {\n        ssSetStatesInfo2(rts, &ATTN_M->NonInlinedSFcns.statesInfo2[1]);\n        ssSetPeriodicStatesInfo(rts, &ATTN_M->\n          NonInlinedSFcns.periodicStatesInfo[1]);\n      }\n\n      /* outputs */\n      {\n        ssSetPortInfoForOutputs(rts,\n          &ATTN_M->NonInlinedSFcns.Sfcn1.outputPortInfo[0]);\n        ssSetPortInfoForOutputs(rts,\n          &ATTN_M->NonInlinedSFcns.Sfcn1.outputPortInfo[0]);\n        _ssSetNumOutputPorts(rts, 2);\n        _ssSetPortInfo2ForOutputUnits(rts,\n          &ATTN_M->NonInlinedSFcns.Sfcn1.outputPortUnits[0]);\n        ssSetOutputPortUnit(rts, 0, 0);\n        ssSetOutputPortUnit(rts, 1, 0);\n        _ssSetPortInfo2ForOutputCoSimAttribute(rts,\n          &ATTN_M->NonInlinedSFcns.Sfcn1.outputPortCoSimAttribute[0]);\n        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);\n        ssSetOutputPortIsContinuousQuantity(rts, 1, 0);\n\n        /* port 0 */\n        {\n          _ssSetOutputPortNumDimensions(rts, 0, 1);\n          ssSetOutputPortWidthAsInt(rts, 0, 1);\n          ssSetOutputPortSignal(rts, 0, ((real_T *) &ATTN_B.Analoginput_o1));\n        }\n\n        /* port 1 */\n        {\n          _ssSetOutputPortNumDimensions(rts, 1, 1);\n          ssSetOutputPortWidthAsInt(rts, 1, 1);\n          ssSetOutputPortSignal(rts, 1, ((real_T *) &ATTN_B.lickometer_piezo));\n        }\n      }\n\n      /* path info */\n      ssSetModelName(rts, \"Analog input \");\n      ssSetPath(rts, \"ATTN/Analog input \");\n      ssSetRTModel(rts,ATTN_M);\n      ssSetParentSS(rts, (NULL));\n      ssSetRootSS(rts, rts);\n      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);\n\n      /* parameters */\n      {\n        mxArray **sfcnParams = (mxArray **)\n          &ATTN_M->NonInlinedSFcns.Sfcn1.params;\n        ssSetSFcnParamsCount(rts, 9);\n        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);\n        ssSetSFcnParam(rts, 0, (mxArray*)ATTN_cal->Analoginput_P1_Size);\n        ssSetSFcnParam(rts, 1, (mxArray*)ATTN_cal->Analoginput_P2_Size);\n        ssSetSFcnParam(rts, 2, (mxArray*)ATTN_cal->Analoginput_P3_Size);\n        ssSetSFcnParam(rts, 3, (mxArray*)ATTN_cal->Analoginput_P4_Size);\n        ssSetSFcnParam(rts, 4, (mxArray*)ATTN_cal->Analoginput_P5_Size);\n        ssSetSFcnParam(rts, 5, (mxArray*)ATTN_cal->Analoginput_P6_Size);\n        ssSetSFcnParam(rts, 6, (mxArray*)ATTN_cal->Analoginput_P7_Size);\n        ssSetSFcnParam(rts, 7, (mxArray*)ATTN_cal->Analoginput_P8_Size);\n        ssSetSFcnParam(rts, 8, (mxArray*)ATTN_cal->Analoginput_P9_Size);\n      }\n\n      /* work vectors */\n      ssSetIWork(rts, (int_T *) &ATTN_DW.Analoginput_IWORK[0]);\n      ssSetPWork(rts, (void **) &ATTN_DW.Analoginput_PWORK);\n\n      {\n        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)\n          &ATTN_M->NonInlinedSFcns.Sfcn1.dWork;\n        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)\n          &ATTN_M->NonInlinedSFcns.Sfcn1.dWorkAux;\n        ssSetSFcnDWork(rts, dWorkRecord);\n        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);\n        ssSetNumDWorkAsInt(rts, 2);\n\n        /* IWORK */\n        ssSetDWorkWidthAsInt(rts, 0, 2);\n        ssSetDWorkDataType(rts, 0,SS_INTEGER);\n        ssSetDWorkComplexSignal(rts, 0, 0);\n        ssSetDWork(rts, 0, &ATTN_DW.Analoginput_IWORK[0]);\n\n        /* PWORK */\n        ssSetDWorkWidthAsInt(rts, 1, 1);\n        ssSetDWorkDataType(rts, 1,SS_POINTER);\n        ssSetDWorkComplexSignal(rts, 1, 0);\n        ssSetDWork(rts, 1, &ATTN_DW.Analoginput_PWORK);\n      }\n\n      /* registration */\n      sg_IO191_ad_s(rts);\n      sfcnInitializeSizes(rts);\n      sfcnInitializeSampleTimes(rts);\n\n      /* adjust sample time */\n      ssSetSampleTime(rts, 0, 0.001);\n      ssSetOffsetTime(rts, 0, 0.0);\n      sfcnTsMap[0] = 1;\n\n      /* set compiled values of dynamic vector attributes */\n      ssSetNumNonsampledZCsAsInt(rts, 0);\n\n      /* Update connectivity flags for each port */\n      _ssSetOutputPortConnected(rts, 0, 0);\n      _ssSetOutputPortConnected(rts, 1, 1);\n      _ssSetOutputPortBeingMerged(rts, 0, 0);\n      _ssSetOutputPortBeingMerged(rts, 1, 0);\n\n      /* Update the BufferDstPort flags for each input port */\n    }\n\n    /* Level2 S-Function Block: ATTN/<Root>/Analog output  (sg_IO191_da_s) */\n    {\n      SimStruct *rts = ATTN_M->childSfunctions[2];\n\n      /* timing info */\n      time_T *sfcnPeriod = ATTN_M->NonInlinedSFcns.Sfcn2.sfcnPeriod;\n      time_T *sfcnOffset = ATTN_M->NonInlinedSFcns.Sfcn2.sfcnOffset;\n      int_T *sfcnTsMap = ATTN_M->NonInlinedSFcns.Sfcn2.sfcnTsMap;\n      (void) std::memset(static_cast<void*>(sfcnPeriod), 0,\n                         sizeof(time_T)*1);\n      (void) std::memset(static_cast<void*>(sfcnOffset), 0,\n                         sizeof(time_T)*1);\n      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);\n      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);\n      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);\n\n      {\n        ssSetBlkInfo2Ptr(rts, &ATTN_M->NonInlinedSFcns.blkInfo2[2]);\n      }\n\n      _ssSetBlkInfo2PortInfo2Ptr(rts,\n        &ATTN_M->NonInlinedSFcns.inputOutputPortInfo2[2]);\n\n      /* Set up the mdlInfo pointer */\n      ssSetRTWSfcnInfo(rts, ATTN_M->sfcnInfo);\n\n      /* Allocate memory of model methods 2 */\n      {\n        ssSetModelMethods2(rts, &ATTN_M->NonInlinedSFcns.methods2[2]);\n      }\n\n      /* Allocate memory of model methods 3 */\n      {\n        ssSetModelMethods3(rts, &ATTN_M->NonInlinedSFcns.methods3[2]);\n      }\n\n      /* Allocate memory of model methods 4 */\n      {\n        ssSetModelMethods4(rts, &ATTN_M->NonInlinedSFcns.methods4[2]);\n      }\n\n      /* Allocate memory for states auxilliary information */\n      {\n        ssSetStatesInfo2(rts, &ATTN_M->NonInlinedSFcns.statesInfo2[2]);\n        ssSetPeriodicStatesInfo(rts, &ATTN_M->\n          NonInlinedSFcns.periodicStatesInfo[2]);\n      }\n\n      /* inputs */\n      {\n        _ssSetNumInputPorts(rts, 2);\n        ssSetPortInfoForInputs(rts, &ATTN_M->\n          NonInlinedSFcns.Sfcn2.inputPortInfo[0]);\n        ssSetPortInfoForInputs(rts, &ATTN_M->\n          NonInlinedSFcns.Sfcn2.inputPortInfo[0]);\n        _ssSetPortInfo2ForInputUnits(rts,\n          &ATTN_M->NonInlinedSFcns.Sfcn2.inputPortUnits[0]);\n        ssSetInputPortUnit(rts, 0, 0);\n        ssSetInputPortUnit(rts, 1, 0);\n        _ssSetPortInfo2ForInputCoSimAttribute(rts,\n          &ATTN_M->NonInlinedSFcns.Sfcn2.inputPortCoSimAttribute[0]);\n        ssSetInputPortIsContinuousQuantity(rts, 0, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 1, 0);\n\n        /* port 0 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 0, 1);\n          ssSetInputPortSignal(rts, 0, &ATTN_B.sf_MATLABFunction1_d.y);\n          _ssSetInputPortNumDimensions(rts, 0, 1);\n          ssSetInputPortWidthAsInt(rts, 0, 1);\n        }\n\n        /* port 1 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 1, 1);\n          ssSetInputPortSignal(rts, 1, &ATTN_B.sf_MATLABFunction2.y);\n          _ssSetInputPortNumDimensions(rts, 1, 1);\n          ssSetInputPortWidthAsInt(rts, 1, 1);\n        }\n      }\n\n      /* path info */\n      ssSetModelName(rts, \"Analog output \");\n      ssSetPath(rts, \"ATTN/Analog output \");\n      ssSetRTModel(rts,ATTN_M);\n      ssSetParentSS(rts, (NULL));\n      ssSetRootSS(rts, rts);\n      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);\n\n      /* parameters */\n      {\n        mxArray **sfcnParams = (mxArray **)\n          &ATTN_M->NonInlinedSFcns.Sfcn2.params;\n        ssSetSFcnParamsCount(rts, 7);\n        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);\n        ssSetSFcnParam(rts, 0, (mxArray*)ATTN_cal->Analogoutput_P1_Size);\n        ssSetSFcnParam(rts, 1, (mxArray*)ATTN_cal->Analogoutput_P2_Size);\n        ssSetSFcnParam(rts, 2, (mxArray*)ATTN_cal->Analogoutput_P3_Size);\n        ssSetSFcnParam(rts, 3, (mxArray*)ATTN_cal->Analogoutput_P4_Size);\n        ssSetSFcnParam(rts, 4, (mxArray*)ATTN_cal->Analogoutput_P5_Size);\n        ssSetSFcnParam(rts, 5, (mxArray*)ATTN_cal->Analogoutput_P6_Size);\n        ssSetSFcnParam(rts, 6, (mxArray*)ATTN_cal->Analogoutput_P7_Size);\n      }\n\n      /* work vectors */\n      ssSetPWork(rts, (void **) &ATTN_DW.Analogoutput_PWORK);\n\n      {\n        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)\n          &ATTN_M->NonInlinedSFcns.Sfcn2.dWork;\n        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)\n          &ATTN_M->NonInlinedSFcns.Sfcn2.dWorkAux;\n        ssSetSFcnDWork(rts, dWorkRecord);\n        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);\n        ssSetNumDWorkAsInt(rts, 1);\n\n        /* PWORK */\n        ssSetDWorkWidthAsInt(rts, 0, 1);\n        ssSetDWorkDataType(rts, 0,SS_POINTER);\n        ssSetDWorkComplexSignal(rts, 0, 0);\n        ssSetDWork(rts, 0, &ATTN_DW.Analogoutput_PWORK);\n      }\n\n      /* registration */\n      sg_IO191_da_s(rts);\n      sfcnInitializeSizes(rts);\n      sfcnInitializeSampleTimes(rts);\n\n      /* adjust sample time */\n      ssSetSampleTime(rts, 0, 0.001);\n      ssSetOffsetTime(rts, 0, 0.0);\n      sfcnTsMap[0] = 1;\n\n      /* set compiled values of dynamic vector attributes */\n      ssSetNumNonsampledZCsAsInt(rts, 0);\n\n      /* Update connectivity flags for each port */\n      _ssSetInputPortConnected(rts, 0, 1);\n      _ssSetInputPortConnected(rts, 1, 1);\n\n      /* Update the BufferDstPort flags for each input port */\n      ssSetInputPortBufferDstPort(rts, 0, -1);\n      ssSetInputPortBufferDstPort(rts, 1, -1);\n    }\n\n    /* Level2 S-Function Block: ATTN/<Root>/Digital output  (sg_IO191_do_s) */\n    {\n      SimStruct *rts = ATTN_M->childSfunctions[3];\n\n      /* timing info */\n      time_T *sfcnPeriod = ATTN_M->NonInlinedSFcns.Sfcn3.sfcnPeriod;\n      time_T *sfcnOffset = ATTN_M->NonInlinedSFcns.Sfcn3.sfcnOffset;\n      int_T *sfcnTsMap = ATTN_M->NonInlinedSFcns.Sfcn3.sfcnTsMap;\n      (void) std::memset(static_cast<void*>(sfcnPeriod), 0,\n                         sizeof(time_T)*1);\n      (void) std::memset(static_cast<void*>(sfcnOffset), 0,\n                         sizeof(time_T)*1);\n      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);\n      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);\n      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);\n\n      {\n        ssSetBlkInfo2Ptr(rts, &ATTN_M->NonInlinedSFcns.blkInfo2[3]);\n      }\n\n      _ssSetBlkInfo2PortInfo2Ptr(rts,\n        &ATTN_M->NonInlinedSFcns.inputOutputPortInfo2[3]);\n\n      /* Set up the mdlInfo pointer */\n      ssSetRTWSfcnInfo(rts, ATTN_M->sfcnInfo);\n\n      /* Allocate memory of model methods 2 */\n      {\n        ssSetModelMethods2(rts, &ATTN_M->NonInlinedSFcns.methods2[3]);\n      }\n\n      /* Allocate memory of model methods 3 */\n      {\n        ssSetModelMethods3(rts, &ATTN_M->NonInlinedSFcns.methods3[3]);\n      }\n\n      /* Allocate memory of model methods 4 */\n      {\n        ssSetModelMethods4(rts, &ATTN_M->NonInlinedSFcns.methods4[3]);\n      }\n\n      /* Allocate memory for states auxilliary information */\n      {\n        ssSetStatesInfo2(rts, &ATTN_M->NonInlinedSFcns.statesInfo2[3]);\n        ssSetPeriodicStatesInfo(rts, &ATTN_M->\n          NonInlinedSFcns.periodicStatesInfo[3]);\n      }\n\n      /* inputs */\n      {\n        _ssSetNumInputPorts(rts, 15);\n        ssSetPortInfoForInputs(rts, &ATTN_M->\n          NonInlinedSFcns.Sfcn3.inputPortInfo[0]);\n        ssSetPortInfoForInputs(rts, &ATTN_M->\n          NonInlinedSFcns.Sfcn3.inputPortInfo[0]);\n        _ssSetPortInfo2ForInputUnits(rts,\n          &ATTN_M->NonInlinedSFcns.Sfcn3.inputPortUnits[0]);\n        ssSetInputPortUnit(rts, 0, 0);\n        ssSetInputPortUnit(rts, 1, 0);\n        ssSetInputPortUnit(rts, 2, 0);\n        ssSetInputPortUnit(rts, 3, 0);\n        ssSetInputPortUnit(rts, 4, 0);\n        ssSetInputPortUnit(rts, 5, 0);\n        ssSetInputPortUnit(rts, 6, 0);\n        ssSetInputPortUnit(rts, 7, 0);\n        ssSetInputPortUnit(rts, 8, 0);\n        ssSetInputPortUnit(rts, 9, 0);\n        ssSetInputPortUnit(rts, 10, 0);\n        ssSetInputPortUnit(rts, 11, 0);\n        ssSetInputPortUnit(rts, 12, 0);\n        ssSetInputPortUnit(rts, 13, 0);\n        ssSetInputPortUnit(rts, 14, 0);\n        _ssSetPortInfo2ForInputCoSimAttribute(rts,\n          &ATTN_M->NonInlinedSFcns.Sfcn3.inputPortCoSimAttribute[0]);\n        ssSetInputPortIsContinuousQuantity(rts, 0, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 1, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 2, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 3, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 4, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 5, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 6, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 7, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 8, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 9, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 10, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 11, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 12, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 13, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 14, 0);\n\n        /* port 0 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 0, 1);\n          ssSetInputPortSignal(rts, 0, &ATTN_B.whiskCam_trig);\n          _ssSetInputPortNumDimensions(rts, 0, 1);\n          ssSetInputPortWidthAsInt(rts, 0, 1);\n        }\n\n        /* port 1 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 1, 1);\n          ssSetInputPortSignal(rts, 1, &ATTN_B.npxls_trig);\n          _ssSetInputPortNumDimensions(rts, 1, 1);\n          ssSetInputPortWidthAsInt(rts, 1, 1);\n        }\n\n        /* port 2 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 2, 1);\n          ssSetInputPortSignal(rts, 2, &ATTN_B.pupilCam_trig);\n          _ssSetInputPortNumDimensions(rts, 2, 1);\n          ssSetInputPortWidthAsInt(rts, 2, 1);\n        }\n\n        /* port 3 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 3, 1);\n          ssSetInputPortSignal(rts, 3, &ATTN_B.npxlsAcq_out);\n          _ssSetInputPortNumDimensions(rts, 3, 1);\n          ssSetInputPortWidthAsInt(rts, 3, 1);\n        }\n\n        /* port 4 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 4, 1);\n          ssSetInputPortSignal(rts, 4, &ATTN_B.y);\n          _ssSetInputPortNumDimensions(rts, 4, 1);\n          ssSetInputPortWidthAsInt(rts, 4, 1);\n        }\n\n        /* port 5 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 5, 1);\n          ssSetInputPortSignal(rts, 5, (const_cast<real_T*>(&ATTN_RGND)));\n          _ssSetInputPortNumDimensions(rts, 5, 1);\n          ssSetInputPortWidthAsInt(rts, 5, 1);\n        }\n\n        /* port 6 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 6, 1);\n          ssSetInputPortSignal(rts, 6, (const_cast<real_T*>(&ATTN_RGND)));\n          _ssSetInputPortNumDimensions(rts, 6, 1);\n          ssSetInputPortWidthAsInt(rts, 6, 1);\n        }\n\n        /* port 7 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 7, 1);\n          ssSetInputPortSignal(rts, 7, (const_cast<real_T*>(&ATTN_RGND)));\n          _ssSetInputPortNumDimensions(rts, 7, 1);\n          ssSetInputPortWidthAsInt(rts, 7, 1);\n        }\n\n        /* port 8 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 8, 1);\n          ssSetInputPortSignal(rts, 8, (const_cast<real_T*>(&ATTN_RGND)));\n          _ssSetInputPortNumDimensions(rts, 8, 1);\n          ssSetInputPortWidthAsInt(rts, 8, 1);\n        }\n\n        /* port 9 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 9, 1);\n          ssSetInputPortSignal(rts, 9, (const_cast<real_T*>(&ATTN_RGND)));\n          _ssSetInputPortNumDimensions(rts, 9, 1);\n          ssSetInputPortWidthAsInt(rts, 9, 1);\n        }\n\n        /* port 10 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 10, 1);\n          ssSetInputPortSignal(rts, 10, (const_cast<real_T*>(&ATTN_RGND)));\n          _ssSetInputPortNumDimensions(rts, 10, 1);\n          ssSetInputPortWidthAsInt(rts, 10, 1);\n        }\n\n        /* port 11 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 11, 1);\n          ssSetInputPortSignal(rts, 11, (const_cast<real_T*>(&ATTN_RGND)));\n          _ssSetInputPortNumDimensions(rts, 11, 1);\n          ssSetInputPortWidthAsInt(rts, 11, 1);\n        }\n\n        /* port 12 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 12, 1);\n          ssSetInputPortSignal(rts, 12, (const_cast<real_T*>(&ATTN_RGND)));\n          _ssSetInputPortNumDimensions(rts, 12, 1);\n          ssSetInputPortWidthAsInt(rts, 12, 1);\n        }\n\n        /* port 13 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 13, 1);\n          ssSetInputPortSignal(rts, 13, (const_cast<real_T*>(&ATTN_RGND)));\n          _ssSetInputPortNumDimensions(rts, 13, 1);\n          ssSetInputPortWidthAsInt(rts, 13, 1);\n        }\n\n        /* port 14 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 14, 1);\n          ssSetInputPortSignal(rts, 14, &ATTN_B.tonePulse);\n          _ssSetInputPortNumDimensions(rts, 14, 1);\n          ssSetInputPortWidthAsInt(rts, 14, 1);\n        }\n      }\n\n      /* path info */\n      ssSetModelName(rts, \"Digital output \");\n      ssSetPath(rts, \"ATTN/Digital output \");\n      ssSetRTModel(rts,ATTN_M);\n      ssSetParentSS(rts, (NULL));\n      ssSetRootSS(rts, rts);\n      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);\n\n      /* parameters */\n      {\n        mxArray **sfcnParams = (mxArray **)\n          &ATTN_M->NonInlinedSFcns.Sfcn3.params;\n        ssSetSFcnParamsCount(rts, 6);\n        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);\n        ssSetSFcnParam(rts, 0, (mxArray*)ATTN_cal->Digitaloutput_P1_Size);\n        ssSetSFcnParam(rts, 1, (mxArray*)ATTN_cal->Digitaloutput_P2_Size);\n        ssSetSFcnParam(rts, 2, (mxArray*)ATTN_cal->Digitaloutput_P3_Size);\n        ssSetSFcnParam(rts, 3, (mxArray*)ATTN_cal->Digitaloutput_P4_Size);\n        ssSetSFcnParam(rts, 4, (mxArray*)ATTN_cal->Digitaloutput_P5_Size);\n        ssSetSFcnParam(rts, 5, (mxArray*)ATTN_cal->Digitaloutput_P6_Size);\n      }\n\n      /* work vectors */\n      ssSetPWork(rts, (void **) &ATTN_DW.Digitaloutput_PWORK);\n\n      {\n        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)\n          &ATTN_M->NonInlinedSFcns.Sfcn3.dWork;\n        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)\n          &ATTN_M->NonInlinedSFcns.Sfcn3.dWorkAux;\n        ssSetSFcnDWork(rts, dWorkRecord);\n        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);\n        ssSetNumDWorkAsInt(rts, 1);\n\n        /* PWORK */\n        ssSetDWorkWidthAsInt(rts, 0, 1);\n        ssSetDWorkDataType(rts, 0,SS_POINTER);\n        ssSetDWorkComplexSignal(rts, 0, 0);\n        ssSetDWork(rts, 0, &ATTN_DW.Digitaloutput_PWORK);\n      }\n\n      /* registration */\n      sg_IO191_do_s(rts);\n      sfcnInitializeSizes(rts);\n      sfcnInitializeSampleTimes(rts);\n\n      /* adjust sample time */\n      ssSetSampleTime(rts, 0, 0.001);\n      ssSetOffsetTime(rts, 0, 0.0);\n      sfcnTsMap[0] = 1;\n\n      /* set compiled values of dynamic vector attributes */\n      ssSetNumNonsampledZCsAsInt(rts, 0);\n\n      /* Update connectivity flags for each port */\n      _ssSetInputPortConnected(rts, 0, 1);\n      _ssSetInputPortConnected(rts, 1, 1);\n      _ssSetInputPortConnected(rts, 2, 1);\n      _ssSetInputPortConnected(rts, 3, 1);\n      _ssSetInputPortConnected(rts, 4, 1);\n      _ssSetInputPortConnected(rts, 5, 0);\n      _ssSetInputPortConnected(rts, 6, 0);\n      _ssSetInputPortConnected(rts, 7, 0);\n      _ssSetInputPortConnected(rts, 8, 0);\n      _ssSetInputPortConnected(rts, 9, 0);\n      _ssSetInputPortConnected(rts, 10, 0);\n      _ssSetInputPortConnected(rts, 11, 0);\n      _ssSetInputPortConnected(rts, 12, 0);\n      _ssSetInputPortConnected(rts, 13, 0);\n      _ssSetInputPortConnected(rts, 14, 1);\n\n      /* Update the BufferDstPort flags for each input port */\n      ssSetInputPortBufferDstPort(rts, 0, -1);\n      ssSetInputPortBufferDstPort(rts, 1, -1);\n      ssSetInputPortBufferDstPort(rts, 2, -1);\n      ssSetInputPortBufferDstPort(rts, 3, -1);\n      ssSetInputPortBufferDstPort(rts, 4, -1);\n      ssSetInputPortBufferDstPort(rts, 5, -1);\n      ssSetInputPortBufferDstPort(rts, 6, -1);\n      ssSetInputPortBufferDstPort(rts, 7, -1);\n      ssSetInputPortBufferDstPort(rts, 8, -1);\n      ssSetInputPortBufferDstPort(rts, 9, -1);\n      ssSetInputPortBufferDstPort(rts, 10, -1);\n      ssSetInputPortBufferDstPort(rts, 11, -1);\n      ssSetInputPortBufferDstPort(rts, 12, -1);\n      ssSetInputPortBufferDstPort(rts, 13, -1);\n      ssSetInputPortBufferDstPort(rts, 14, -1);\n    }\n\n    /* Level2 S-Function Block: ATTN/<Root>/Digital input  (sg_IO191_di_s) */\n    {\n      SimStruct *rts = ATTN_M->childSfunctions[4];\n\n      /* timing info */\n      time_T *sfcnPeriod = ATTN_M->NonInlinedSFcns.Sfcn4.sfcnPeriod;\n      time_T *sfcnOffset = ATTN_M->NonInlinedSFcns.Sfcn4.sfcnOffset;\n      int_T *sfcnTsMap = ATTN_M->NonInlinedSFcns.Sfcn4.sfcnTsMap;\n      (void) std::memset(static_cast<void*>(sfcnPeriod), 0,\n                         sizeof(time_T)*1);\n      (void) std::memset(static_cast<void*>(sfcnOffset), 0,\n                         sizeof(time_T)*1);\n      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);\n      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);\n      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);\n\n      {\n        ssSetBlkInfo2Ptr(rts, &ATTN_M->NonInlinedSFcns.blkInfo2[4]);\n      }\n\n      _ssSetBlkInfo2PortInfo2Ptr(rts,\n        &ATTN_M->NonInlinedSFcns.inputOutputPortInfo2[4]);\n\n      /* Set up the mdlInfo pointer */\n      ssSetRTWSfcnInfo(rts, ATTN_M->sfcnInfo);\n\n      /* Allocate memory of model methods 2 */\n      {\n        ssSetModelMethods2(rts, &ATTN_M->NonInlinedSFcns.methods2[4]);\n      }\n\n      /* Allocate memory of model methods 3 */\n      {\n        ssSetModelMethods3(rts, &ATTN_M->NonInlinedSFcns.methods3[4]);\n      }\n\n      /* Allocate memory of model methods 4 */\n      {\n        ssSetModelMethods4(rts, &ATTN_M->NonInlinedSFcns.methods4[4]);\n      }\n\n      /* Allocate memory for states auxilliary information */\n      {\n        ssSetStatesInfo2(rts, &ATTN_M->NonInlinedSFcns.statesInfo2[4]);\n        ssSetPeriodicStatesInfo(rts, &ATTN_M->\n          NonInlinedSFcns.periodicStatesInfo[4]);\n      }\n\n      /* outputs */\n      {\n        ssSetPortInfoForOutputs(rts,\n          &ATTN_M->NonInlinedSFcns.Sfcn4.outputPortInfo[0]);\n        ssSetPortInfoForOutputs(rts,\n          &ATTN_M->NonInlinedSFcns.Sfcn4.outputPortInfo[0]);\n        _ssSetNumOutputPorts(rts, 1);\n        _ssSetPortInfo2ForOutputUnits(rts,\n          &ATTN_M->NonInlinedSFcns.Sfcn4.outputPortUnits[0]);\n        ssSetOutputPortUnit(rts, 0, 0);\n        _ssSetPortInfo2ForOutputCoSimAttribute(rts,\n          &ATTN_M->NonInlinedSFcns.Sfcn4.outputPortCoSimAttribute[0]);\n        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);\n\n        /* port 0 */\n        {\n          _ssSetOutputPortNumDimensions(rts, 0, 1);\n          ssSetOutputPortWidthAsInt(rts, 0, 1);\n          ssSetOutputPortSignal(rts, 0, ((real_T *) &ATTN_B.PulseGen1Hz));\n        }\n      }\n\n      /* path info */\n      ssSetModelName(rts, \"Digital input \");\n      ssSetPath(rts, \"ATTN/Digital input \");\n      ssSetRTModel(rts,ATTN_M);\n      ssSetParentSS(rts, (NULL));\n      ssSetRootSS(rts, rts);\n      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);\n\n      /* parameters */\n      {\n        mxArray **sfcnParams = (mxArray **)\n          &ATTN_M->NonInlinedSFcns.Sfcn4.params;\n        ssSetSFcnParamsCount(rts, 4);\n        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);\n        ssSetSFcnParam(rts, 0, (mxArray*)ATTN_cal->Digitalinput_P1_Size);\n        ssSetSFcnParam(rts, 1, (mxArray*)ATTN_cal->Digitalinput_P2_Size);\n        ssSetSFcnParam(rts, 2, (mxArray*)ATTN_cal->Digitalinput_P3_Size);\n        ssSetSFcnParam(rts, 3, (mxArray*)ATTN_cal->Digitalinput_P4_Size);\n      }\n\n      /* work vectors */\n      ssSetPWork(rts, (void **) &ATTN_DW.Digitalinput_PWORK);\n\n      {\n        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)\n          &ATTN_M->NonInlinedSFcns.Sfcn4.dWork;\n        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)\n          &ATTN_M->NonInlinedSFcns.Sfcn4.dWorkAux;\n        ssSetSFcnDWork(rts, dWorkRecord);\n        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);\n        ssSetNumDWorkAsInt(rts, 1);\n\n        /* PWORK */\n        ssSetDWorkWidthAsInt(rts, 0, 1);\n        ssSetDWorkDataType(rts, 0,SS_POINTER);\n        ssSetDWorkComplexSignal(rts, 0, 0);\n        ssSetDWork(rts, 0, &ATTN_DW.Digitalinput_PWORK);\n      }\n\n      /* registration */\n      sg_IO191_di_s(rts);\n      sfcnInitializeSizes(rts);\n      sfcnInitializeSampleTimes(rts);\n\n      /* adjust sample time */\n      ssSetSampleTime(rts, 0, 0.001);\n      ssSetOffsetTime(rts, 0, 0.0);\n      sfcnTsMap[0] = 1;\n\n      /* set compiled values of dynamic vector attributes */\n      ssSetNumNonsampledZCsAsInt(rts, 0);\n\n      /* Update connectivity flags for each port */\n      _ssSetOutputPortConnected(rts, 0, 1);\n      _ssSetOutputPortBeingMerged(rts, 0, 0);\n\n      /* Update the BufferDstPort flags for each input port */\n    }\n  }\n\n  /* Start for S-Function (sg_IO191_setup_s): '<Root>/Setup ' */\n  /* Level2 S-Function Block: '<Root>/Setup ' (sg_IO191_setup_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[0];\n    sfcnStart(rts);\n    if (ssGetErrorStatus(rts) != (NULL))\n      return;\n  }\n\n  /* Start for S-Function (sg_IO191_ad_s): '<Root>/Analog input ' */\n  /* Level2 S-Function Block: '<Root>/Analog input ' (sg_IO191_ad_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[1];\n    sfcnStart(rts);\n    if (ssGetErrorStatus(rts) != (NULL))\n      return;\n  }\n\n  /* Start for S-Function (sg_IO191_da_s): '<Root>/Analog output ' */\n  /* Level2 S-Function Block: '<Root>/Analog output ' (sg_IO191_da_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[2];\n    sfcnStart(rts);\n    if (ssGetErrorStatus(rts) != (NULL))\n      return;\n  }\n\n  /* Start for S-Function (sg_IO191_do_s): '<Root>/Digital output ' */\n  /* Level2 S-Function Block: '<Root>/Digital output ' (sg_IO191_do_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[3];\n    sfcnStart(rts);\n    if (ssGetErrorStatus(rts) != (NULL))\n      return;\n  }\n\n  /* Start for S-Function (sg_IO191_di_s): '<Root>/Digital input ' */\n  /* Level2 S-Function Block: '<Root>/Digital input ' (sg_IO191_di_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[4];\n    sfcnStart(rts);\n    if (ssGetErrorStatus(rts) != (NULL))\n      return;\n  }\n\n  {\n    int32_T i;\n    static const uint32_T tmp[625] = { 5489U, 1301868182U, 2938499221U,\n      2950281878U, 1875628136U, 751856242U, 944701696U, 2243192071U, 694061057U,\n      219885934U, 2066767472U, 3182869408U, 485472502U, 2336857883U, 1071588843U,\n      3418470598U, 951210697U, 3693558366U, 2923482051U, 1793174584U,\n      2982310801U, 1586906132U, 1951078751U, 1808158765U, 1733897588U,\n      431328322U, 4202539044U, 530658942U, 1714810322U, 3025256284U, 3342585396U,\n      1937033938U, 2640572511U, 1654299090U, 3692403553U, 4233871309U,\n      3497650794U, 862629010U, 2943236032U, 2426458545U, 1603307207U,\n      1133453895U, 3099196360U, 2208657629U, 2747653927U, 931059398U, 761573964U,\n      3157853227U, 785880413U, 730313442U, 124945756U, 2937117055U, 3295982469U,\n      1724353043U, 3021675344U, 3884886417U, 4010150098U, 4056961966U,\n      699635835U, 2681338818U, 1339167484U, 720757518U, 2800161476U, 2376097373U,\n      1532957371U, 3902664099U, 1238982754U, 3725394514U, 3449176889U,\n      3570962471U, 4287636090U, 4087307012U, 3603343627U, 202242161U,\n      2995682783U, 1620962684U, 3704723357U, 371613603U, 2814834333U,\n      2111005706U, 624778151U, 2094172212U, 4284947003U, 1211977835U, 991917094U,\n      1570449747U, 2962370480U, 1259410321U, 170182696U, 146300961U, 2836829791U,\n      619452428U, 2723670296U, 1881399711U, 1161269684U, 1675188680U,\n      4132175277U, 780088327U, 3409462821U, 1036518241U, 1834958505U,\n      3048448173U, 161811569U, 618488316U, 44795092U, 3918322701U, 1924681712U,\n      3239478144U, 383254043U, 4042306580U, 2146983041U, 3992780527U,\n      3518029708U, 3545545436U, 3901231469U, 1896136409U, 2028528556U,\n      2339662006U, 501326714U, 2060962201U, 2502746480U, 561575027U, 581893337U,\n      3393774360U, 1778912547U, 3626131687U, 2175155826U, 319853231U, 986875531U,\n      819755096U, 2915734330U, 2688355739U, 3482074849U, 2736559U, 2296975761U,\n      1029741190U, 2876812646U, 690154749U, 579200347U, 4027461746U, 1285330465U,\n      2701024045U, 4117700889U, 759495121U, 3332270341U, 2313004527U,\n      2277067795U, 4131855432U, 2722057515U, 1264804546U, 3848622725U,\n      2211267957U, 4100593547U, 959123777U, 2130745407U, 3194437393U, 486673947U,\n      1377371204U, 17472727U, 352317554U, 3955548058U, 159652094U, 1232063192U,\n      3835177280U, 49423123U, 3083993636U, 733092U, 2120519771U, 2573409834U,\n      1112952433U, 3239502554U, 761045320U, 1087580692U, 2540165110U, 641058802U,\n      1792435497U, 2261799288U, 1579184083U, 627146892U, 2165744623U,\n      2200142389U, 2167590760U, 2381418376U, 1793358889U, 3081659520U,\n      1663384067U, 2009658756U, 2689600308U, 739136266U, 2304581039U,\n      3529067263U, 591360555U, 525209271U, 3131882996U, 294230224U, 2076220115U,\n      3113580446U, 1245621585U, 1386885462U, 3203270426U, 123512128U, 12350217U,\n      354956375U, 4282398238U, 3356876605U, 3888857667U, 157639694U, 2616064085U,\n      1563068963U, 2762125883U, 4045394511U, 4180452559U, 3294769488U,\n      1684529556U, 1002945951U, 3181438866U, 22506664U, 691783457U, 2685221343U,\n      171579916U, 3878728600U, 2475806724U, 2030324028U, 3331164912U,\n      1708711359U, 1970023127U, 2859691344U, 2588476477U, 2748146879U,\n      136111222U, 2967685492U, 909517429U, 2835297809U, 3206906216U, 3186870716U,\n      341264097U, 2542035121U, 3353277068U, 548223577U, 3170936588U, 1678403446U,\n      297435620U, 2337555430U, 466603495U, 1132321815U, 1208589219U, 696392160U,\n      894244439U, 2562678859U, 470224582U, 3306867480U, 201364898U, 2075966438U,\n      1767227936U, 2929737987U, 3674877796U, 2654196643U, 3692734598U,\n      3528895099U, 2796780123U, 3048728353U, 842329300U, 191554730U, 2922459673U,\n      3489020079U, 3979110629U, 1022523848U, 2202932467U, 3583655201U,\n      3565113719U, 587085778U, 4176046313U, 3013713762U, 950944241U, 396426791U,\n      3784844662U, 3477431613U, 3594592395U, 2782043838U, 3392093507U,\n      3106564952U, 2829419931U, 1358665591U, 2206918825U, 3170783123U, 31522386U,\n      2988194168U, 1782249537U, 1105080928U, 843500134U, 1225290080U,\n      1521001832U, 3605886097U, 2802786495U, 2728923319U, 3996284304U,\n      903417639U, 1171249804U, 1020374987U, 2824535874U, 423621996U, 1988534473U,\n      2493544470U, 1008604435U, 1756003503U, 1488867287U, 1386808992U,\n      732088248U, 1780630732U, 2482101014U, 976561178U, 1543448953U, 2602866064U,\n      2021139923U, 1952599828U, 2360242564U, 2117959962U, 2753061860U,\n      2388623612U, 4138193781U, 2962920654U, 2284970429U, 766920861U,\n      3457264692U, 2879611383U, 815055854U, 2332929068U, 1254853997U,\n      3740375268U, 3799380844U, 4091048725U, 2006331129U, 1982546212U,\n      686850534U, 1907447564U, 2682801776U, 2780821066U, 998290361U, 1342433871U,\n      4195430425U, 607905174U, 3902331779U, 2454067926U, 1708133115U,\n      1170874362U, 2008609376U, 3260320415U, 2211196135U, 433538229U,\n      2728786374U, 2189520818U, 262554063U, 1182318347U, 3710237267U,\n      1221022450U, 715966018U, 2417068910U, 2591870721U, 2870691989U,\n      3418190842U, 4238214053U, 1540704231U, 1575580968U, 2095917976U,\n      4078310857U, 2313532447U, 2110690783U, 4056346629U, 4061784526U,\n      1123218514U, 551538993U, 597148360U, 4120175196U, 3581618160U, 3181170517U,\n      422862282U, 3227524138U, 1713114790U, 662317149U, 1230418732U, 928171837U,\n      1324564878U, 1928816105U, 1786535431U, 2878099422U, 3290185549U,\n      539474248U, 1657512683U, 552370646U, 1671741683U, 3655312128U, 1552739510U,\n      2605208763U, 1441755014U, 181878989U, 3124053868U, 1447103986U,\n      3183906156U, 1728556020U, 3502241336U, 3055466967U, 1013272474U,\n      818402132U, 1715099063U, 2900113506U, 397254517U, 4194863039U, 1009068739U,\n      232864647U, 2540223708U, 2608288560U, 2415367765U, 478404847U, 3455100648U,\n      3182600021U, 2115988978U, 434269567U, 4117179324U, 3461774077U, 887256537U,\n      3545801025U, 286388911U, 3451742129U, 1981164769U, 786667016U, 3310123729U,\n      3097811076U, 2224235657U, 2959658883U, 3370969234U, 2514770915U,\n      3345656436U, 2677010851U, 2206236470U, 271648054U, 2342188545U,\n      4292848611U, 3646533909U, 3754009956U, 3803931226U, 4160647125U,\n      1477814055U, 4043852216U, 1876372354U, 3133294443U, 3871104810U,\n      3177020907U, 2074304428U, 3479393793U, 759562891U, 164128153U, 1839069216U,\n      2114162633U, 3989947309U, 3611054956U, 1333547922U, 835429831U, 494987340U,\n      171987910U, 1252001001U, 370809172U, 3508925425U, 2535703112U, 1276855041U,\n      1922855120U, 835673414U, 3030664304U, 613287117U, 171219893U, 3423096126U,\n      3376881639U, 2287770315U, 1658692645U, 1262815245U, 3957234326U,\n      1168096164U, 2968737525U, 2655813712U, 2132313144U, 3976047964U,\n      326516571U, 353088456U, 3679188938U, 3205649712U, 2654036126U, 1249024881U,\n      880166166U, 691800469U, 2229503665U, 1673458056U, 4032208375U, 1851778863U,\n      2563757330U, 376742205U, 1794655231U, 340247333U, 1505873033U, 396524441U,\n      879666767U, 3335579166U, 3260764261U, 3335999539U, 506221798U, 4214658741U,\n      975887814U, 2080536343U, 3360539560U, 571586418U, 138896374U, 4234352651U,\n      2737620262U, 3928362291U, 1516365296U, 38056726U, 3599462320U, 3585007266U,\n      3850961033U, 471667319U, 1536883193U, 2310166751U, 1861637689U,\n      2530999841U, 4139843801U, 2710569485U, 827578615U, 2012334720U,\n      2907369459U, 3029312804U, 2820112398U, 1965028045U, 35518606U, 2478379033U,\n      643747771U, 1924139484U, 4123405127U, 3811735531U, 3429660832U,\n      3285177704U, 1948416081U, 1311525291U, 1183517742U, 1739192232U,\n      3979815115U, 2567840007U, 4116821529U, 213304419U, 4125718577U,\n      1473064925U, 2442436592U, 1893310111U, 4195361916U, 3747569474U,\n      828465101U, 2991227658U, 750582866U, 1205170309U, 1409813056U, 678418130U,\n      1171531016U, 3821236156U, 354504587U, 4202874632U, 3882511497U,\n      1893248677U, 1903078632U, 26340130U, 2069166240U, 3657122492U, 3725758099U,\n      831344905U, 811453383U, 3447711422U, 2434543565U, 4166886888U, 3358210805U,\n      4142984013U, 2988152326U, 3527824853U, 982082992U, 2809155763U, 190157081U,\n      3340214818U, 2365432395U, 2548636180U, 2894533366U, 3474657421U,\n      2372634704U, 2845748389U, 43024175U, 2774226648U, 1987702864U, 3186502468U,\n      453610222U, 4204736567U, 1392892630U, 2471323686U, 2470534280U,\n      3541393095U, 4269885866U, 3909911300U, 759132955U, 1482612480U, 667715263U,\n      1795580598U, 2337923983U, 3390586366U, 581426223U, 1515718634U, 476374295U,\n      705213300U, 363062054U, 2084697697U, 2407503428U, 2292957699U, 2426213835U,\n      2199989172U, 1987356470U, 4026755612U, 2147252133U, 270400031U,\n      1367820199U, 2369854699U, 2844269403U, 79981964U, 624U };\n\n    /* InitializeConditions for Memory: '<Root>/Memory8' */\n    ATTN_DW.Memory8_PreviousInput = ATTN_cal->Memory8_InitialCondition;\n\n    /* InitializeConditions for Memory: '<Root>/Memory2' */\n    ATTN_DW.Memory2_PreviousInput = ATTN_cal->Memory2_InitialCondition;\n\n    /* InitializeConditions for Memory: '<Root>/Memory1' */\n    ATTN_DW.Memory1_PreviousInput = ATTN_cal->Memory1_InitialCondition;\n\n    /* InitializeConditions for Memory: '<Root>/Memory' */\n    ATTN_DW.Memory_PreviousInput = ATTN_cal->Memory_InitialCondition;\n\n    /* InitializeConditions for DiscreteFir: '<Root>/Discrete FIR Filter1' */\n    ATTN_DW.DiscreteFIRFilter1_circBuf = 0;\n    for (i = 0; i < 1500; i++) {\n      ATTN_DW.DiscreteFIRFilter1_states[i] =\n        ATTN_cal->DiscreteFIRFilter1_InitialState;\n    }\n\n    /* End of InitializeConditions for DiscreteFir: '<Root>/Discrete FIR Filter1' */\n\n    /* InitializeConditions for Memory: '<Root>/Memory11' */\n    ATTN_DW.Memory11_PreviousInput = ATTN_cal->Memory11_InitialCondition;\n\n    /* InitializeConditions for Memory: '<Root>/Memory7' */\n    ATTN_DW.Memory7_PreviousInput = ATTN_cal->Memory7_InitialCondition;\n\n    /* InitializeConditions for Memory: '<Root>/Memory3' */\n    ATTN_DW.Memory3_PreviousInput = ATTN_cal->Memory3_InitialCondition;\n\n    /* InitializeConditions for Memory: '<Root>/Memory4' */\n    ATTN_DW.Memory4_PreviousInput = ATTN_cal->Memory4_InitialCondition;\n\n    /* InitializeConditions for Memory: '<Root>/Memory9' */\n    ATTN_DW.Memory9_PreviousInput = ATTN_cal->Memory9_InitialCondition;\n\n    /* InitializeConditions for Memory: '<Root>/Memory5' */\n    ATTN_DW.Memory5_PreviousInput = ATTN_cal->Memory5_InitialCondition;\n\n    /* InitializeConditions for Memory: '<Root>/Memory6' */\n    ATTN_DW.Memory6_PreviousInput = ATTN_cal->Memory6_InitialCondition;\n\n    /* InitializeConditions for Memory: '<Root>/Memory10' */\n    ATTN_DW.Memory10_PreviousInput = ATTN_cal->Memory10_InitialCondition;\n\n    /* InitializeConditions for DiscretePulseGenerator: '<Root>/Whisker Trig' */\n    ATTN_DW.clockTickCounter = 0;\n\n    /* InitializeConditions for DiscretePulseGenerator: '<Root>/Npxls Trig' */\n    ATTN_DW.clockTickCounter_n = 0;\n\n    /* InitializeConditions for DiscretePulseGenerator: '<Root>/Pupil Trig' */\n    ATTN_DW.clockTickCounter_c = 0;\n\n    /* SystemInitialize for MATLAB Function: '<Root>/MATLAB Function1' */\n    ATTN_DW.sfEvent_b = ATTN_CALL_EVENT_n;\n    ATTN_DW.is_active_c6_ATTN = 0U;\n\n    /* SystemInitialize for MATLAB Function: '<Root>/MATLAB Function' */\n    std::memcpy(&ATTN_DW.state_k[0], &tmp[0], 625U * sizeof(uint32_T));\n    ATTN_DW.sfEvent_e = ATTN_CALL_EVENT_n;\n    ATTN_DW.is_active_c1_ATTN = 0U;\n    ATTN_DW.method = 7U;\n    ATTN_DW.method_not_empty = true;\n    ATTN_DW.state = 1144108930U;\n    ATTN_DW.state_not_empty = true;\n    ATTN_DW.state_p[0] = 362436069U;\n    ATTN_DW.state_p[1] = 521288629U;\n    ATTN_DW.state_not_empty_k = true;\n    ATTN_DW.state_not_empty_d = true;\n\n    /* SystemInitialize for MATLAB Function: '<S4>/MATLAB Function1' */\n    ATTN_MATLABFunction2_Init(&ATTN_DW.sf_MATLABFunction1_d);\n\n    /* SystemInitialize for MATLAB Function: '<S3>/MATLAB Function2' */\n    ATTN_MATLABFunction2_Init(&ATTN_DW.sf_MATLABFunction2);\n\n    /* SystemInitialize for MATLAB Function: '<S5>/MATLAB Function1' */\n    ATTN_DW.sfEvent_a = ATTN_CALL_EVENT_n;\n    ATTN_DW.t0_not_empty_p = false;\n    ATTN_DW.is_active_c5_ATTN = 0U;\n\n    /* SystemInitialize for MATLAB Function: '<S6>/MATLAB Function1' */\n    ATTN_DW.sfEvent = ATTN_CALL_EVENT_n;\n    ATTN_DW.t0_not_empty = false;\n    ATTN_DW.is_active_c2_ATTN = 0U;\n  }\n}\n\n/* Model terminate function */\nvoid ATTN_terminate(void)\n{\n  /* Terminate for S-Function (sg_IO191_setup_s): '<Root>/Setup ' */\n  /* Level2 S-Function Block: '<Root>/Setup ' (sg_IO191_setup_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[0];\n    sfcnTerminate(rts);\n  }\n\n  /* Terminate for S-Function (sg_IO191_ad_s): '<Root>/Analog input ' */\n  /* Level2 S-Function Block: '<Root>/Analog input ' (sg_IO191_ad_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[1];\n    sfcnTerminate(rts);\n  }\n\n  /* Terminate for S-Function (sg_IO191_da_s): '<Root>/Analog output ' */\n  /* Level2 S-Function Block: '<Root>/Analog output ' (sg_IO191_da_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[2];\n    sfcnTerminate(rts);\n  }\n\n  /* Terminate for S-Function (sg_IO191_do_s): '<Root>/Digital output ' */\n  /* Level2 S-Function Block: '<Root>/Digital output ' (sg_IO191_do_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[3];\n    sfcnTerminate(rts);\n  }\n\n  /* Terminate for S-Function (sg_IO191_di_s): '<Root>/Digital input ' */\n  /* Level2 S-Function Block: '<Root>/Digital input ' (sg_IO191_di_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[4];\n    sfcnTerminate(rts);\n  }\n}\n"},{"name":"ATTN.h","type":"header","group":"model","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * ATTN.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.506\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Tue Dec 12 16:07:50 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_ATTN_h_\n#define RTW_HEADER_ATTN_h_\n#include <logsrv.h>\n#include \"rtwtypes.h\"\n#include \"simstruc.h\"\n#include \"fixedpoint.h\"\n#include \"verify/verifyIntrf.h\"\n#include \"ATTN_types.h\"\n#include <stddef.h>\n#include <cstring>\n#include \"ATTN_cal.h\"\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n/* Macros for accessing real-time model data structure */\n#ifndef rtmGetContTimeOutputInconsistentWithStateAtMajorStepFlag\n#define rtmGetContTimeOutputInconsistentWithStateAtMajorStepFlag(rtm) ((rtm)->CTOutputIncnstWithState)\n#endif\n\n#ifndef rtmSetContTimeOutputInconsistentWithStateAtMajorStepFlag\n#define rtmSetContTimeOutputInconsistentWithStateAtMajorStepFlag(rtm, val) ((rtm)->CTOutputIncnstWithState = (val))\n#endif\n\n#ifndef rtmGetDerivCacheNeedsReset\n#define rtmGetDerivCacheNeedsReset(rtm) ((rtm)->derivCacheNeedsReset)\n#endif\n\n#ifndef rtmSetDerivCacheNeedsReset\n#define rtmSetDerivCacheNeedsReset(rtm, val) ((rtm)->derivCacheNeedsReset = (val))\n#endif\n\n#ifndef rtmGetFinalTime\n#define rtmGetFinalTime(rtm)           ((rtm)->Timing.tFinal)\n#endif\n\n#ifndef rtmGetSampleHitArray\n#define rtmGetSampleHitArray(rtm)      ((rtm)->Timing.sampleHitArray)\n#endif\n\n#ifndef rtmGetStepSize\n#define rtmGetStepSize(rtm)            ((rtm)->Timing.stepSize)\n#endif\n\n#ifndef rtmGetZCCacheNeedsReset\n#define rtmGetZCCacheNeedsReset(rtm)   ((rtm)->zCCacheNeedsReset)\n#endif\n\n#ifndef rtmSetZCCacheNeedsReset\n#define rtmSetZCCacheNeedsReset(rtm, val) ((rtm)->zCCacheNeedsReset = (val))\n#endif\n\n#ifndef rtmGet_TimeOfLastOutput\n#define rtmGet_TimeOfLastOutput(rtm)   ((rtm)->Timing.timeOfLastOutput)\n#endif\n\n#ifndef rtmGetErrorStatus\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\n#endif\n\n#ifndef rtmSetErrorStatus\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\n#endif\n\n#ifndef rtmGetStopRequested\n#define rtmGetStopRequested(rtm)       ((rtm)->Timing.stopRequestedFlag)\n#endif\n\n#ifndef rtmSetStopRequested\n#define rtmSetStopRequested(rtm, val)  ((rtm)->Timing.stopRequestedFlag = (val))\n#endif\n\n#ifndef rtmGetStopRequestedPtr\n#define rtmGetStopRequestedPtr(rtm)    (&((rtm)->Timing.stopRequestedFlag))\n#endif\n\n#ifndef rtmGetT\n#define rtmGetT(rtm)                   (rtmGetTPtr((rtm))[0])\n#endif\n\n#ifndef rtmGetTFinal\n#define rtmGetTFinal(rtm)              ((rtm)->Timing.tFinal)\n#endif\n\n#ifndef rtmGetTPtr\n#define rtmGetTPtr(rtm)                ((rtm)->Timing.t)\n#endif\n\n#ifndef rtmGetTStart\n#define rtmGetTStart(rtm)              ((rtm)->Timing.tStart)\n#endif\n\n#ifndef rtmGetTimeOfLastOutput\n#define rtmGetTimeOfLastOutput(rtm)    ((rtm)->Timing.timeOfLastOutput)\n#endif\n\n/* Block signals for system '<S3>/MATLAB Function2' */\nstruct B_MATLABFunction2_ATTN_T {\n  real_T y;                            /* '<S3>/MATLAB Function2' */\n};\n\n/* Block states (default storage) for system '<S3>/MATLAB Function2' */\nstruct DW_MATLABFunction2_ATTN_T {\n  real_T t0;                           /* '<S3>/MATLAB Function2' */\n  real_T y0;                           /* '<S3>/MATLAB Function2' */\n  int32_T sfEvent;                     /* '<S3>/MATLAB Function2' */\n  uint8_T is_active_c3_ATTN;           /* '<S3>/MATLAB Function2' */\n  boolean_T doneDoubleBufferReInit;    /* '<S3>/MATLAB Function2' */\n  boolean_T t0_not_empty;              /* '<S3>/MATLAB Function2' */\n  boolean_T y0_not_empty;              /* '<S3>/MATLAB Function2' */\n};\n\n/* Block signals (default storage) */\nstruct B_ATTN_T {\n  real_T Memory8;                      /* '<Root>/Memory8' */\n  real_T Memory2;                      /* '<Root>/Memory2' */\n  real_T Memory1;                      /* '<Root>/Memory1' */\n  real_T Memory;                       /* '<Root>/Memory' */\n  real_T Analoginput_o1;               /* '<Root>/Analog input ' */\n  real_T lickometer_piezo;             /* '<Root>/Analog input ' */\n  real_T filtered_lickometer;          /* '<Root>/Discrete FIR Filter1' */\n  real_T Memory11;                     /* '<Root>/Memory11' */\n  real_T Memory7;                      /* '<Root>/Memory7' */\n  real_T clock_time;                   /* '<Root>/Clock' */\n  real_T Memory3;                      /* '<Root>/Memory3' */\n  real_T Memory4;                      /* '<Root>/Memory4' */\n  real_T Memory9;                      /* '<Root>/Memory9' */\n  real_T Memory5;                      /* '<Root>/Memory5' */\n  real_T Memory6;                      /* '<Root>/Memory6' */\n  real_T Memory10;                     /* '<Root>/Memory10' */\n  real_T Clock1;                       /* '<S4>/Clock1' */\n  real_T Clock2;                       /* '<S3>/Clock2' */\n  real_T whiskCam_trig;                /* '<Root>/Whisker Trig' */\n  real_T npxls_trig;                   /* '<Root>/Npxls Trig' */\n  real_T pupilCam_trig;                /* '<Root>/Pupil Trig' */\n  real_T Clock1_b;                     /* '<S5>/Clock1' */\n  real_T Clock1_l;                     /* '<S6>/Clock1' */\n  real_T PulseGen1Hz;                  /* '<Root>/Digital input ' */\n  real_T HiddenRateTransitionForToWks_In;\n  /* '<Root>/HiddenRateTransitionForToWks_InsertedFor_TAQSigLogging_InsertedFor_Digital input _at_outport_0_at_inport_0' */\n  real_T tonePulse;                    /* '<S6>/MATLAB Function1' */\n  real_T y;                            /* '<S5>/MATLAB Function1' */\n  real_T Lick;                         /* '<Root>/MATLAB Function1' */\n  real_T y1;                           /* '<Root>/MATLAB Function1' */\n  real_T y2;                           /* '<Root>/MATLAB Function1' */\n  real_T state_out;                    /* '<Root>/MATLAB Function' */\n  real_T localTime_out;                /* '<Root>/MATLAB Function' */\n  real_T trialNum_out;                 /* '<Root>/MATLAB Function' */\n  real_T npxlsAcq_out;                 /* '<Root>/MATLAB Function' */\n  real_T counter_out;                  /* '<Root>/MATLAB Function' */\n  real_T numLicks_out;                 /* '<Root>/MATLAB Function' */\n  real_T reward_trigger_out;           /* '<Root>/MATLAB Function' */\n  real_T right_trigger_out;            /* '<Root>/MATLAB Function' */\n  real_T left_trigger_out;             /* '<Root>/MATLAB Function' */\n  real_T delay_out;                    /* '<Root>/MATLAB Function' */\n  real_T was_target_out;               /* '<Root>/MATLAB Function' */\n  real_T reward_duration_out;          /* '<Root>/MATLAB Function' */\n  real_T stim_duration_out;            /* '<Root>/MATLAB Function' */\n  real_T onsetTone_trig;               /* '<Root>/MATLAB Function' */\n  boolean_T RelationalOperator;        /* '<Root>/Relational Operator' */\n  B_MATLABFunction2_ATTN_T sf_MATLABFunction1_d;/* '<S4>/MATLAB Function1' */\n  B_MATLABFunction2_ATTN_T sf_MATLABFunction2;/* '<S3>/MATLAB Function2' */\n};\n\n/* Block states (default storage) for system '<Root>' */\nstruct DW_ATTN_T {\n  real_T DiscreteFIRFilter1_states[1500];/* '<Root>/Discrete FIR Filter1' */\n  real_T Memory8_PreviousInput;        /* '<Root>/Memory8' */\n  real_T Memory2_PreviousInput;        /* '<Root>/Memory2' */\n  real_T Memory1_PreviousInput;        /* '<Root>/Memory1' */\n  real_T Memory_PreviousInput;         /* '<Root>/Memory' */\n  real_T Memory11_PreviousInput;       /* '<Root>/Memory11' */\n  real_T Memory7_PreviousInput;        /* '<Root>/Memory7' */\n  real_T Memory3_PreviousInput;        /* '<Root>/Memory3' */\n  real_T Memory4_PreviousInput;        /* '<Root>/Memory4' */\n  real_T Memory9_PreviousInput;        /* '<Root>/Memory9' */\n  real_T Memory5_PreviousInput;        /* '<Root>/Memory5' */\n  real_T Memory6_PreviousInput;        /* '<Root>/Memory6' */\n  real_T Memory10_PreviousInput;       /* '<Root>/Memory10' */\n  real_T t0;                           /* '<S6>/MATLAB Function1' */\n  real_T t0_p;                         /* '<S5>/MATLAB Function1' */\n  real_T Setup_RWORK[2];               /* '<Root>/Setup ' */\n  void *Setup_PWORK;                   /* '<Root>/Setup ' */\n  void *Analoginput_PWORK;             /* '<Root>/Analog input ' */\n  void *Analogoutput_PWORK;            /* '<Root>/Analog output ' */\n  void *Digitaloutput_PWORK;           /* '<Root>/Digital output ' */\n  void *Digitalinput_PWORK;            /* '<Root>/Digital input ' */\n  struct {\n    void *LoggedData[5];\n  } Scope_PWORK;                       /* '<Root>/Scope' */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_Digit;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_Rewar;   /* synthesized block */\n\n  struct {\n    void *LoggedData;\n  } reward_scope_PWORK;                /* '<Root>/reward_scope' */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_Pupil;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_Npxls;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_Whisk;   /* synthesized block */\n\n  struct {\n    void *LoggedData;\n  } left_scope_PWORK;                  /* '<Root>/left_scope' */\n\n  struct {\n    void *LoggedData;\n  } right_scope_PWORK;                 /* '<Root>/right_scope' */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MATLA;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_n;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_k;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_h;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_f;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_p;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_o;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_c;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_m;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MA_cm;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_g;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_b;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_Clock;   /* synthesized block */\n\n  struct {\n    void *LoggedData;\n  } Scope2_PWORK;                      /* '<Root>/Scope2' */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_a;   /* synthesized block */\n\n  struct {\n    void *LoggedData;\n  } Scope1_PWORK;                      /* '<Root>/Scope1' */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_Discr;   /* synthesized block */\n\n  struct {\n    void *LoggedData;\n  } Scope3_PWORK;                      /* '<Root>/Scope3' */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_Analo;   /* synthesized block */\n\n  int32_T DiscreteFIRFilter1_circBuf;  /* '<Root>/Discrete FIR Filter1' */\n  int32_T clockTickCounter;            /* '<Root>/Whisker Trig' */\n  int32_T clockTickCounter_n;          /* '<Root>/Npxls Trig' */\n  int32_T clockTickCounter_c;          /* '<Root>/Pupil Trig' */\n  int32_T sfEvent;                     /* '<S6>/MATLAB Function1' */\n  int32_T sfEvent_a;                   /* '<S5>/MATLAB Function1' */\n  int32_T sfEvent_b;                   /* '<Root>/MATLAB Function1' */\n  int32_T sfEvent_e;                   /* '<Root>/MATLAB Function' */\n  uint32_T method;                     /* '<Root>/MATLAB Function' */\n  uint32_T state;                      /* '<Root>/MATLAB Function' */\n  uint32_T state_p[2];                 /* '<Root>/MATLAB Function' */\n  uint32_T state_k[625];               /* '<Root>/MATLAB Function' */\n  int_T Analoginput_IWORK[2];          /* '<Root>/Analog input ' */\n  uint8_T is_active_c2_ATTN;           /* '<S6>/MATLAB Function1' */\n  uint8_T is_active_c5_ATTN;           /* '<S5>/MATLAB Function1' */\n  uint8_T is_active_c6_ATTN;           /* '<Root>/MATLAB Function1' */\n  uint8_T is_active_c1_ATTN;           /* '<Root>/MATLAB Function' */\n  boolean_T doneDoubleBufferReInit;    /* '<S6>/MATLAB Function1' */\n  boolean_T t0_not_empty;              /* '<S6>/MATLAB Function1' */\n  boolean_T doneDoubleBufferReInit_i;  /* '<S5>/MATLAB Function1' */\n  boolean_T t0_not_empty_p;            /* '<S5>/MATLAB Function1' */\n  boolean_T doneDoubleBufferReInit_j;  /* '<Root>/MATLAB Function1' */\n  boolean_T doneDoubleBufferReInit_e;  /* '<Root>/MATLAB Function' */\n  boolean_T method_not_empty;          /* '<Root>/MATLAB Function' */\n  boolean_T state_not_empty;           /* '<Root>/MATLAB Function' */\n  boolean_T state_not_empty_k;         /* '<Root>/MATLAB Function' */\n  boolean_T state_not_empty_d;         /* '<Root>/MATLAB Function' */\n  DW_MATLABFunction2_ATTN_T sf_MATLABFunction1_d;/* '<S4>/MATLAB Function1' */\n  DW_MATLABFunction2_ATTN_T sf_MATLABFunction2;/* '<S3>/MATLAB Function2' */\n};\n\n/* Real-time Model Data Structure */\nstruct tag_RTM_ATTN_T {\n  struct SimStruct_tag * *childSfunctions;\n  const char_T *errorStatus;\n  SS_SimMode simMode;\n  RTWSolverInfo solverInfo;\n  RTWSolverInfo *solverInfoPtr;\n  void *sfcnInfo;\n\n  /*\n   * NonInlinedSFcns:\n   * The following substructure contains information regarding\n   * non-inlined s-functions used in the model.\n   */\n  struct {\n    RTWSfcnInfo sfcnInfo;\n    time_T *taskTimePtrs[2];\n    SimStruct childSFunctions[5];\n    SimStruct *childSFunctionPtrs[5];\n    struct _ssBlkInfo2 blkInfo2[5];\n    struct _ssSFcnModelMethods2 methods2[5];\n    struct _ssSFcnModelMethods3 methods3[5];\n    struct _ssSFcnModelMethods4 methods4[5];\n    struct _ssStatesInfo2 statesInfo2[5];\n    ssPeriodicStatesInfo periodicStatesInfo[5];\n    struct _ssPortInfo2 inputOutputPortInfo2[5];\n    struct {\n      time_T sfcnPeriod[1];\n      time_T sfcnOffset[1];\n      int_T sfcnTsMap[1];\n      uint_T attribs[9];\n      mxArray *params[9];\n      struct _ssDWorkRecord dWork[2];\n      struct _ssDWorkAuxRecord dWorkAux[2];\n    } Sfcn0;\n\n    struct {\n      time_T sfcnPeriod[1];\n      time_T sfcnOffset[1];\n      int_T sfcnTsMap[1];\n      struct _ssPortOutputs outputPortInfo[2];\n      struct _ssOutPortUnit outputPortUnits[2];\n      struct _ssOutPortCoSimAttribute outputPortCoSimAttribute[2];\n      uint_T attribs[9];\n      mxArray *params[9];\n      struct _ssDWorkRecord dWork[2];\n      struct _ssDWorkAuxRecord dWorkAux[2];\n    } Sfcn1;\n\n    struct {\n      time_T sfcnPeriod[1];\n      time_T sfcnOffset[1];\n      int_T sfcnTsMap[1];\n      struct _ssPortInputs inputPortInfo[2];\n      struct _ssInPortUnit inputPortUnits[2];\n      struct _ssInPortCoSimAttribute inputPortCoSimAttribute[2];\n      uint_T attribs[7];\n      mxArray *params[7];\n      struct _ssDWorkRecord dWork[1];\n      struct _ssDWorkAuxRecord dWorkAux[1];\n    } Sfcn2;\n\n    struct {\n      time_T sfcnPeriod[1];\n      time_T sfcnOffset[1];\n      int_T sfcnTsMap[1];\n      struct _ssPortInputs inputPortInfo[15];\n      struct _ssInPortUnit inputPortUnits[15];\n      struct _ssInPortCoSimAttribute inputPortCoSimAttribute[15];\n      uint_T attribs[6];\n      mxArray *params[6];\n      struct _ssDWorkRecord dWork[1];\n      struct _ssDWorkAuxRecord dWorkAux[1];\n    } Sfcn3;\n\n    struct {\n      time_T sfcnPeriod[1];\n      time_T sfcnOffset[1];\n      int_T sfcnTsMap[1];\n      struct _ssPortOutputs outputPortInfo[1];\n      struct _ssOutPortUnit outputPortUnits[1];\n      struct _ssOutPortCoSimAttribute outputPortCoSimAttribute[1];\n      uint_T attribs[4];\n      mxArray *params[4];\n      struct _ssDWorkRecord dWork[1];\n      struct _ssDWorkAuxRecord dWorkAux[1];\n    } Sfcn4;\n  } NonInlinedSFcns;\n\n  boolean_T zCCacheNeedsReset;\n  boolean_T derivCacheNeedsReset;\n  boolean_T CTOutputIncnstWithState;\n\n  /*\n   * Sizes:\n   * The following substructure contains sizes information\n   * for many of the model attributes such as inputs, outputs,\n   * dwork, sample times, etc.\n   */\n  struct {\n    uint32_T options;\n    int_T numContStates;\n    int_T numU;\n    int_T numY;\n    int_T numSampTimes;\n    int_T numBlocks;\n    int_T numBlockIO;\n    int_T numBlockPrms;\n    int_T numDwork;\n    int_T numSFcnPrms;\n    int_T numSFcns;\n    int_T numIports;\n    int_T numOports;\n    int_T numNonSampZCs;\n    int_T sysDirFeedThru;\n    int_T rtwGenSfcn;\n  } Sizes;\n\n  /*\n   * Timing:\n   * The following substructure contains information regarding\n   * the timing information for the model.\n   */\n  struct {\n    time_T stepSize;\n    uint32_T clockTick0;\n    uint32_T clockTickH0;\n    time_T stepSize0;\n    uint32_T clockTick1;\n    uint32_T clockTickH1;\n    time_T stepSize1;\n    time_T tStart;\n    time_T tFinal;\n    time_T timeOfLastOutput;\n    SimTimeStep simTimeStep;\n    boolean_T stopRequestedFlag;\n    time_T *sampleTimes;\n    time_T *offsetTimes;\n    int_T *sampleTimeTaskIDPtr;\n    int_T *sampleHits;\n    int_T *perTaskSampleHits;\n    time_T *t;\n    time_T sampleTimesArray[2];\n    time_T offsetTimesArray[2];\n    int_T sampleTimeTaskIDArray[2];\n    int_T sampleHitArray[2];\n    int_T perTaskSampleHitsArray[4];\n    time_T tArray[2];\n  } Timing;\n};\n\n/* Block signals (default storage) */\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern struct B_ATTN_T ATTN_B;\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n/* Block states (default storage) */\nextern struct DW_ATTN_T ATTN_DW;\n\n/* External data declarations for dependent source files */\nextern const real_T ATTN_RGND;         /* real_T ground */\n\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  /* Model entry point functions */\n  extern void ATTN_initialize(void);\n  extern void ATTN_step(void);\n  extern void ATTN_terminate(void);\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n/* Real-time Model object */\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern RT_MODEL_ATTN_T *const ATTN_M;\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n/*-\n * The generated code includes comments that allow you to trace directly\n * back to the appropriate location in the model.  The basic format\n * is <system>/block_name, where system is the system number (uniquely\n * assigned by Simulink) and block_name is the name of the block.\n *\n * Use the MATLAB hilite_system command to trace the generated code back\n * to the model.  For example,\n *\n * hilite_system('<S3>')    - opens system 3\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\n *\n * Here is the system hierarchy for this model\n *\n * '<Root>' : 'ATTN'\n * '<S1>'   : 'ATTN/MATLAB Function'\n * '<S2>'   : 'ATTN/MATLAB Function1'\n * '<S3>'   : 'ATTN/PiezoDriver_1'\n * '<S4>'   : 'ATTN/PiezoDriver_2'\n * '<S5>'   : 'ATTN/RewardDriver'\n * '<S6>'   : 'ATTN/onsetToneDriver'\n * '<S7>'   : 'ATTN/PiezoDriver_1/MATLAB Function2'\n * '<S8>'   : 'ATTN/PiezoDriver_2/MATLAB Function1'\n * '<S9>'   : 'ATTN/RewardDriver/MATLAB Function1'\n * '<S10>'  : 'ATTN/onsetToneDriver/MATLAB Function1'\n */\n#endif                                 /* RTW_HEADER_ATTN_h_ */\n"},{"name":"ATTN_private.h","type":"header","group":"model","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * ATTN_private.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.506\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Tue Dec 12 16:07:50 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_ATTN_private_h_\n#define RTW_HEADER_ATTN_private_h_\n#include \"rtwtypes.h\"\n#include \"multiword_types.h\"\n#include \"ATTN.h\"\n#include \"ATTN_types.h\"\n\n/* Private macros used by the generated code to access rtModel */\n#ifndef rtmIsMajorTimeStep\n#define rtmIsMajorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MAJOR_TIME_STEP)\n#endif\n\n#ifndef rtmIsMinorTimeStep\n#define rtmIsMinorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MINOR_TIME_STEP)\n#endif\n\n#ifndef rtmSetTFinal\n#define rtmSetTFinal(rtm, val)         ((rtm)->Timing.tFinal = (val))\n#endif\n\n#ifndef rtmSetTPtr\n#define rtmSetTPtr(rtm, val)           ((rtm)->Timing.t = (val))\n#endif\n\nextern void* slrtRegisterSignalToLoggingService(uintptr_t sigAddr);\nextern \"C\" void sg_IO191_setup_s(SimStruct *rts);\nextern \"C\" void sg_IO191_ad_s(SimStruct *rts);\nextern \"C\" void sg_IO191_da_s(SimStruct *rts);\nextern \"C\" void sg_IO191_do_s(SimStruct *rts);\nextern \"C\" void sg_IO191_di_s(SimStruct *rts);\nextern void ATTN_MATLABFunction2_Init(DW_MATLABFunction2_ATTN_T *localDW);\nextern void ATTN_MATLABFunction2(real_T rtu_trigger, real_T rtu_duration, real_T\n  rtu_amp, real_T rtu_t, B_MATLABFunction2_ATTN_T *localB,\n  DW_MATLABFunction2_ATTN_T *localDW);\n\n#endif                                 /* RTW_HEADER_ATTN_private_h_ */\n"},{"name":"ATTN_types.h","type":"header","group":"model","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * ATTN_types.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.506\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Tue Dec 12 16:07:50 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_ATTN_types_h_\n#define RTW_HEADER_ATTN_types_h_\n\n/* Forward declaration for rtModel */\ntypedef struct tag_RTM_ATTN_T RT_MODEL_ATTN_T;\n\n#endif                                 /* RTW_HEADER_ATTN_types_h_ */\n"},{"name":"ATTN_cal.cpp","type":"source","group":"data","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Data files","code":"#include \"ATTN_cal.h\"\n#include \"ATTN.h\"\n\n/* Storage class 'PageSwitching' */\nATTN_cal_type ATTN_cal_impl = {\n  /* Variable: SampleTime\n   * Referenced by: '<Root>/SampleTime'\n   */\n  0.001,\n\n  /* Variable: T_npxls\n   * Referenced by: '<Root>/Npxls Trig'\n   */\n  4.0,\n\n  /* Variable: T_pupil\n   * Referenced by: '<Root>/Pupil Trig'\n   */\n  100.0,\n\n  /* Variable: T_whisk\n   * Referenced by: '<Root>/Whisker Trig'\n   */\n  20.0,\n\n  /* Variable: maxFrame\n   * Referenced by: '<Root>/Constant'\n   */\n  3.6E+6,\n\n  /* Variable: rewardDuration\n   * Referenced by: '<Root>/rewardDuration'\n   */\n  0.05,\n\n  /* Variable: targetSide\n   * Referenced by: '<Root>/targetSide'\n   */\n  0.0,\n\n  /* Variable: trainingStage\n   * Referenced by: '<Root>/trainingStage'\n   */\n  1.0,\n\n  /* Variable: triangleAmplitude\n   * Referenced by: '<Root>/triangleAmplitude'\n   */\n  10.0,\n\n  /* Variable: triangleDuration\n   * Referenced by: '<Root>/triangleDuration'\n   */\n  0.1,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Memory8'\n   */\n  0.0,\n\n  /* Expression: 1\n   * Referenced by: '<Root>/Memory2'\n   */\n  1.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Memory1'\n   */\n  0.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Memory'\n   */\n  0.0,\n\n  /* Computed Parameter: Setup_P1_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parPciSlot\n   * Referenced by: '<Root>/Setup '\n   */\n  -1.0,\n\n  /* Computed Parameter: Setup_P2_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parModuleId\n   * Referenced by: '<Root>/Setup '\n   */\n  1.0,\n\n  /* Computed Parameter: Setup_P3_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parTriggerSignal\n   * Referenced by: '<Root>/Setup '\n   */\n  1.0,\n\n  /* Computed Parameter: Setup_P4_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parAdcChannels\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 2.0 },\n\n  /* Computed Parameter: Setup_P5_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parAdcMode\n   * Referenced by: '<Root>/Setup '\n   */\n  2.0,\n\n  /* Computed Parameter: Setup_P6_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parAdcRanges\n   * Referenced by: '<Root>/Setup '\n   */\n  { 3.0, 3.0 },\n\n  /* Computed Parameter: Setup_P7_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parDacChannels\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 3.0 },\n\n  /* Computed Parameter: Setup_P8_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parDacRanges\n   * Referenced by: '<Root>/Setup '\n   */\n  { 4.0, 4.0 },\n\n  /* Computed Parameter: Setup_P9_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 8.0 },\n\n  /* Expression: parDioFirstControl\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 8.0, 9.0 },\n\n  /* Computed Parameter: Analoginput_P1_Size\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parModuleId\n   * Referenced by: '<Root>/Analog input '\n   */\n  1.0,\n\n  /* Computed Parameter: Analoginput_P2_Size\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parSampleTime\n   * Referenced by: '<Root>/Analog input '\n   */\n  -1.0,\n\n  /* Computed Parameter: Analoginput_P3_Size\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parPciSlot\n   * Referenced by: '<Root>/Analog input '\n   */\n  -1.0,\n\n  /* Computed Parameter: Analoginput_P4_Size\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parAdcChannels\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 2.0 },\n\n  /* Computed Parameter: Analoginput_P5_Size\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parAdcMode\n   * Referenced by: '<Root>/Analog input '\n   */\n  2.0,\n\n  /* Computed Parameter: Analoginput_P6_Size\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parAdcRate\n   * Referenced by: '<Root>/Analog input '\n   */\n  100000.0,\n\n  /* Computed Parameter: Analoginput_P7_Size\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parAdcRanges\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 3.0, 3.0 },\n\n  /* Computed Parameter: Analoginput_P8_Size\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parAdcInitValues\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 0.0, 0.0 },\n\n  /* Computed Parameter: Analoginput_P9_Size\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parAdcResets\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Discrete FIR Filter1'\n   */\n  0.0,\n\n  /* Expression: [7.47277683114599e-20\t2.55865962628471e-06\t5.11967570263367e-06\t7.67856921040619e-06\t1.02308419417135e-05\t1.27719788015466e-05\t1.52974501454567e-05\t1.78027141586849e-05\t2.02832192825685e-05\t2.27344066940190e-05\t2.51517128437406e-05\t2.75305720587617e-05\t2.98664192146919e-05\t3.21546924829572e-05\t3.43908361580643e-05\t3.65703035697221e-05\t3.86885600844072e-05\t4.07410862006860e-05\t4.27233807423181e-05\t4.46309641528412e-05\t4.64593818950024e-05\t4.82042079580479e-05\t4.98610484754855e-05\t5.14255454555536e-05\t5.28933806261883e-05\t5.42602793958663e-05\t5.55220149312262e-05\t5.66744123519132e-05\t5.77133530426020e-05\t5.86347790816568e-05\t5.94346977853764e-05\t6.01091863662453e-05\t6.06543967030956e-05\t6.10665602205273e-05\t6.13419928744055e-05\t6.14771002396855e-05\t6.14683826962815e-05\t6.13124407081177e-05\t6.10059801899582e-05\t6.05458179560438e-05\t5.99288872440181e-05\t5.91522433070664e-05\t5.82130690666487e-05\t5.71086808176713e-05\t5.58365339774059e-05\t5.43942288689521e-05\t5.27795165295223e-05\t5.09903045333425e-05\t4. */\n  { 7.47277683114599E-20, 2.55865962628471E-6, 5.11967570263367E-6,\n    7.67856921040619E-6, 1.02308419417135E-5, 1.27719788015466E-5,\n    1.52974501454567E-5, 1.78027141586849E-5, 2.02832192825685E-5,\n    2.2734406694019E-5, 2.51517128437406E-5, 2.75305720587617E-5,\n    2.98664192146919E-5, 3.21546924829572E-5, 3.43908361580643E-5,\n    3.65703035697221E-5, 3.86885600844072E-5, 4.0741086200686E-5,\n    4.27233807423181E-5, 4.46309641528412E-5, 4.64593818950024E-5,\n    4.82042079580479E-5, 4.98610484754855E-5, 5.14255454555536E-5,\n    5.28933806261883E-5, 5.42602793958663E-5, 5.55220149312262E-5,\n    5.66744123519132E-5, 5.7713353042602E-5, 5.86347790816568E-5,\n    5.94346977853764E-5, 6.01091863662453E-5, 6.06543967030956E-5,\n    6.10665602205273E-5, 6.13419928744055E-5, 6.14771002396855E-5,\n    6.14683826962815E-5, 6.13124407081177E-5, 6.10059801899582E-5,\n    6.05458179560438E-5, 5.99288872440181E-5, 5.91522433070664E-5,\n    5.82130690666487E-5, 5.71086808176713E-5, 5.58365339774059E-5,\n    5.43942288689521E-5, 5.27795165295223E-5, 5.09903045333425E-5,\n    4.90246628184729E-5, 4.68808295063986E-5, 4.45572167027813E-5,\n    4.20524162673526E-5, 3.93652055405077E-5, 3.64945530137878E-5,\n    3.343962393107E-5, 3.01997858069561E-5, 2.67746138485385E-5,\n    2.3163896266439E-5, 1.93676394607737E-5, 1.53860730674611E-5,\n    1.12196548501132E-5, 6.86907542257971E-6, 2.33526278709564E-6,\n    -2.38061332710547E-6, -7.277137339921E-6, -1.23526439264607E-5,\n    -1.76052143682957E-5, -2.30326731650107E-5, -2.86325849211373E-5,\n    -3.44022515233885E-5, -4.03387096229618E-5, -4.64387284374705E-5,\n    -5.26988078868132E-5, -5.91151770770133E-5, -6.56837931457214E-5,\n    -7.24003404827332E-5, -7.92602303384457E-5, -8.62586008327578E-5,\n    -9.33903173764076E-5, -0.000100649973516263, -0.000108031892215478,\n    -0.000115530127578867, -0.000123138467033194, -0.000130850433971418,\n    -0.000138659290869229, -0.000146558042881469, -0.000154539441925259,\n    -0.000162595991255854, -0.00017071995054041, -0.000178903341433976,\n    -0.00018713795366115, -0.000195415351605887, -0.000203726881411025,\n    -0.000212063678588118, -0.000220416676137166, -0.000228776613174815,\n    -0.000237134044068595, -0.000245479348073666, -0.000253802739467532,\n    -0.000262094278177049, -0.000270343880891021, -0.000278541332650522,\n    -0.000286676298908029, -0.000294738338045302, -0.000302716914338852,\n    -0.000310601411360734, -0.000318381145801259, -0.000326045381699152,\n    -0.00033358334506356, -0.000340984238871217, -0.000348237258421025,\n    -0.000355331607027209, -0.000362256512031173, -0.000369001241111159,\n    -0.000375555118867786, -0.000381907543662574, -0.000388048004685588,\n    -0.000393966099227414, -0.000399651550129767, -0.000405094223388176,\n    -0.000410284145879348, -0.000415211523185017, -0.000419866757483334,\n    -0.000424240465478137, -0.00042832349633576, -0.000432106949598435,\n    -0.000435582193042744, -0.000438740880451056, -0.000441574969263422,\n    -0.000444076738076955, -0.00044623880395937, -0.000448054139543056,\n    -0.000449516089865765, -0.000450618388923862, -0.000451355175903889,\n    -0.000451721011058181, -0.000451710891190224, -0.000451320264715525,\n    -0.000450545046263876, -0.000449381630789087, -0.000447826907152526,\n    -0.000445878271147096, -0.000443533637928715, -0.000440791453822779,\n    -0.000437650707473649, -0.000434110940305761, -0.000430172256265661,\n    -0.000425835330814964, -0.000421101419145048, -0.000415972363585155,\n    -0.000410450600176512, -0.00040453916438606, -0.000398241695934472,\n    -0.000391562442714227, -0.000384506263774744, -0.000377078631352787,\n    -0.000369285631927676, -0.000361133966282231, -0.000352630948551759,\n    -0.000343784504244919, -0.00033460316722179, -0.000325096075616101,\n    -0.000315272966690158, -0.000305144170612759, -0.000294720603152018,\n    -0.00028401375727689, -0.000273035693662904, -0.000261799030099529,\n    -0.000250316929798388, -0.000238603088603566, -0.000226671721107042,\n    -0.000214537545674379, -0.000202215768387676, -0.000189722065914846,\n    -0.000177072567316285, -0.000164283834802009, -0.000151372843454383,\n    -0.000138356959933597, -0.000125253920185076, -0.000112081806170066,\n    -9.88590216426344E-5, -8.56042669983775E-5, -7.23365132220933E-5,\n    -5.90749749637039E-5, -4.58390827736315E-5, -3.26484545308114E-5,\n    -1.95228660984025E-5, -6.48222124416269E-6, 6.45347913574842E-6,\n    1.92641684489213E-5, 3.19297464524893E-5, 4.44301118684996E-5,\n    5.67451955231691E-5, 6.88549939627184E-5, 8.07396034969619E-5,\n    9.23792546203174E-5, 0.00010375434675853, 0.00011484548328803,\n    0.000125633506773593, 0.00013609953436877, 0.000146224993322452,\n    0.00015599165653388, 0.000165381678097493, 0.000174377628778114,\n    0.000182962531356236, 0.000191119895782473, 0.000198833754079658,\n    0.000206088694930604, 0.000212869897889143, 0.000219163167151782,\n    0.000224954964827125, 0.000230232443640159, 0.000234983479008503,\n    0.000239196700427884, 0.000242861522104343, 0.000245968172771024,\n    0.000248507724627882, 0.000250472121343227, 0.000251854205056692,\n    0.000252647742324057, 0.000252847448945224, 0.000252449013617722,\n    0.000251449120359227, 0.000249845469643829, 0.00024763679819818,\n    0.000244822897405062, 0.00024140463026357, 0.000237383946856721,\n    0.000232763898279138, 0.000227548648979331, 0.000221743487473104,\n    0.000215354835386701, 0.000208390254790512, 0.000200858453786435,\n    0.000192769290314387, 0.000184133774145895, 0.0001749640670353,\n    0.000165273481001697, 0.000155076474717484, 0.000144388647982165,\n    0.000133226734262944, 0.000121608591286549, 0.00010955318966974,\n    9.7080599579001E-5, 8.42119754130424E-5, 7.09695385048991E-5,\n    5.73765578435795E-5, 4.34573288185537E-5, 2.92371499935482E-5,\n    1.47422979195256E-5, -2.89570102206907E-19, -1.49615945747347E-5,\n    -3.01134458045921E-5, -4.54256557445348E-5, -6.08675032306165E-5,\n    -7.64074804371047E-5, -9.20133312312316E-5, -0.000107652091288701,\n    -0.000123290129929803, -0.00013889319363255, -0.000154426451176078,\n    -0.000169854540364182, -0.000185141616275717, -0.00020025140098535,\n    -0.000215147234695133, -0.000229792128214169, -0.000244148816720784,\n    -0.000258179814738611, -0.000271847472255163, -0.000285114031908709,\n    -0.000297941687166617, -0.000310292641415675, -0.000322129167882484,\n    -0.000333413670299596, -0.000344108744230797, -0.000354177238966773,\n    -0.000363582319900374, -0.000372287531288722, -0.000380256859307689,\n    -0.000387454795302522, -0.000393846399136942, -0.000399397362541602,\n    -0.000404074072361604, -0.000407843673601605, -0.000410674132166183,\n    -0.000412534297192291, -0.000413393962869987, -0.000413223929647223,\n    -0.00041199606471408, -0.000409683361661765, -0.000406259999211655,\n    -0.000401701398909919, -0.00039598428168354, -0.00038908672315418,\n    -0.000380988207606948, -0.000371669680512089, -0.000361113599498608,\n    -0.000349303983680105, -0.000336226461234486, -0.00032186831514079,\n    -0.000306218526978132, -0.000289267818693655, -0.000271008692248528,\n    -0.000251435467053209, -0.000230544315105724, -0.000208333293749184,\n    -0.000184802375967652, -0.000159953478142262, -0.000133790485192674,\n    -0.000106319273032093, -7.75477282675384E-5, -4.74857650804866E-5,\n    -1.61453392267853E-5, 1.64595409015606E-5, 5.03128062061118E-5,\n    8.53963218525767E-5, 0.000121689885327374, 0.000159171227621052,\n    0.000197816017574914, 0.000237597869422766, 0.000278488353555005,\n    0.00032045701052757, 0.000363471368333427, 0.000407496962949437,\n    0.000452497362166358, 0.00049843419270485, 0.00054526717061513,\n    0.00059295413495279, 0.000641451084718191, 0.000690712219041478,\n    0.000740689980590114, 0.000791335102170428, 0.000842596656489554,\n    0.00089442210903861, 0.000946757374052876, 0.000999546873499304,\n    0.00105273359903652, 0.00110625917688716, 0.00116006393555726,\n    0.00121408697633218, 0.00126826624647365, 0.00132253861503705,\n    0.0013768399512237, 0.00143110520517742, 0.00148526849113038,\n    0.00153926317279804, 0.00159302195091886, 0.00164647695282973,\n    0.00169955982396365, 0.00175220182115219, 0.00180433390761108,\n    0.00185588684948312, 0.00190679131380927, 0.00195697796779464,\n    0.00200637757923311, 0.00205492111795062, 0.0021025398581243,\n    0.0021491654813317, 0.00219473018018159, 0.00223916676237516,\n    0.00228240875504447, 0.00232439050921261, 0.00236504730421813,\n    0.00240431545194501, 0.00244213240069747, 0.00247843683855824,\n    0.0025131687960675, 0.00254626974805942, 0.00257768271449228,\n    0.00260735236010835, 0.00263522509275942, 0.00266124916023432,\n    0.00268537474542521, 0.00270755405967022, 0.00272774143411101,\n    0.0027458934089053, 0.0027619688201356, 0.00277592888425765,\n    0.00278773727993376, 0.00279736022709874, 0.0028047665631087,\n    0.00280992781582576, 0.00281281827349487, 0.0028134150512722,\n    0.00281169815426827, 0.00280765053697264, 0.00280125815893131,\n    0.00279251003655189, 0.00278139829091669, 0.00276791819148808,\n    0.00275206819559587, 0.00273384998360153, 0.00271326848963936,\n    0.00269033192784063, 0.00266505181395229, 0.00263744298226794,\n    0.00260752359779501, 0.00257531516358838, 0.00254084252318727,\n    0.00250413385809899, 0.00246522068027977, 0.00242413781957023,\n    0.00238092340604986, 0.0023356188472823, 0.00228826880043062,\n    0.00223892113922903, 0.00218762691580539, 0.00213444031735612,\n    0.00207941861768317, 0.00202262212361024, 0.0019641141163035,\n    0.00190396078752973, 0.00184223117089264, 0.00177899706809648,\n    0.00171433297029328, 0.00164831597457857, 0.00158102569570795,\n    0.00151254417311495, 0.0014429557733181, 0.00137234708781338,\n    0.00130080682655538, 0.00122842570713851, 0.00115529633979676,\n    0.00108151310834823, 0.00100717204721764, 0.000932370714677483,\n    0.0008572080624552, 0.00078178430186079, 0.000706200766596011,\n    0.000630559772412639, 0.000554964473793834, 0.000479518717838589,\n    0.000404326895535311, 0.000329493790616252, 0.000255124426189886,\n    0.000181323909353765, 0.000108197273995199, 3.58493219919046E-5,\n    -3.56155369707369E-5, -0.000106093446745042, -0.000175481267004346,\n    -0.000243676736235937, -0.000310578635212037, -0.000376086950704255,\n    -0.000440103039204209, -0.000502529790410721, -0.000563271790241955,\n    -0.00062223548312913, -0.000679329333347147, -0.000734463985136471,\n    -0.000787552421369875, -0.000838510120517479, -0.000887255211663436,\n    -0.000933708627328164, -0.000977794253850711, -0.00101943907908703,\n    -0.00105857333718142, -0.00109513065017034, -0.00112904816617986,\n    -0.00116026669398096, -0.00118873083366949, -0.00121438910324108,\n    -0.00123719406083525, -0.0012571024224266, -0.00127407517474559,\n    -0.00128807768321635, -0.00129907979470377, -0.00130705593486782,\n    -0.00131198519992874, -0.00131385144265302, -0.00131264335237627,\n    -0.00130835452888634, -0.0013009835499966, -0.00129053403264728,\n    -0.00127701468737988, -0.00126043936603828, -0.00124082710255787,\n    -0.00121820214671305, -0.00119259399070198, -0.0011640373884566,\n    -0.00113257236757519, -0.0010982442337845, -0.00106110356784778,\n    -0.00102120621484539, -0.000978613265764647, -0.000933391031345854,\n    -0.000885611008141868, -0.000835349836759427, -0.000782689252260949,\n    -0.000727716026716505, -0.000670521903906705, -0.000611203526188236,\n    -0.000549862353544915, -0.000486604574858484, -0.00042154101144448,\n    -0.000354787012909843, -0.000286462345400301, -0.000216691072316808,\n    -0.00014560142759155, -7.33256816254293E-5, 7.19254769997801E-19,\n    7.42357049120248E-5, 0.000149237929302405, 0.000224859740103052,\n    0.00030095094382479, 0.000377358261891444, 0.000453925512291049,\n    0.000530493797355587, 0.000606901697470346, 0.000682985470504074,\n    0.000758579256741336, 0.000833515289088735, 0.000907624108317507,\n    0.000980734783095885, 0.0010526751345557, 0.00112327196512931,\n    0.00119235129138475, 0.00125973858057888, 0.00132525899064098,\n    0.00138873761329188, 0.0014499997199968, 0.00150887101044373,\n    0.00156517786323271, 0.00161874758845597, 0.00166940868184338,\n    0.00171699108014261, 0.00176132641739902, 0.00180224828179624,\n    0.00183959247271447, 0.00187319725766064, 0.00190290362872159,\n    0.00192855555818921, 0.00195000025300448, 0.00196708840766637,\n    0.00197967445525011, 0.00198761681617943, 0.00199077814439713,\n    0.001989025570579, 0.00198223094203719, 0.00197027105896066,\n    0.00195302790664221, 0.00193038888334449, 0.00190224702345992,\n    0.00186850121562344, 0.00182905641544065, 0.00178382385249867,\n    0.00173272123133173, 0.00167567292601933, 0.00161261016810032,\n    0.00154347122749315, 0.00146820158611887, 0.00138675410393134,\n    0.00129908917706644, 0.00120517488783061, 0.00110498714625756,\n    0.000998509822971181, 0.000885734873102136, 0.000766662451015514,\n    0.000641301015617403, 0.000509667426018673, 0.000371787027345634,\n    0.0002276937264984, 7.74300576697443E-5, -7.89527625507157E-5,\n    -0.000241394790649771, -0.00040982732239134, -0.000584172869881566,\n    -0.000764345149622112, -0.000950249081661772, -0.00114178079994279,\n    -0.00133882767392432, -0.00154126834155127, -0.00174897275362225,\n    -0.00196180222959601, -0.00217960952486101, -0.00240223890947765,\n    -0.00262952625838842, -0.00286129915307534, -0.00309737699462987,\n    -0.0033375711281846, -0.0035816849786414, -0.00382951419761518,\n    -0.00408084682149751, -0.00433546344052907, -0.00459313737875492,\n    -0.00485363488472152, -0.00511671533275963, -0.00538213143468235,\n    -0.0056496294617129, -0.00591894947644237, -0.00618982557460332,\n    -0.0064619861364308, -0.0067351540873688, -0.00700904716786624,\n    -0.00728337821199327, -0.00755785543459555, -0.00783218272669133,\n    -0.00810605995880358, -0.00837918329190739, -0.00865124549566087,\n    -0.00892193627357631, -0.00919094259477741, -0.00945794903197762,\n    -0.00972263810530438, -0.00998469063158416, -0.010243786078694,\n    -0.0104996029245761, -0.0107518190205037, -0.011000111958179,\n    -0.0112441594402344, -0.0114836396537058, -0.0117182316460343,\n    -0.0119476157031521, -0.0121714737292003, -0.0123894896274222,\n    -0.0126013496817715, -0.012806742938771, -0.0130053615891551,\n    -0.0131969013488267, -0.0133810618386553, -0.0135575469626461,\n    -0.013726065284005, -0.0138863303986269, -0.0140380613055336,\n    -0.0141809827737919, -0.0143148257054396, -0.0144393274939538,\n    -0.0145542323777966, -0.0146592917885783, -0.0147542646933807,\n    -0.0148389179307901, -0.0149130265401937, -0.0149763740838996,\n    -0.015028752961647, -0.0150699647170814, -0.0150998203357757,\n    -0.0151181405343887, -0.0151247560405597, -0.0151195078631481,\n    -0.0151022475524371, -0.0150728374499309, -0.015031150927387,\n    -0.014977072614734, -0.0149104986165412, -0.0148313367167168,\n    -0.0147395065711232, -0.0146349398878158, -0.01451758059462,\n    -0.0143873849937804, -0.0142443219034289, -0.0140883727856319,\n    -0.0139195318607958, -0.0137378062082235, -0.0135432158526313,\n    -0.0133357938364516, -0.0131155862777654, -0.0128826524137235,\n    -0.012637064629333, -0.012378908471505, -0.0121082826482743,\n    -0.0118252990131225, -0.0115300825343511, -0.0112227712494722,\n    -0.0109035162046009, -0.0105724813788522, -0.010229843593763,\n    -0.00987579240778032, -0.00951052999587282, -0.00913427101434232,\n    -0.00874724245093055, -0.00834968346033439, -0.00794184518526101,\n    -0.00752399056317267, -0.00709639411888902, -0.00665934174323227,\n    -0.00621313045791866, -0.00575806816691683, -0.00529447339451106,\n    -0.00482267501032449, -0.00434301194157384, -0.00385583287284378,\n    -0.00336149593368541, -0.00286036837435846, -0.0023528262300532,\n    -0.00183925397394197, -0.00132004415942586, -0.000795597051955804,\n    -0.000266320250821043, 0.000267371698688395, 0.000805057702325976,\n    0.0013463105227081, 0.00189069719346513, 0.0024377794412692,\n    0.00298711411527345, 0.00353825362348642, 0.00409074637559677,\n    0.00464413723175339, 0.00519796795679813, 0.00575177767944047,\n    0.00630510335585588, 0.0068574802371835, 0.0074084423403926,\n    0.00795752292198173, 0.00850425495397047, 0.00904817160163901,\n    0.00958880670246806, 0.0101256952457286, 0.0106583738521692,\n    0.0111863812532474, 0.0117092587693513, 0.0122265507864565,\n    0.0127378052306666, 0.0132425740400844, 0.0137404136334652,\n    0.0142308853751047, 0.01471355603542, 0.0151879982466835, 0.0156537909533765,\n    0.0161105198566348, 0.0165577778522639, 0.0169951654618083,\n    0.017422291256169, 0.0178387722712688, 0.0182442344152751,\n    0.0186383128669006, 0.0190206524643096, 0.0193909080841709,\n    0.0197487450104079, 0.0200938392922097, 0.0204258780908776,\n    0.0207445600150963, 0.0210495954442313, 0.0213407068392676,\n    0.0216176290410214, 0.0218801095552688, 0.0221279088244518,\n    0.0223608004856395, 0.0225785716144351, 0.0227810229545396,\n    0.0229679691326971, 0.0231392388587654, 0.0232946751106741,\n    0.0234341353040481, 0.023557491446294, 0.0236646302749659,\n    0.0237554533802449, 0.023829877311386, 0.0238878336670043,\n    0.0239292691690938, 0.0239541457206896, 0.0239624404471043,\n    0.0239541457206896, 0.0239292691690938, 0.0238878336670043,\n    0.023829877311386, 0.0237554533802449, 0.0236646302749659, 0.023557491446294,\n    0.0234341353040481, 0.0232946751106741, 0.0231392388587654,\n    0.0229679691326971, 0.0227810229545396, 0.0225785716144351,\n    0.0223608004856395, 0.0221279088244518, 0.0218801095552688,\n    0.0216176290410214, 0.0213407068392676, 0.0210495954442313,\n    0.0207445600150963, 0.0204258780908776, 0.0200938392922097,\n    0.0197487450104079, 0.0193909080841709, 0.0190206524643096,\n    0.0186383128669006, 0.0182442344152751, 0.0178387722712688,\n    0.017422291256169, 0.0169951654618083, 0.0165577778522639,\n    0.0161105198566348, 0.0156537909533765, 0.0151879982466835, 0.01471355603542,\n    0.0142308853751047, 0.0137404136334652, 0.0132425740400844,\n    0.0127378052306666, 0.0122265507864565, 0.0117092587693513,\n    0.0111863812532474, 0.0106583738521692, 0.0101256952457286,\n    0.00958880670246806, 0.00904817160163901, 0.00850425495397047,\n    0.00795752292198173, 0.0074084423403926, 0.0068574802371835,\n    0.00630510335585588, 0.00575177767944047, 0.00519796795679813,\n    0.00464413723175339, 0.00409074637559677, 0.00353825362348642,\n    0.00298711411527345, 0.0024377794412692, 0.00189069719346513,\n    0.0013463105227081, 0.000805057702325976, 0.000267371698688395,\n    -0.000266320250821043, -0.000795597051955804, -0.00132004415942586,\n    -0.00183925397394197, -0.0023528262300532, -0.00286036837435846,\n    -0.00336149593368541, -0.00385583287284378, -0.00434301194157384,\n    -0.00482267501032449, -0.00529447339451106, -0.00575806816691683,\n    -0.00621313045791866, -0.00665934174323227, -0.00709639411888902,\n    -0.00752399056317267, -0.00794184518526101, -0.00834968346033439,\n    -0.00874724245093055, -0.00913427101434232, -0.00951052999587282,\n    -0.00987579240778032, -0.010229843593763, -0.0105724813788522,\n    -0.0109035162046009, -0.0112227712494722, -0.0115300825343511,\n    -0.0118252990131225, -0.0121082826482743, -0.012378908471505,\n    -0.012637064629333, -0.0128826524137235, -0.0131155862777654,\n    -0.0133357938364516, -0.0135432158526313, -0.0137378062082235,\n    -0.0139195318607958, -0.0140883727856319, -0.0142443219034289,\n    -0.0143873849937804, -0.01451758059462, -0.0146349398878158,\n    -0.0147395065711232, -0.0148313367167168, -0.0149104986165412,\n    -0.014977072614734, -0.015031150927387, -0.0150728374499309,\n    -0.0151022475524371, -0.0151195078631481, -0.0151247560405597,\n    -0.0151181405343887, -0.0150998203357757, -0.0150699647170814,\n    -0.015028752961647, -0.0149763740838996, -0.0149130265401937,\n    -0.0148389179307901, -0.0147542646933807, -0.0146592917885783,\n    -0.0145542323777966, -0.0144393274939538, -0.0143148257054396,\n    -0.0141809827737919, -0.0140380613055336, -0.0138863303986269,\n    -0.013726065284005, -0.0135575469626461, -0.0133810618386553,\n    -0.0131969013488267, -0.0130053615891551, -0.012806742938771,\n    -0.0126013496817715, -0.0123894896274222, -0.0121714737292003,\n    -0.0119476157031521, -0.0117182316460343, -0.0114836396537058,\n    -0.0112441594402344, -0.011000111958179, -0.0107518190205037,\n    -0.0104996029245761, -0.010243786078694, -0.00998469063158416,\n    -0.00972263810530438, -0.00945794903197762, -0.00919094259477741,\n    -0.00892193627357631, -0.00865124549566087, -0.00837918329190739,\n    -0.00810605995880358, -0.00783218272669133, -0.00755785543459555,\n    -0.00728337821199327, -0.00700904716786624, -0.0067351540873688,\n    -0.0064619861364308, -0.00618982557460332, -0.00591894947644237,\n    -0.0056496294617129, -0.00538213143468235, -0.00511671533275963,\n    -0.00485363488472152, -0.00459313737875492, -0.00433546344052907,\n    -0.00408084682149751, -0.00382951419761518, -0.0035816849786414,\n    -0.0033375711281846, -0.00309737699462987, -0.00286129915307534,\n    -0.00262952625838842, -0.00240223890947765, -0.00217960952486101,\n    -0.00196180222959601, -0.00174897275362225, -0.00154126834155127,\n    -0.00133882767392432, -0.00114178079994279, -0.000950249081661772,\n    -0.000764345149622112, -0.000584172869881566, -0.00040982732239134,\n    -0.000241394790649771, -7.89527625507157E-5, 7.74300576697443E-5,\n    0.0002276937264984, 0.000371787027345634, 0.000509667426018673,\n    0.000641301015617403, 0.000766662451015514, 0.000885734873102136,\n    0.000998509822971181, 0.00110498714625756, 0.00120517488783061,\n    0.00129908917706644, 0.00138675410393134, 0.00146820158611887,\n    0.00154347122749315, 0.00161261016810032, 0.00167567292601933,\n    0.00173272123133173, 0.00178382385249867, 0.00182905641544065,\n    0.00186850121562344, 0.00190224702345992, 0.00193038888334449,\n    0.00195302790664221, 0.00197027105896066, 0.00198223094203719,\n    0.001989025570579, 0.00199077814439713, 0.00198761681617943,\n    0.00197967445525011, 0.00196708840766637, 0.00195000025300448,\n    0.00192855555818921, 0.00190290362872159, 0.00187319725766064,\n    0.00183959247271447, 0.00180224828179624, 0.00176132641739902,\n    0.00171699108014261, 0.00166940868184338, 0.00161874758845597,\n    0.00156517786323271, 0.00150887101044373, 0.0014499997199968,\n    0.00138873761329188, 0.00132525899064098, 0.00125973858057888,\n    0.00119235129138475, 0.00112327196512931, 0.0010526751345557,\n    0.000980734783095885, 0.000907624108317507, 0.000833515289088735,\n    0.000758579256741336, 0.000682985470504074, 0.000606901697470346,\n    0.000530493797355587, 0.000453925512291049, 0.000377358261891444,\n    0.00030095094382479, 0.000224859740103052, 0.000149237929302405,\n    7.42357049120248E-5, 7.19254769997801E-19, -7.33256816254293E-5,\n    -0.00014560142759155, -0.000216691072316808, -0.000286462345400301,\n    -0.000354787012909843, -0.00042154101144448, -0.000486604574858484,\n    -0.000549862353544915, -0.000611203526188236, -0.000670521903906705,\n    -0.000727716026716505, -0.000782689252260949, -0.000835349836759427,\n    -0.000885611008141868, -0.000933391031345854, -0.000978613265764647,\n    -0.00102120621484539, -0.00106110356784778, -0.0010982442337845,\n    -0.00113257236757519, -0.0011640373884566, -0.00119259399070198,\n    -0.00121820214671305, -0.00124082710255787, -0.00126043936603828,\n    -0.00127701468737988, -0.00129053403264728, -0.0013009835499966,\n    -0.00130835452888634, -0.00131264335237627, -0.00131385144265302,\n    -0.00131198519992874, -0.00130705593486782, -0.00129907979470377,\n    -0.00128807768321635, -0.00127407517474559, -0.0012571024224266,\n    -0.00123719406083525, -0.00121438910324108, -0.00118873083366949,\n    -0.00116026669398096, -0.00112904816617986, -0.00109513065017034,\n    -0.00105857333718142, -0.00101943907908703, -0.000977794253850711,\n    -0.000933708627328164, -0.000887255211663436, -0.000838510120517479,\n    -0.000787552421369875, -0.000734463985136471, -0.000679329333347147,\n    -0.00062223548312913, -0.000563271790241955, -0.000502529790410721,\n    -0.000440103039204209, -0.000376086950704255, -0.000310578635212037,\n    -0.000243676736235937, -0.000175481267004346, -0.000106093446745042,\n    -3.56155369707369E-5, 3.58493219919046E-5, 0.000108197273995199,\n    0.000181323909353765, 0.000255124426189886, 0.000329493790616252,\n    0.000404326895535311, 0.000479518717838589, 0.000554964473793834,\n    0.000630559772412639, 0.000706200766596011, 0.00078178430186079,\n    0.0008572080624552, 0.000932370714677483, 0.00100717204721764,\n    0.00108151310834823, 0.00115529633979676, 0.00122842570713851,\n    0.00130080682655538, 0.00137234708781338, 0.0014429557733181,\n    0.00151254417311495, 0.00158102569570795, 0.00164831597457857,\n    0.00171433297029328, 0.00177899706809648, 0.00184223117089264,\n    0.00190396078752973, 0.0019641141163035, 0.00202262212361024,\n    0.00207941861768317, 0.00213444031735612, 0.00218762691580539,\n    0.00223892113922903, 0.00228826880043062, 0.0023356188472823,\n    0.00238092340604986, 0.00242413781957023, 0.00246522068027977,\n    0.00250413385809899, 0.00254084252318727, 0.00257531516358838,\n    0.00260752359779501, 0.00263744298226794, 0.00266505181395229,\n    0.00269033192784063, 0.00271326848963936, 0.00273384998360153,\n    0.00275206819559587, 0.00276791819148808, 0.00278139829091669,\n    0.00279251003655189, 0.00280125815893131, 0.00280765053697264,\n    0.00281169815426827, 0.0028134150512722, 0.00281281827349487,\n    0.00280992781582576, 0.0028047665631087, 0.00279736022709874,\n    0.00278773727993376, 0.00277592888425765, 0.0027619688201356,\n    0.0027458934089053, 0.00272774143411101, 0.00270755405967022,\n    0.00268537474542521, 0.00266124916023432, 0.00263522509275942,\n    0.00260735236010835, 0.00257768271449228, 0.00254626974805942,\n    0.0025131687960675, 0.00247843683855824, 0.00244213240069747,\n    0.00240431545194501, 0.00236504730421813, 0.00232439050921261,\n    0.00228240875504447, 0.00223916676237516, 0.00219473018018159,\n    0.0021491654813317, 0.0021025398581243, 0.00205492111795062,\n    0.00200637757923311, 0.00195697796779464, 0.00190679131380927,\n    0.00185588684948312, 0.00180433390761108, 0.00175220182115219,\n    0.00169955982396365, 0.00164647695282973, 0.00159302195091886,\n    0.00153926317279804, 0.00148526849113038, 0.00143110520517742,\n    0.0013768399512237, 0.00132253861503705, 0.00126826624647365,\n    0.00121408697633218, 0.00116006393555726, 0.00110625917688716,\n    0.00105273359903652, 0.000999546873499304, 0.000946757374052876,\n    0.00089442210903861, 0.000842596656489554, 0.000791335102170428,\n    0.000740689980590114, 0.000690712219041478, 0.000641451084718191,\n    0.00059295413495279, 0.00054526717061513, 0.00049843419270485,\n    0.000452497362166358, 0.000407496962949437, 0.000363471368333427,\n    0.00032045701052757, 0.000278488353555005, 0.000237597869422766,\n    0.000197816017574914, 0.000159171227621052, 0.000121689885327374,\n    8.53963218525767E-5, 5.03128062061118E-5, 1.64595409015606E-5,\n    -1.61453392267853E-5, -4.74857650804866E-5, -7.75477282675384E-5,\n    -0.000106319273032093, -0.000133790485192674, -0.000159953478142262,\n    -0.000184802375967652, -0.000208333293749184, -0.000230544315105724,\n    -0.000251435467053209, -0.000271008692248528, -0.000289267818693655,\n    -0.000306218526978132, -0.00032186831514079, -0.000336226461234486,\n    -0.000349303983680105, -0.000361113599498608, -0.000371669680512089,\n    -0.000380988207606948, -0.00038908672315418, -0.00039598428168354,\n    -0.000401701398909919, -0.000406259999211655, -0.000409683361661765,\n    -0.00041199606471408, -0.000413223929647223, -0.000413393962869987,\n    -0.000412534297192291, -0.000410674132166183, -0.000407843673601605,\n    -0.000404074072361604, -0.000399397362541602, -0.000393846399136942,\n    -0.000387454795302522, -0.000380256859307689, -0.000372287531288722,\n    -0.000363582319900374, -0.000354177238966773, -0.000344108744230797,\n    -0.000333413670299596, -0.000322129167882484, -0.000310292641415675,\n    -0.000297941687166617, -0.000285114031908709, -0.000271847472255163,\n    -0.000258179814738611, -0.000244148816720784, -0.000229792128214169,\n    -0.000215147234695133, -0.00020025140098535, -0.000185141616275717,\n    -0.000169854540364182, -0.000154426451176078, -0.00013889319363255,\n    -0.000123290129929803, -0.000107652091288701, -9.20133312312316E-5,\n    -7.64074804371047E-5, -6.08675032306165E-5, -4.54256557445348E-5,\n    -3.01134458045921E-5, -1.49615945747347E-5, -2.89570102206907E-19,\n    1.47422979195256E-5, 2.92371499935482E-5, 4.34573288185537E-5,\n    5.73765578435795E-5, 7.09695385048991E-5, 8.42119754130424E-5,\n    9.7080599579001E-5, 0.00010955318966974, 0.000121608591286549,\n    0.000133226734262944, 0.000144388647982165, 0.000155076474717484,\n    0.000165273481001697, 0.0001749640670353, 0.000184133774145895,\n    0.000192769290314387, 0.000200858453786435, 0.000208390254790512,\n    0.000215354835386701, 0.000221743487473104, 0.000227548648979331,\n    0.000232763898279138, 0.000237383946856721, 0.00024140463026357,\n    0.000244822897405062, 0.00024763679819818, 0.000249845469643829,\n    0.000251449120359227, 0.000252449013617722, 0.000252847448945224,\n    0.000252647742324057, 0.000251854205056692, 0.000250472121343227,\n    0.000248507724627882, 0.000245968172771024, 0.000242861522104343,\n    0.000239196700427884, 0.000234983479008503, 0.000230232443640159,\n    0.000224954964827125, 0.000219163167151782, 0.000212869897889143,\n    0.000206088694930604, 0.000198833754079658, 0.000191119895782473,\n    0.000182962531356236, 0.000174377628778114, 0.000165381678097493,\n    0.00015599165653388, 0.000146224993322452, 0.00013609953436877,\n    0.000125633506773593, 0.00011484548328803, 0.00010375434675853,\n    9.23792546203174E-5, 8.07396034969619E-5, 6.88549939627184E-5,\n    5.67451955231691E-5, 4.44301118684996E-5, 3.19297464524893E-5,\n    1.92641684489213E-5, 6.45347913574842E-6, -6.48222124416269E-6,\n    -1.95228660984025E-5, -3.26484545308114E-5, -4.58390827736315E-5,\n    -5.90749749637039E-5, -7.23365132220933E-5, -8.56042669983775E-5,\n    -9.88590216426344E-5, -0.000112081806170066, -0.000125253920185076,\n    -0.000138356959933597, -0.000151372843454383, -0.000164283834802009,\n    -0.000177072567316285, -0.000189722065914846, -0.000202215768387676,\n    -0.000214537545674379, -0.000226671721107042, -0.000238603088603566,\n    -0.000250316929798388, -0.000261799030099529, -0.000273035693662904,\n    -0.00028401375727689, -0.000294720603152018, -0.000305144170612759,\n    -0.000315272966690158, -0.000325096075616101, -0.00033460316722179,\n    -0.000343784504244919, -0.000352630948551759, -0.000361133966282231,\n    -0.000369285631927676, -0.000377078631352787, -0.000384506263774744,\n    -0.000391562442714227, -0.000398241695934472, -0.00040453916438606,\n    -0.000410450600176512, -0.000415972363585155, -0.000421101419145048,\n    -0.000425835330814964, -0.000430172256265661, -0.000434110940305761,\n    -0.000437650707473649, -0.000440791453822779, -0.000443533637928715,\n    -0.000445878271147096, -0.000447826907152526, -0.000449381630789087,\n    -0.000450545046263876, -0.000451320264715525, -0.000451710891190224,\n    -0.000451721011058181, -0.000451355175903889, -0.000450618388923862,\n    -0.000449516089865765, -0.000448054139543056, -0.00044623880395937,\n    -0.000444076738076955, -0.000441574969263422, -0.000438740880451056,\n    -0.000435582193042744, -0.000432106949598435, -0.00042832349633576,\n    -0.000424240465478137, -0.000419866757483334, -0.000415211523185017,\n    -0.000410284145879348, -0.000405094223388176, -0.000399651550129767,\n    -0.000393966099227414, -0.000388048004685588, -0.000381907543662574,\n    -0.000375555118867786, -0.000369001241111159, -0.000362256512031173,\n    -0.000355331607027209, -0.000348237258421025, -0.000340984238871217,\n    -0.00033358334506356, -0.000326045381699152, -0.000318381145801259,\n    -0.000310601411360734, -0.000302716914338852, -0.000294738338045302,\n    -0.000286676298908029, -0.000278541332650522, -0.000270343880891021,\n    -0.000262094278177049, -0.000253802739467532, -0.000245479348073666,\n    -0.000237134044068595, -0.000228776613174815, -0.000220416676137166,\n    -0.000212063678588118, -0.000203726881411025, -0.000195415351605887,\n    -0.00018713795366115, -0.000178903341433976, -0.00017071995054041,\n    -0.000162595991255854, -0.000154539441925259, -0.000146558042881469,\n    -0.000138659290869229, -0.000130850433971418, -0.000123138467033194,\n    -0.000115530127578867, -0.000108031892215478, -0.000100649973516263,\n    -9.33903173764076E-5, -8.62586008327578E-5, -7.92602303384457E-5,\n    -7.24003404827332E-5, -6.56837931457214E-5, -5.91151770770133E-5,\n    -5.26988078868132E-5, -4.64387284374705E-5, -4.03387096229618E-5,\n    -3.44022515233885E-5, -2.86325849211373E-5, -2.30326731650107E-5,\n    -1.76052143682957E-5, -1.23526439264607E-5, -7.277137339921E-6,\n    -2.38061332710547E-6, 2.33526278709564E-6, 6.86907542257971E-6,\n    1.12196548501132E-5, 1.53860730674611E-5, 1.93676394607737E-5,\n    2.3163896266439E-5, 2.67746138485385E-5, 3.01997858069561E-5,\n    3.343962393107E-5, 3.64945530137878E-5, 3.93652055405077E-5,\n    4.20524162673526E-5, 4.45572167027813E-5, 4.68808295063986E-5,\n    4.90246628184729E-5, 5.09903045333425E-5, 5.27795165295223E-5,\n    5.43942288689521E-5, 5.58365339774059E-5, 5.71086808176713E-5,\n    5.82130690666487E-5, 5.91522433070664E-5, 5.99288872440181E-5,\n    6.05458179560438E-5, 6.10059801899582E-5, 6.13124407081177E-5,\n    6.14683826962815E-5, 6.14771002396855E-5, 6.13419928744055E-5,\n    6.10665602205273E-5, 6.06543967030956E-5, 6.01091863662453E-5,\n    5.94346977853764E-5, 5.86347790816568E-5, 5.7713353042602E-5,\n    5.66744123519132E-5, 5.55220149312262E-5, 5.42602793958663E-5,\n    5.28933806261883E-5, 5.14255454555536E-5, 4.98610484754855E-5,\n    4.82042079580479E-5, 4.64593818950024E-5, 4.46309641528412E-5,\n    4.27233807423181E-5, 4.0741086200686E-5, 3.86885600844072E-5,\n    3.65703035697221E-5, 3.43908361580643E-5, 3.21546924829572E-5,\n    2.98664192146919E-5, 2.75305720587617E-5, 2.51517128437406E-5,\n    2.2734406694019E-5, 2.02832192825685E-5, 1.78027141586849E-5,\n    1.52974501454567E-5, 1.27719788015466E-5, 1.02308419417135E-5,\n    7.67856921040619E-6, 5.11967570263367E-6, 2.55865962628471E-6,\n    7.47277683114599E-20 },\n\n  /* Expression: 0.03\n   * Referenced by: '<Root>/Thrd'\n   */\n  0.03,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Memory11'\n   */\n  0.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Memory7'\n   */\n  0.0,\n\n  /* Expression: 1\n   * Referenced by: '<Root>/Memory3'\n   */\n  1.0,\n\n  /* Expression: 1\n   * Referenced by: '<Root>/Memory4'\n   */\n  1.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Memory9'\n   */\n  0.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Memory5'\n   */\n  0.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Memory6'\n   */\n  0.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Memory10'\n   */\n  0.0,\n\n  /* Computed Parameter: Analogoutput_P1_Size\n   * Referenced by: '<Root>/Analog output '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parModuleId\n   * Referenced by: '<Root>/Analog output '\n   */\n  1.0,\n\n  /* Computed Parameter: Analogoutput_P2_Size\n   * Referenced by: '<Root>/Analog output '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parSampleTime\n   * Referenced by: '<Root>/Analog output '\n   */\n  -1.0,\n\n  /* Computed Parameter: Analogoutput_P3_Size\n   * Referenced by: '<Root>/Analog output '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parPciSlot\n   * Referenced by: '<Root>/Analog output '\n   */\n  -1.0,\n\n  /* Computed Parameter: Analogoutput_P4_Size\n   * Referenced by: '<Root>/Analog output '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parDacChannels\n   * Referenced by: '<Root>/Analog output '\n   */\n  { 1.0, 3.0 },\n\n  /* Computed Parameter: Analogoutput_P5_Size\n   * Referenced by: '<Root>/Analog output '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parDacRanges\n   * Referenced by: '<Root>/Analog output '\n   */\n  { 4.0, 4.0 },\n\n  /* Computed Parameter: Analogoutput_P6_Size\n   * Referenced by: '<Root>/Analog output '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parDacInitValues\n   * Referenced by: '<Root>/Analog output '\n   */\n  { 0.0, 0.0 },\n\n  /* Computed Parameter: Analogoutput_P7_Size\n   * Referenced by: '<Root>/Analog output '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parDacResets\n   * Referenced by: '<Root>/Analog output '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: 1\n   * Referenced by: '<Root>/Whisker Trig'\n   */\n  1.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Whisker Trig'\n   */\n  0.0,\n\n  /* Expression: 2.5\n   * Referenced by: '<Root>/Npxls Trig'\n   */\n  2.5,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Npxls Trig'\n   */\n  0.0,\n\n  /* Expression: 1\n   * Referenced by: '<Root>/Pupil Trig'\n   */\n  1.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Pupil Trig'\n   */\n  0.0,\n\n  /* Expression: 1\n   * Referenced by: '<S5>/Constant4'\n   */\n  1.0,\n\n  /* Computed Parameter: Digitaloutput_P1_Size\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parModuleId\n   * Referenced by: '<Root>/Digital output '\n   */\n  1.0,\n\n  /* Computed Parameter: Digitaloutput_P2_Size\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parSampleTime\n   * Referenced by: '<Root>/Digital output '\n   */\n  0.001,\n\n  /* Computed Parameter: Digitaloutput_P3_Size\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parPciSlot\n   * Referenced by: '<Root>/Digital output '\n   */\n  -1.0,\n\n  /* Computed Parameter: Digitaloutput_P4_Size\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 15.0 },\n\n  /* Expression: parDoChannels\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 15.0,\n    16.0 },\n\n  /* Computed Parameter: Digitaloutput_P5_Size\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 15.0 },\n\n  /* Expression: parDoInitValues\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },\n\n  /* Computed Parameter: Digitaloutput_P6_Size\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 15.0 },\n\n  /* Expression: parDoResets\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },\n\n  /* Computed Parameter: Digitalinput_P1_Size\n   * Referenced by: '<Root>/Digital input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parModuleId\n   * Referenced by: '<Root>/Digital input '\n   */\n  1.0,\n\n  /* Computed Parameter: Digitalinput_P2_Size\n   * Referenced by: '<Root>/Digital input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parSampleTime\n   * Referenced by: '<Root>/Digital input '\n   */\n  0.001,\n\n  /* Computed Parameter: Digitalinput_P3_Size\n   * Referenced by: '<Root>/Digital input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parPciSlot\n   * Referenced by: '<Root>/Digital input '\n   */\n  -1.0,\n\n  /* Computed Parameter: Digitalinput_P4_Size\n   * Referenced by: '<Root>/Digital input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parDiChannels\n   * Referenced by: '<Root>/Digital input '\n   */\n  14.0\n};\n\nATTN_cal_type *ATTN_cal = &ATTN_cal_impl;\n"},{"name":"ATTN_cal.h","type":"header","group":"data","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Data files","code":"#ifndef RTW_HEADER_ATTN_cal_h_\n#define RTW_HEADER_ATTN_cal_h_\n#include \"rtwtypes.h\"\n\n/* Storage class 'PageSwitching', for system '<Root>' */\nstruct ATTN_cal_type {\n  real_T SampleTime;                   /* Variable: SampleTime\n                                        * Referenced by: '<Root>/SampleTime'\n                                        */\n  real_T T_npxls;                      /* Variable: T_npxls\n                                        * Referenced by: '<Root>/Npxls Trig'\n                                        */\n  real_T T_pupil;                      /* Variable: T_pupil\n                                        * Referenced by: '<Root>/Pupil Trig'\n                                        */\n  real_T T_whisk;                      /* Variable: T_whisk\n                                        * Referenced by: '<Root>/Whisker Trig'\n                                        */\n  real_T maxFrame;                     /* Variable: maxFrame\n                                        * Referenced by: '<Root>/Constant'\n                                        */\n  real_T rewardDuration;               /* Variable: rewardDuration\n                                        * Referenced by: '<Root>/rewardDuration'\n                                        */\n  real_T targetSide;                   /* Variable: targetSide\n                                        * Referenced by: '<Root>/targetSide'\n                                        */\n  real_T trainingStage;                /* Variable: trainingStage\n                                        * Referenced by: '<Root>/trainingStage'\n                                        */\n  real_T triangleAmplitude;            /* Variable: triangleAmplitude\n                                        * Referenced by: '<Root>/triangleAmplitude'\n                                        */\n  real_T triangleDuration;             /* Variable: triangleDuration\n                                        * Referenced by: '<Root>/triangleDuration'\n                                        */\n  real_T Memory8_InitialCondition;     /* Expression: 0\n                                        * Referenced by: '<Root>/Memory8'\n                                        */\n  real_T Memory2_InitialCondition;     /* Expression: 1\n                                        * Referenced by: '<Root>/Memory2'\n                                        */\n  real_T Memory1_InitialCondition;     /* Expression: 0\n                                        * Referenced by: '<Root>/Memory1'\n                                        */\n  real_T Memory_InitialCondition;      /* Expression: 0\n                                        * Referenced by: '<Root>/Memory'\n                                        */\n  real_T Setup_P1_Size[2];             /* Computed Parameter: Setup_P1_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P1;                     /* Expression: parPciSlot\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P2_Size[2];             /* Computed Parameter: Setup_P2_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P2;                     /* Expression: parModuleId\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P3_Size[2];             /* Computed Parameter: Setup_P3_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P3;                     /* Expression: parTriggerSignal\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P4_Size[2];             /* Computed Parameter: Setup_P4_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P4[2];                  /* Expression: parAdcChannels\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P5_Size[2];             /* Computed Parameter: Setup_P5_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P5;                     /* Expression: parAdcMode\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P6_Size[2];             /* Computed Parameter: Setup_P6_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P6[2];                  /* Expression: parAdcRanges\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P7_Size[2];             /* Computed Parameter: Setup_P7_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P7[2];                  /* Expression: parDacChannels\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P8_Size[2];             /* Computed Parameter: Setup_P8_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P8[2];                  /* Expression: parDacRanges\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P9_Size[2];             /* Computed Parameter: Setup_P9_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P9[8];                  /* Expression: parDioFirstControl\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Analoginput_P1_Size[2];      /* Computed Parameter: Analoginput_P1_Size\n                                       * Referenced by: '<Root>/Analog input '\n                                       */\n  real_T Analoginput_P1;               /* Expression: parModuleId\n                                        * Referenced by: '<Root>/Analog input '\n                                        */\n  real_T Analoginput_P2_Size[2];      /* Computed Parameter: Analoginput_P2_Size\n                                       * Referenced by: '<Root>/Analog input '\n                                       */\n  real_T Analoginput_P2;               /* Expression: parSampleTime\n                                        * Referenced by: '<Root>/Analog input '\n                                        */\n  real_T Analoginput_P3_Size[2];      /* Computed Parameter: Analoginput_P3_Size\n                                       * Referenced by: '<Root>/Analog input '\n                                       */\n  real_T Analoginput_P3;               /* Expression: parPciSlot\n                                        * Referenced by: '<Root>/Analog input '\n                                        */\n  real_T Analoginput_P4_Size[2];      /* Computed Parameter: Analoginput_P4_Size\n                                       * Referenced by: '<Root>/Analog input '\n                                       */\n  real_T Analoginput_P4[2];            /* Expression: parAdcChannels\n                                        * Referenced by: '<Root>/Analog input '\n                                        */\n  real_T Analoginput_P5_Size[2];      /* Computed Parameter: Analoginput_P5_Size\n                                       * Referenced by: '<Root>/Analog input '\n                                       */\n  real_T Analoginput_P5;               /* Expression: parAdcMode\n                                        * Referenced by: '<Root>/Analog input '\n                                        */\n  real_T Analoginput_P6_Size[2];      /* Computed Parameter: Analoginput_P6_Size\n                                       * Referenced by: '<Root>/Analog input '\n                                       */\n  real_T Analoginput_P6;               /* Expression: parAdcRate\n                                        * Referenced by: '<Root>/Analog input '\n                                        */\n  real_T Analoginput_P7_Size[2];      /* Computed Parameter: Analoginput_P7_Size\n                                       * Referenced by: '<Root>/Analog input '\n                                       */\n  real_T Analoginput_P7[2];            /* Expression: parAdcRanges\n                                        * Referenced by: '<Root>/Analog input '\n                                        */\n  real_T Analoginput_P8_Size[2];      /* Computed Parameter: Analoginput_P8_Size\n                                       * Referenced by: '<Root>/Analog input '\n                                       */\n  real_T Analoginput_P8[2];            /* Expression: parAdcInitValues\n                                        * Referenced by: '<Root>/Analog input '\n                                        */\n  real_T Analoginput_P9_Size[2];      /* Computed Parameter: Analoginput_P9_Size\n                                       * Referenced by: '<Root>/Analog input '\n                                       */\n  real_T Analoginput_P9[2];            /* Expression: parAdcResets\n                                        * Referenced by: '<Root>/Analog input '\n                                        */\n  real_T DiscreteFIRFilter1_InitialState;/* Expression: 0\n                                          * Referenced by: '<Root>/Discrete FIR Filter1'\n                                          */\n  real_T DiscreteFIRFilter1_Coefficients[1501];\n  /* Expression: [7.47277683114599e-20\t2.55865962628471e-06\t5.11967570263367e-06\t7.67856921040619e-06\t1.02308419417135e-05\t1.27719788015466e-05\t1.52974501454567e-05\t1.78027141586849e-05\t2.02832192825685e-05\t2.27344066940190e-05\t2.51517128437406e-05\t2.75305720587617e-05\t2.98664192146919e-05\t3.21546924829572e-05\t3.43908361580643e-05\t3.65703035697221e-05\t3.86885600844072e-05\t4.07410862006860e-05\t4.27233807423181e-05\t4.46309641528412e-05\t4.64593818950024e-05\t4.82042079580479e-05\t4.98610484754855e-05\t5.14255454555536e-05\t5.28933806261883e-05\t5.42602793958663e-05\t5.55220149312262e-05\t5.66744123519132e-05\t5.77133530426020e-05\t5.86347790816568e-05\t5.94346977853764e-05\t6.01091863662453e-05\t6.06543967030956e-05\t6.10665602205273e-05\t6.13419928744055e-05\t6.14771002396855e-05\t6.14683826962815e-05\t6.13124407081177e-05\t6.10059801899582e-05\t6.05458179560438e-05\t5.99288872440181e-05\t5.91522433070664e-05\t5.82130690666487e-05\t5.71086808176713e-05\t5.58365339774059e-05\t5.43942288689521e-05\t5.27795165295223e-05\t5.09903045333425e-05\t4.90246628184729e-05\t4.68808295063986e-05\t4.45572167027813e-05\t4.20524162673526e-05\t3.93652055405077e-05\t3.64945530137878e-05\t3.34396239310700e-05\t3.01997858069561e-05\t2.67746138485385e-05\t2.31638962664390e-05\t1.93676394607737e-05\t1.53860730674611e-05\t1.12196548501132e-05\t6.86907542257971e-06\t2.33526278709564e-06\t-2.38061332710547e-06\t-7.27713733992100e-06\t-1.23526439264607e-05\t-1.76052143682957e-05\t-2.30326731650107e-05\t-2.86325849211373e-05\t-3.44022515233885e-05\t-4.03387096229618e-05\t-4.64387284374705e-05\t-5.26988078868132e-05\t-5.91151770770133e-05\t-6.56837931457214e-05\t-7.24003404827332e-05\t-7.92602303384457e-05\t-8.62586008327578e-05\t-9.33903173764076e-05\t-0.000100649973516263\t-0.000108031892215478\t-0.000115530127578867\t-0.000123138467033194\t-0.000130850433971418\t-0.000138659290869229\t-0.000146558042881469\t-0.000154539441925259\t-0.000162595991255854\t-0.000170719950540410\t-0.000178903341433976\t-0.000187137953661150\t-0.000195415351605887\t-0.000203726881411025\t-0.000212063678588118\t-0.000220416676137166\t-0.000228776613174815\t-0.000237134044068595\t-0.000245479348073666\t-0.000253802739467532\t-0.000262094278177049\t-0.000270343880891021\t-0.000278541332650522\t-0.000286676298908029\t-0.000294738338045302\t-0.000302716914338852\t-0.000310601411360734\t-0.000318381145801259\t-0.000326045381699152\t-0.000333583345063560\t-0.000340984238871217\t-0.000348237258421025\t-0.000355331607027209\t-0.000362256512031173\t-0.000369001241111159\t-0.000375555118867786\t-0.000381907543662574\t-0.000388048004685588\t-0.000393966099227414\t-0.000399651550129767\t-0.000405094223388176\t-0.000410284145879348\t-0.000415211523185017\t-0.000419866757483334\t-0.000424240465478137\t-0.000428323496335760\t-0.000432106949598435\t-0.000435582193042744\t-0.000438740880451056\t-0.000441574969263422\t-0.000444076738076955\t-0.000446238803959370\t-0.000448054139543056\t-0.000449516089865765\t-0.000450618388923862\t-0.000451355175903889\t-0.000451721011058181\t-0.000451710891190224\t-0.000451320264715525\t-0.000450545046263876\t-0.000449381630789087\t-0.000447826907152526\t-0.000445878271147096\t-0.000443533637928715\t-0.000440791453822779\t-0.000437650707473649\t-0.000434110940305761\t-0.000430172256265661\t-0.000425835330814964\t-0.000421101419145048\t-0.000415972363585155\t-0.000410450600176512\t-0.000404539164386060\t-0.000398241695934472\t-0.000391562442714227\t-0.000384506263774744\t-0.000377078631352787\t-0.000369285631927676\t-0.000361133966282231\t-0.000352630948551759\t-0.000343784504244919\t-0.000334603167221790\t-0.000325096075616101\t-0.000315272966690158\t-0.000305144170612759\t-0.000294720603152018\t-0.000284013757276890\t-0.000273035693662904\t-0.000261799030099529\t-0.000250316929798388\t-0.000238603088603566\t-0.000226671721107042\t-0.000214537545674379\t-0.000202215768387676\t-0.000189722065914846\t-0.000177072567316285\t-0.000164283834802009\t-0.000151372843454383\t-0.000138356959933597\t-0.000125253920185076\t-0.000112081806170066\t-9.88590216426344e-05\t-8.56042669983775e-05\t-7.23365132220933e-05\t-5.90749749637039e-05\t-4.58390827736315e-05\t-3.26484545308114e-05\t-1.95228660984025e-05\t-6.48222124416269e-06\t6.45347913574842e-06\t1.92641684489213e-05\t3.19297464524893e-05\t4.44301118684996e-05\t5.67451955231691e-05\t6.88549939627184e-05\t8.07396034969619e-05\t9.23792546203174e-05\t0.000103754346758530\t0.000114845483288030\t0.000125633506773593\t0.000136099534368770\t0.000146224993322452\t0.000155991656533880\t0.000165381678097493\t0.000174377628778114\t0.000182962531356236\t0.000191119895782473\t0.000198833754079658\t0.000206088694930604\t0.000212869897889143\t0.000219163167151782\t0.000224954964827125\t0.000230232443640159\t0.000234983479008503\t0.000239196700427884\t0.000242861522104343\t0.000245968172771024\t0.000248507724627882\t0.000250472121343227\t0.000251854205056692\t0.000252647742324057\t0.000252847448945224\t0.000252449013617722\t0.000251449120359227\t0.000249845469643829\t0.000247636798198180\t0.000244822897405062\t0.000241404630263570\t0.000237383946856721\t0.000232763898279138\t0.000227548648979331\t0.000221743487473104\t0.000215354835386701\t0.000208390254790512\t0.000200858453786435\t0.000192769290314387\t0.000184133774145895\t0.000174964067035300\t0.000165273481001697\t0.000155076474717484\t0.000144388647982165\t0.000133226734262944\t0.000121608591286549\t0.000109553189669740\t9.70805995790010e-05\t8.42119754130424e-05\t7.09695385048991e-05\t5.73765578435795e-05\t4.34573288185537e-05\t2.92371499935482e-05\t1.47422979195256e-05\t-2.89570102206907e-19\t-1.49615945747347e-05\t-3.01134458045921e-05\t-4.54256557445348e-05\t-6.08675032306165e-05\t-7.64074804371047e-05\t-9.20133312312316e-05\t-0.000107652091288701\t-0.000123290129929803\t-0.000138893193632550\t-0.000154426451176078\t-0.000169854540364182\t-0.000185141616275717\t-0.000200251400985350\t-0.000215147234695133\t-0.000229792128214169\t-0.000244148816720784\t-0.000258179814738611\t-0.000271847472255163\t-0.000285114031908709\t-0.000297941687166617\t-0.000310292641415675\t-0.000322129167882484\t-0.000333413670299596\t-0.000344108744230797\t-0.000354177238966773\t-0.000363582319900374\t-0.000372287531288722\t-0.000380256859307689\t-0.000387454795302522\t-0.000393846399136942\t-0.000399397362541602\t-0.000404074072361604\t-0.000407843673601605\t-0.000410674132166183\t-0.000412534297192291\t-0.000413393962869987\t-0.000413223929647223\t-0.000411996064714080\t-0.000409683361661765\t-0.000406259999211655\t-0.000401701398909919\t-0.000395984281683540\t-0.000389086723154180\t-0.000380988207606948\t-0.000371669680512089\t-0.000361113599498608\t-0.000349303983680105\t-0.000336226461234486\t-0.000321868315140790\t-0.000306218526978132\t-0.000289267818693655\t-0.000271008692248528\t-0.000251435467053209\t-0.000230544315105724\t-0.000208333293749184\t-0.000184802375967652\t-0.000159953478142262\t-0.000133790485192674\t-0.000106319273032093\t-7.75477282675384e-05\t-4.74857650804866e-05\t-1.61453392267853e-05\t1.64595409015606e-05\t5.03128062061118e-05\t8.53963218525767e-05\t0.000121689885327374\t0.000159171227621052\t0.000197816017574914\t0.000237597869422766\t0.000278488353555005\t0.000320457010527570\t0.000363471368333427\t0.000407496962949437\t0.000452497362166358\t0.000498434192704850\t0.000545267170615130\t0.000592954134952790\t0.000641451084718191\t0.000690712219041478\t0.000740689980590114\t0.000791335102170428\t0.000842596656489554\t0.000894422109038610\t0.000946757374052876\t0.000999546873499304\t0.00105273359903652\t0.00110625917688716\t0.00116006393555726\t0.00121408697633218\t0.00126826624647365\t0.00132253861503705\t0.00137683995122370\t0.00143110520517742\t0.00148526849113038\t0.00153926317279804\t0.00159302195091886\t0.00164647695282973\t0.00169955982396365\t0.00175220182115219\t0.00180433390761108\t0.00185588684948312\t0.00190679131380927\t0.00195697796779464\t0.00200637757923311\t0.00205492111795062\t0.00210253985812430\t0.00214916548133170\t0.00219473018018159\t0.00223916676237516\t0.00228240875504447\t0.00232439050921261\t0.00236504730421813\t0.00240431545194501\t0.00244213240069747\t0.00247843683855824\t0.00251316879606750\t0.00254626974805942\t0.00257768271449228\t0.00260735236010835\t0.00263522509275942\t0.00266124916023432\t0.00268537474542521\t0.00270755405967022\t0.00272774143411101\t0.00274589340890530\t0.00276196882013560\t0.00277592888425765\t0.00278773727993376\t0.00279736022709874\t0.00280476656310870\t0.00280992781582576\t0.00281281827349487\t0.00281341505127220\t0.00281169815426827\t0.00280765053697264\t0.00280125815893131\t0.00279251003655189\t0.00278139829091669\t0.00276791819148808\t0.00275206819559587\t0.00273384998360153\t0.00271326848963936\t0.00269033192784063\t0.00266505181395229\t0.00263744298226794\t0.00260752359779501\t0.00257531516358838\t0.00254084252318727\t0.00250413385809899\t0.00246522068027977\t0.00242413781957023\t0.00238092340604986\t0.00233561884728230\t0.00228826880043062\t0.00223892113922903\t0.00218762691580539\t0.00213444031735612\t0.00207941861768317\t0.00202262212361024\t0.00196411411630350\t0.00190396078752973\t0.00184223117089264\t0.00177899706809648\t0.00171433297029328\t0.00164831597457857\t0.00158102569570795\t0.00151254417311495\t0.00144295577331810\t0.00137234708781338\t0.00130080682655538\t0.00122842570713851\t0.00115529633979676\t0.00108151310834823\t0.00100717204721764\t0.000932370714677483\t0.000857208062455200\t0.000781784301860790\t0.000706200766596011\t0.000630559772412639\t0.000554964473793834\t0.000479518717838589\t0.000404326895535311\t0.000329493790616252\t0.000255124426189886\t0.000181323909353765\t0.000108197273995199\t3.58493219919046e-05\t-3.56155369707369e-05\t-0.000106093446745042\t-0.000175481267004346\t-0.000243676736235937\t-0.000310578635212037\t-0.000376086950704255\t-0.000440103039204209\t-0.000502529790410721\t-0.000563271790241955\t-0.000622235483129130\t-0.000679329333347147\t-0.000734463985136471\t-0.000787552421369875\t-0.000838510120517479\t-0.000887255211663436\t-0.000933708627328164\t-0.000977794253850711\t-0.00101943907908703\t-0.00105857333718142\t-0.00109513065017034\t-0.00112904816617986\t-0.00116026669398096\t-0.00118873083366949\t-0.00121438910324108\t-0.00123719406083525\t-0.00125710242242660\t-0.00127407517474559\t-0.00128807768321635\t-0.00129907979470377\t-0.00130705593486782\t-0.00131198519992874\t-0.00131385144265302\t-0.00131264335237627\t-0.00130835452888634\t-0.00130098354999660\t-0.00129053403264728\t-0.00127701468737988\t-0.00126043936603828\t-0.00124082710255787\t-0.00121820214671305\t-0.00119259399070198\t-0.00116403738845660\t-0.00113257236757519\t-0.00109824423378450\t-0.00106110356784778\t-0.00102120621484539\t-0.000978613265764647\t-0.000933391031345854\t-0.000885611008141868\t-0.000835349836759427\t-0.000782689252260949\t-0.000727716026716505\t-0.000670521903906705\t-0.000611203526188236\t-0.000549862353544915\t-0.000486604574858484\t-0.000421541011444480\t-0.000354787012909843\t-0.000286462345400301\t-0.000216691072316808\t-0.000145601427591550\t-7.33256816254293e-05\t7.19254769997801e-19\t7.42357049120248e-05\t0.000149237929302405\t0.000224859740103052\t0.000300950943824790\t0.000377358261891444\t0.000453925512291049\t0.000530493797355587\t0.000606901697470346\t0.000682985470504074\t0.000758579256741336\t0.000833515289088735\t0.000907624108317507\t0.000980734783095885\t0.00105267513455570\t0.00112327196512931\t0.00119235129138475\t0.00125973858057888\t0.00132525899064098\t0.00138873761329188\t0.00144999971999680\t0.00150887101044373\t0.00156517786323271\t0.00161874758845597\t0.00166940868184338\t0.00171699108014261\t0.00176132641739902\t0.00180224828179624\t0.00183959247271447\t0.00187319725766064\t0.00190290362872159\t0.00192855555818921\t0.00195000025300448\t0.00196708840766637\t0.00197967445525011\t0.00198761681617943\t0.00199077814439713\t0.00198902557057900\t0.00198223094203719\t0.00197027105896066\t0.00195302790664221\t0.00193038888334449\t0.00190224702345992\t0.00186850121562344\t0.00182905641544065\t0.00178382385249867\t0.00173272123133173\t0.00167567292601933\t0.00161261016810032\t0.00154347122749315\t0.00146820158611887\t0.00138675410393134\t0.00129908917706644\t0.00120517488783061\t0.00110498714625756\t0.000998509822971181\t0.000885734873102136\t0.000766662451015514\t0.000641301015617403\t0.000509667426018673\t0.000371787027345634\t0.000227693726498400\t7.74300576697443e-05\t-7.89527625507157e-05\t-0.000241394790649771\t-0.000409827322391340\t-0.000584172869881566\t-0.000764345149622112\t-0.000950249081661772\t-0.00114178079994279\t-0.00133882767392432\t-0.00154126834155127\t-0.00174897275362225\t-0.00196180222959601\t-0.00217960952486101\t-0.00240223890947765\t-0.00262952625838842\t-0.00286129915307534\t-0.00309737699462987\t-0.00333757112818460\t-0.00358168497864140\t-0.00382951419761518\t-0.00408084682149751\t-0.00433546344052907\t-0.00459313737875492\t-0.00485363488472152\t-0.00511671533275963\t-0.00538213143468235\t-0.00564962946171290\t-0.00591894947644237\t-0.00618982557460332\t-0.00646198613643080\t-0.00673515408736880\t-0.00700904716786624\t-0.00728337821199327\t-0.00755785543459555\t-0.00783218272669133\t-0.00810605995880358\t-0.00837918329190739\t-0.00865124549566087\t-0.00892193627357631\t-0.00919094259477741\t-0.00945794903197762\t-0.00972263810530438\t-0.00998469063158416\t-0.0102437860786940\t-0.0104996029245761\t-0.0107518190205037\t-0.0110001119581790\t-0.0112441594402344\t-0.0114836396537058\t-0.0117182316460343\t-0.0119476157031521\t-0.0121714737292003\t-0.0123894896274222\t-0.0126013496817715\t-0.0128067429387710\t-0.0130053615891551\t-0.0131969013488267\t-0.0133810618386553\t-0.0135575469626461\t-0.0137260652840050\t-0.0138863303986269\t-0.0140380613055336\t-0.0141809827737919\t-0.0143148257054396\t-0.0144393274939538\t-0.0145542323777966\t-0.0146592917885783\t-0.0147542646933807\t-0.0148389179307901\t-0.0149130265401937\t-0.0149763740838996\t-0.0150287529616470\t-0.0150699647170814\t-0.0150998203357757\t-0.0151181405343887\t-0.0151247560405597\t-0.0151195078631481\t-0.0151022475524371\t-0.0150728374499309\t-0.0150311509273870\t-0.0149770726147340\t-0.0149104986165412\t-0.0148313367167168\t-0.0147395065711232\t-0.0146349398878158\t-0.0145175805946200\t-0.0143873849937804\t-0.0142443219034289\t-0.0140883727856319\t-0.0139195318607958\t-0.0137378062082235\t-0.0135432158526313\t-0.0133357938364516\t-0.0131155862777654\t-0.0128826524137235\t-0.0126370646293330\t-0.0123789084715050\t-0.0121082826482743\t-0.0118252990131225\t-0.0115300825343511\t-0.0112227712494722\t-0.0109035162046009\t-0.0105724813788522\t-0.0102298435937630\t-0.00987579240778032\t-0.00951052999587282\t-0.00913427101434232\t-0.00874724245093055\t-0.00834968346033439\t-0.00794184518526101\t-0.00752399056317267\t-0.00709639411888902\t-0.00665934174323227\t-0.00621313045791866\t-0.00575806816691683\t-0.00529447339451106\t-0.00482267501032449\t-0.00434301194157384\t-0.00385583287284378\t-0.00336149593368541\t-0.00286036837435846\t-0.00235282623005320\t-0.00183925397394197\t-0.00132004415942586\t-0.000795597051955804\t-0.000266320250821043\t0.000267371698688395\t0.000805057702325976\t0.00134631052270810\t0.00189069719346513\t0.00243777944126920\t0.00298711411527345\t0.00353825362348642\t0.00409074637559677\t0.00464413723175339\t0.00519796795679813\t0.00575177767944047\t0.00630510335585588\t0.00685748023718350\t0.00740844234039260\t0.00795752292198173\t0.00850425495397047\t0.00904817160163901\t0.00958880670246806\t0.0101256952457286\t0.0106583738521692\t0.0111863812532474\t0.0117092587693513\t0.0122265507864565\t0.0127378052306666\t0.0132425740400844\t0.0137404136334652\t0.0142308853751047\t0.0147135560354200\t0.0151879982466835\t0.0156537909533765\t0.0161105198566348\t0.0165577778522639\t0.0169951654618083\t0.0174222912561690\t0.0178387722712688\t0.0182442344152751\t0.0186383128669006\t0.0190206524643096\t0.0193909080841709\t0.0197487450104079\t0.0200938392922097\t0.0204258780908776\t0.0207445600150963\t0.0210495954442313\t0.0213407068392676\t0.0216176290410214\t0.0218801095552688\t0.0221279088244518\t0.0223608004856395\t0.0225785716144351\t0.0227810229545396\t0.0229679691326971\t0.0231392388587654\t0.0232946751106741\t0.0234341353040481\t0.0235574914462940\t0.0236646302749659\t0.0237554533802449\t0.0238298773113860\t0.0238878336670043\t0.0239292691690938\t0.0239541457206896\t0.0239624404471043\t0.0239541457206896\t0.0239292691690938\t0.0238878336670043\t0.0238298773113860\t0.0237554533802449\t0.0236646302749659\t0.0235574914462940\t0.0234341353040481\t0.0232946751106741\t0.0231392388587654\t0.0229679691326971\t0.0227810229545396\t0.0225785716144351\t0.0223608004856395\t0.0221279088244518\t0.0218801095552688\t0.0216176290410214\t0.0213407068392676\t0.0210495954442313\t0.0207445600150963\t0.0204258780908776\t0.0200938392922097\t0.0197487450104079\t0.0193909080841709\t0.0190206524643096\t0.0186383128669006\t0.0182442344152751\t0.0178387722712688\t0.0174222912561690\t0.0169951654618083\t0.0165577778522639\t0.0161105198566348\t0.0156537909533765\t0.0151879982466835\t0.0147135560354200\t0.0142308853751047\t0.0137404136334652\t0.0132425740400844\t0.0127378052306666\t0.0122265507864565\t0.0117092587693513\t0.0111863812532474\t0.0106583738521692\t0.0101256952457286\t0.00958880670246806\t0.00904817160163901\t0.00850425495397047\t0.00795752292198173\t0.00740844234039260\t0.00685748023718350\t0.00630510335585588\t0.00575177767944047\t0.00519796795679813\t0.00464413723175339\t0.00409074637559677\t0.00353825362348642\t0.00298711411527345\t0.00243777944126920\t0.00189069719346513\t0.00134631052270810\t0.000805057702325976\t0.000267371698688395\t-0.000266320250821043\t-0.000795597051955804\t-0.00132004415942586\t-0.00183925397394197\t-0.00235282623005320\t-0.00286036837435846\t-0.00336149593368541\t-0.00385583287284378\t-0.00434301194157384\t-0.00482267501032449\t-0.00529447339451106\t-0.00575806816691683\t-0.00621313045791866\t-0.00665934174323227\t-0.00709639411888902\t-0.00752399056317267\t-0.00794184518526101\t-0.00834968346033439\t-0.00874724245093055\t-0.00913427101434232\t-0.00951052999587282\t-0.00987579240778032\t-0.0102298435937630\t-0.0105724813788522\t-0.0109035162046009\t-0.0112227712494722\t-0.0115300825343511\t-0.0118252990131225\t-0.0121082826482743\t-0.0123789084715050\t-0.0126370646293330\t-0.0128826524137235\t-0.0131155862777654\t-0.0133357938364516\t-0.0135432158526313\t-0.0137378062082235\t-0.0139195318607958\t-0.0140883727856319\t-0.0142443219034289\t-0.0143873849937804\t-0.0145175805946200\t-0.0146349398878158\t-0.0147395065711232\t-0.0148313367167168\t-0.0149104986165412\t-0.0149770726147340\t-0.0150311509273870\t-0.0150728374499309\t-0.0151022475524371\t-0.0151195078631481\t-0.0151247560405597\t-0.0151181405343887\t-0.0150998203357757\t-0.0150699647170814\t-0.0150287529616470\t-0.0149763740838996\t-0.0149130265401937\t-0.0148389179307901\t-0.0147542646933807\t-0.0146592917885783\t-0.0145542323777966\t-0.0144393274939538\t-0.0143148257054396\t-0.0141809827737919\t-0.0140380613055336\t-0.0138863303986269\t-0.0137260652840050\t-0.0135575469626461\t-0.0133810618386553\t-0.0131969013488267\t-0.0130053615891551\t-0.0128067429387710\t-0.0126013496817715\t-0.0123894896274222\t-0.0121714737292003\t-0.0119476157031521\t-0.0117182316460343\t-0.0114836396537058\t-0.0112441594402344\t-0.0110001119581790\t-0.0107518190205037\t-0.0104996029245761\t-0.0102437860786940\t-0.00998469063158416\t-0.00972263810530438\t-0.00945794903197762\t-0.00919094259477741\t-0.00892193627357631\t-0.00865124549566087\t-0.00837918329190739\t-0.00810605995880358\t-0.00783218272669133\t-0.00755785543459555\t-0.00728337821199327\t-0.00700904716786624\t-0.00673515408736880\t-0.00646198613643080\t-0.00618982557460332\t-0.00591894947644237\t-0.00564962946171290\t-0.00538213143468235\t-0.00511671533275963\t-0.00485363488472152\t-0.00459313737875492\t-0.00433546344052907\t-0.00408084682149751\t-0.00382951419761518\t-0.00358168497864140\t-0.00333757112818460\t-0.00309737699462987\t-0.00286129915307534\t-0.00262952625838842\t-0.00240223890947765\t-0.00217960952486101\t-0.00196180222959601\t-0.00174897275362225\t-0.00154126834155127\t-0.00133882767392432\t-0.00114178079994279\t-0.000950249081661772\t-0.000764345149622112\t-0.000584172869881566\t-0.000409827322391340\t-0.000241394790649771\t-7.89527625507157e-05\t7.74300576697443e-05\t0.000227693726498400\t0.000371787027345634\t0.000509667426018673\t0.000641301015617403\t0.000766662451015514\t0.000885734873102136\t0.000998509822971181\t0.00110498714625756\t0.00120517488783061\t0.00129908917706644\t0.00138675410393134\t0.00146820158611887\t0.00154347122749315\t0.00161261016810032\t0.00167567292601933\t0.00173272123133173\t0.00178382385249867\t0.00182905641544065\t0.00186850121562344\t0.00190224702345992\t0.00193038888334449\t0.00195302790664221\t0.00197027105896066\t0.00198223094203719\t0.00198902557057900\t0.00199077814439713\t0.00198761681617943\t0.00197967445525011\t0.00196708840766637\t0.00195000025300448\t0.00192855555818921\t0.00190290362872159\t0.00187319725766064\t0.00183959247271447\t0.00180224828179624\t0.00176132641739902\t0.00171699108014261\t0.00166940868184338\t0.00161874758845597\t0.00156517786323271\t0.00150887101044373\t0.00144999971999680\t0.00138873761329188\t0.00132525899064098\t0.00125973858057888\t0.00119235129138475\t0.00112327196512931\t0.00105267513455570\t0.000980734783095885\t0.000907624108317507\t0.000833515289088735\t0.000758579256741336\t0.000682985470504074\t0.000606901697470346\t0.000530493797355587\t0.000453925512291049\t0.000377358261891444\t0.000300950943824790\t0.000224859740103052\t0.000149237929302405\t7.42357049120248e-05\t7.19254769997801e-19\t-7.33256816254293e-05\t-0.000145601427591550\t-0.000216691072316808\t-0.000286462345400301\t-0.000354787012909843\t-0.000421541011444480\t-0.000486604574858484\t-0.000549862353544915\t-0.000611203526188236\t-0.000670521903906705\t-0.000727716026716505\t-0.000782689252260949\t-0.000835349836759427\t-0.000885611008141868\t-0.000933391031345854\t-0.000978613265764647\t-0.00102120621484539\t-0.00106110356784778\t-0.00109824423378450\t-0.00113257236757519\t-0.00116403738845660\t-0.00119259399070198\t-0.00121820214671305\t-0.00124082710255787\t-0.00126043936603828\t-0.00127701468737988\t-0.00129053403264728\t-0.00130098354999660\t-0.00130835452888634\t-0.00131264335237627\t-0.00131385144265302\t-0.00131198519992874\t-0.00130705593486782\t-0.00129907979470377\t-0.00128807768321635\t-0.00127407517474559\t-0.00125710242242660\t-0.00123719406083525\t-0.00121438910324108\t-0.00118873083366949\t-0.00116026669398096\t-0.00112904816617986\t-0.00109513065017034\t-0.00105857333718142\t-0.00101943907908703\t-0.000977794253850711\t-0.000933708627328164\t-0.000887255211663436\t-0.000838510120517479\t-0.000787552421369875\t-0.000734463985136471\t-0.000679329333347147\t-0.000622235483129130\t-0.000563271790241955\t-0.000502529790410721\t-0.000440103039204209\t-0.000376086950704255\t-0.000310578635212037\t-0.000243676736235937\t-0.000175481267004346\t-0.000106093446745042\t-3.56155369707369e-05\t3.58493219919046e-05\t0.000108197273995199\t0.000181323909353765\t0.000255124426189886\t0.000329493790616252\t0.000404326895535311\t0.000479518717838589\t0.000554964473793834\t0.000630559772412639\t0.000706200766596011\t0.000781784301860790\t0.000857208062455200\t0.000932370714677483\t0.00100717204721764\t0.00108151310834823\t0.00115529633979676\t0.00122842570713851\t0.00130080682655538\t0.00137234708781338\t0.00144295577331810\t0.00151254417311495\t0.00158102569570795\t0.00164831597457857\t0.00171433297029328\t0.00177899706809648\t0.00184223117089264\t0.00190396078752973\t0.00196411411630350\t0.00202262212361024\t0.00207941861768317\t0.00213444031735612\t0.00218762691580539\t0.00223892113922903\t0.00228826880043062\t0.00233561884728230\t0.00238092340604986\t0.00242413781957023\t0.00246522068027977\t0.00250413385809899\t0.00254084252318727\t0.00257531516358838\t0.00260752359779501\t0.00263744298226794\t0.00266505181395229\t0.00269033192784063\t0.00271326848963936\t0.00273384998360153\t0.00275206819559587\t0.00276791819148808\t0.00278139829091669\t0.00279251003655189\t0.00280125815893131\t0.00280765053697264\t0.00281169815426827\t0.00281341505127220\t0.00281281827349487\t0.00280992781582576\t0.00280476656310870\t0.00279736022709874\t0.00278773727993376\t0.00277592888425765\t0.00276196882013560\t0.00274589340890530\t0.00272774143411101\t0.00270755405967022\t0.00268537474542521\t0.00266124916023432\t0.00263522509275942\t0.00260735236010835\t0.00257768271449228\t0.00254626974805942\t0.00251316879606750\t0.00247843683855824\t0.00244213240069747\t0.00240431545194501\t0.00236504730421813\t0.00232439050921261\t0.00228240875504447\t0.00223916676237516\t0.00219473018018159\t0.00214916548133170\t0.00210253985812430\t0.00205492111795062\t0.00200637757923311\t0.00195697796779464\t0.00190679131380927\t0.00185588684948312\t0.00180433390761108\t0.00175220182115219\t0.00169955982396365\t0.00164647695282973\t0.00159302195091886\t0.00153926317279804\t0.00148526849113038\t0.00143110520517742\t0.00137683995122370\t0.00132253861503705\t0.00126826624647365\t0.00121408697633218\t0.00116006393555726\t0.00110625917688716\t0.00105273359903652\t0.000999546873499304\t0.000946757374052876\t0.000894422109038610\t0.000842596656489554\t0.000791335102170428\t0.000740689980590114\t0.000690712219041478\t0.000641451084718191\t0.000592954134952790\t0.000545267170615130\t0.000498434192704850\t0.000452497362166358\t0.000407496962949437\t0.000363471368333427\t0.000320457010527570\t0.000278488353555005\t0.000237597869422766\t0.000197816017574914\t0.000159171227621052\t0.000121689885327374\t8.53963218525767e-05\t5.03128062061118e-05\t1.64595409015606e-05\t-1.61453392267853e-05\t-4.74857650804866e-05\t-7.75477282675384e-05\t-0.000106319273032093\t-0.000133790485192674\t-0.000159953478142262\t-0.000184802375967652\t-0.000208333293749184\t-0.000230544315105724\t-0.000251435467053209\t-0.000271008692248528\t-0.000289267818693655\t-0.000306218526978132\t-0.000321868315140790\t-0.000336226461234486\t-0.000349303983680105\t-0.000361113599498608\t-0.000371669680512089\t-0.000380988207606948\t-0.000389086723154180\t-0.000395984281683540\t-0.000401701398909919\t-0.000406259999211655\t-0.000409683361661765\t-0.000411996064714080\t-0.000413223929647223\t-0.000413393962869987\t-0.000412534297192291\t-0.000410674132166183\t-0.000407843673601605\t-0.000404074072361604\t-0.000399397362541602\t-0.000393846399136942\t-0.000387454795302522\t-0.000380256859307689\t-0.000372287531288722\t-0.000363582319900374\t-0.000354177238966773\t-0.000344108744230797\t-0.000333413670299596\t-0.000322129167882484\t-0.000310292641415675\t-0.000297941687166617\t-0.000285114031908709\t-0.000271847472255163\t-0.000258179814738611\t-0.000244148816720784\t-0.000229792128214169\t-0.000215147234695133\t-0.000200251400985350\t-0.000185141616275717\t-0.000169854540364182\t-0.000154426451176078\t-0.000138893193632550\t-0.000123290129929803\t-0.000107652091288701\t-9.20133312312316e-05\t-7.64074804371047e-05\t-6.08675032306165e-05\t-4.54256557445348e-05\t-3.01134458045921e-05\t-1.49615945747347e-05\t-2.89570102206907e-19\t1.47422979195256e-05\t2.92371499935482e-05\t4.34573288185537e-05\t5.73765578435795e-05\t7.09695385048991e-05\t8.42119754130424e-05\t9.70805995790010e-05\t0.000109553189669740\t0.000121608591286549\t0.000133226734262944\t0.000144388647982165\t0.000155076474717484\t0.000165273481001697\t0.000174964067035300\t0.000184133774145895\t0.000192769290314387\t0.000200858453786435\t0.000208390254790512\t0.000215354835386701\t0.000221743487473104\t0.000227548648979331\t0.000232763898279138\t0.000237383946856721\t0.000241404630263570\t0.000244822897405062\t0.000247636798198180\t0.000249845469643829\t0.000251449120359227\t0.000252449013617722\t0.000252847448945224\t0.000252647742324057\t0.000251854205056692\t0.000250472121343227\t0.000248507724627882\t0.000245968172771024\t0.000242861522104343\t0.000239196700427884\t0.000234983479008503\t0.000230232443640159\t0.000224954964827125\t0.000219163167151782\t0.000212869897889143\t0.000206088694930604\t0.000198833754079658\t0.000191119895782473\t0.000182962531356236\t0.000174377628778114\t0.000165381678097493\t0.000155991656533880\t0.000146224993322452\t0.000136099534368770\t0.000125633506773593\t0.000114845483288030\t0.000103754346758530\t9.23792546203174e-05\t8.07396034969619e-05\t6.88549939627184e-05\t5.67451955231691e-05\t4.44301118684996e-05\t3.19297464524893e-05\t1.92641684489213e-05\t6.45347913574842e-06\t-6.48222124416269e-06\t-1.95228660984025e-05\t-3.26484545308114e-05\t-4.58390827736315e-05\t-5.90749749637039e-05\t-7.23365132220933e-05\t-8.56042669983775e-05\t-9.88590216426344e-05\t-0.000112081806170066\t-0.000125253920185076\t-0.000138356959933597\t-0.000151372843454383\t-0.000164283834802009\t-0.000177072567316285\t-0.000189722065914846\t-0.000202215768387676\t-0.000214537545674379\t-0.000226671721107042\t-0.000238603088603566\t-0.000250316929798388\t-0.000261799030099529\t-0.000273035693662904\t-0.000284013757276890\t-0.000294720603152018\t-0.000305144170612759\t-0.000315272966690158\t-0.000325096075616101\t-0.000334603167221790\t-0.000343784504244919\t-0.000352630948551759\t-0.000361133966282231\t-0.000369285631927676\t-0.000377078631352787\t-0.000384506263774744\t-0.000391562442714227\t-0.000398241695934472\t-0.000404539164386060\t-0.000410450600176512\t-0.000415972363585155\t-0.000421101419145048\t-0.000425835330814964\t-0.000430172256265661\t-0.000434110940305761\t-0.000437650707473649\t-0.000440791453822779\t-0.000443533637928715\t-0.000445878271147096\t-0.000447826907152526\t-0.000449381630789087\t-0.000450545046263876\t-0.000451320264715525\t-0.000451710891190224\t-0.000451721011058181\t-0.000451355175903889\t-0.000450618388923862\t-0.000449516089865765\t-0.000448054139543056\t-0.000446238803959370\t-0.000444076738076955\t-0.000441574969263422\t-0.000438740880451056\t-0.000435582193042744\t-0.000432106949598435\t-0.000428323496335760\t-0.000424240465478137\t-0.000419866757483334\t-0.000415211523185017\t-0.000410284145879348\t-0.000405094223388176\t-0.000399651550129767\t-0.000393966099227414\t-0.000388048004685588\t-0.000381907543662574\t-0.000375555118867786\t-0.000369001241111159\t-0.000362256512031173\t-0.000355331607027209\t-0.000348237258421025\t-0.000340984238871217\t-0.000333583345063560\t-0.000326045381699152\t-0.000318381145801259\t-0.000310601411360734\t-0.000302716914338852\t-0.000294738338045302\t-0.000286676298908029\t-0.000278541332650522\t-0.000270343880891021\t-0.000262094278177049\t-0.000253802739467532\t-0.000245479348073666\t-0.000237134044068595\t-0.000228776613174815\t-0.000220416676137166\t-0.000212063678588118\t-0.000203726881411025\t-0.000195415351605887\t-0.000187137953661150\t-0.000178903341433976\t-0.000170719950540410\t-0.000162595991255854\t-0.000154539441925259\t-0.000146558042881469\t-0.000138659290869229\t-0.000130850433971418\t-0.000123138467033194\t-0.000115530127578867\t-0.000108031892215478\t-0.000100649973516263\t-9.33903173764076e-05\t-8.62586008327578e-05\t-7.92602303384457e-05\t-7.24003404827332e-05\t-6.56837931457214e-05\t-5.91151770770133e-05\t-5.26988078868132e-05\t-4.64387284374705e-05\t-4.03387096229618e-05\t-3.44022515233885e-05\t-2.86325849211373e-05\t-2.30326731650107e-05\t-1.76052143682957e-05\t-1.23526439264607e-05\t-7.27713733992100e-06\t-2.38061332710547e-06\t2.33526278709564e-06\t6.86907542257971e-06\t1.12196548501132e-05\t1.53860730674611e-05\t1.93676394607737e-05\t2.31638962664390e-05\t2.67746138485385e-05\t3.01997858069561e-05\t3.34396239310700e-05\t3.64945530137878e-05\t3.93652055405077e-05\t4.20524162673526e-05\t4.45572167027813e-05\t4.68808295063986e-05\t4.90246628184729e-05\t5.09903045333425e-05\t5.27795165295223e-05\t5.43942288689521e-05\t5.58365339774059e-05\t5.71086808176713e-05\t5.82130690666487e-05\t5.91522433070664e-05\t5.99288872440181e-05\t6.05458179560438e-05\t6.10059801899582e-05\t6.13124407081177e-05\t6.14683826962815e-05\t6.14771002396855e-05\t6.13419928744055e-05\t6.10665602205273e-05\t6.06543967030956e-05\t6.01091863662453e-05\t5.94346977853764e-05\t5.86347790816568e-05\t5.77133530426020e-05\t5.66744123519132e-05\t5.55220149312262e-05\t5.42602793958663e-05\t5.28933806261883e-05\t5.14255454555536e-05\t4.98610484754855e-05\t4.82042079580479e-05\t4.64593818950024e-05\t4.46309641528412e-05\t4.27233807423181e-05\t4.07410862006860e-05\t3.86885600844072e-05\t3.65703035697221e-05\t3.43908361580643e-05\t3.21546924829572e-05\t2.98664192146919e-05\t2.75305720587617e-05\t2.51517128437406e-05\t2.27344066940190e-05\t2.02832192825685e-05\t1.78027141586849e-05\t1.52974501454567e-05\t1.27719788015466e-05\t1.02308419417135e-05\t7.67856921040619e-06\t5.11967570263367e-06\t2.55865962628471e-06\t7.47277683114599e-20]\n   * Referenced by: '<Root>/Discrete FIR Filter1'\n   */\n  real_T Thrd_Value;                   /* Expression: 0.03\n                                        * Referenced by: '<Root>/Thrd'\n                                        */\n  real_T Memory11_InitialCondition;    /* Expression: 0\n                                        * Referenced by: '<Root>/Memory11'\n                                        */\n  real_T Memory7_InitialCondition;     /* Expression: 0\n                                        * Referenced by: '<Root>/Memory7'\n                                        */\n  real_T Memory3_InitialCondition;     /* Expression: 1\n                                        * Referenced by: '<Root>/Memory3'\n                                        */\n  real_T Memory4_InitialCondition;     /* Expression: 1\n                                        * Referenced by: '<Root>/Memory4'\n                                        */\n  real_T Memory9_InitialCondition;     /* Expression: 0\n                                        * Referenced by: '<Root>/Memory9'\n                                        */\n  real_T Memory5_InitialCondition;     /* Expression: 0\n                                        * Referenced by: '<Root>/Memory5'\n                                        */\n  real_T Memory6_InitialCondition;     /* Expression: 0\n                                        * Referenced by: '<Root>/Memory6'\n                                        */\n  real_T Memory10_InitialCondition;    /* Expression: 0\n                                        * Referenced by: '<Root>/Memory10'\n                                        */\n  real_T Analogoutput_P1_Size[2];    /* Computed Parameter: Analogoutput_P1_Size\n                                      * Referenced by: '<Root>/Analog output '\n                                      */\n  real_T Analogoutput_P1;              /* Expression: parModuleId\n                                        * Referenced by: '<Root>/Analog output '\n                                        */\n  real_T Analogoutput_P2_Size[2];    /* Computed Parameter: Analogoutput_P2_Size\n                                      * Referenced by: '<Root>/Analog output '\n                                      */\n  real_T Analogoutput_P2;              /* Expression: parSampleTime\n                                        * Referenced by: '<Root>/Analog output '\n                                        */\n  real_T Analogoutput_P3_Size[2];    /* Computed Parameter: Analogoutput_P3_Size\n                                      * Referenced by: '<Root>/Analog output '\n                                      */\n  real_T Analogoutput_P3;              /* Expression: parPciSlot\n                                        * Referenced by: '<Root>/Analog output '\n                                        */\n  real_T Analogoutput_P4_Size[2];    /* Computed Parameter: Analogoutput_P4_Size\n                                      * Referenced by: '<Root>/Analog output '\n                                      */\n  real_T Analogoutput_P4[2];           /* Expression: parDacChannels\n                                        * Referenced by: '<Root>/Analog output '\n                                        */\n  real_T Analogoutput_P5_Size[2];    /* Computed Parameter: Analogoutput_P5_Size\n                                      * Referenced by: '<Root>/Analog output '\n                                      */\n  real_T Analogoutput_P5[2];           /* Expression: parDacRanges\n                                        * Referenced by: '<Root>/Analog output '\n                                        */\n  real_T Analogoutput_P6_Size[2];    /* Computed Parameter: Analogoutput_P6_Size\n                                      * Referenced by: '<Root>/Analog output '\n                                      */\n  real_T Analogoutput_P6[2];           /* Expression: parDacInitValues\n                                        * Referenced by: '<Root>/Analog output '\n                                        */\n  real_T Analogoutput_P7_Size[2];    /* Computed Parameter: Analogoutput_P7_Size\n                                      * Referenced by: '<Root>/Analog output '\n                                      */\n  real_T Analogoutput_P7[2];           /* Expression: parDacResets\n                                        * Referenced by: '<Root>/Analog output '\n                                        */\n  real_T WhiskerTrig_Amp;              /* Expression: 1\n                                        * Referenced by: '<Root>/Whisker Trig'\n                                        */\n  real_T WhiskerTrig_PhaseDelay;       /* Expression: 0\n                                        * Referenced by: '<Root>/Whisker Trig'\n                                        */\n  real_T NpxlsTrig_Amp;                /* Expression: 2.5\n                                        * Referenced by: '<Root>/Npxls Trig'\n                                        */\n  real_T NpxlsTrig_PhaseDelay;         /* Expression: 0\n                                        * Referenced by: '<Root>/Npxls Trig'\n                                        */\n  real_T PupilTrig_Amp;                /* Expression: 1\n                                        * Referenced by: '<Root>/Pupil Trig'\n                                        */\n  real_T PupilTrig_PhaseDelay;         /* Expression: 0\n                                        * Referenced by: '<Root>/Pupil Trig'\n                                        */\n  real_T Constant4_Value;              /* Expression: 1\n                                        * Referenced by: '<S5>/Constant4'\n                                        */\n  real_T Digitaloutput_P1_Size[2];  /* Computed Parameter: Digitaloutput_P1_Size\n                                     * Referenced by: '<Root>/Digital output '\n                                     */\n  real_T Digitaloutput_P1;             /* Expression: parModuleId\n                                        * Referenced by: '<Root>/Digital output '\n                                        */\n  real_T Digitaloutput_P2_Size[2];  /* Computed Parameter: Digitaloutput_P2_Size\n                                     * Referenced by: '<Root>/Digital output '\n                                     */\n  real_T Digitaloutput_P2;             /* Expression: parSampleTime\n                                        * Referenced by: '<Root>/Digital output '\n                                        */\n  real_T Digitaloutput_P3_Size[2];  /* Computed Parameter: Digitaloutput_P3_Size\n                                     * Referenced by: '<Root>/Digital output '\n                                     */\n  real_T Digitaloutput_P3;             /* Expression: parPciSlot\n                                        * Referenced by: '<Root>/Digital output '\n                                        */\n  real_T Digitaloutput_P4_Size[2];  /* Computed Parameter: Digitaloutput_P4_Size\n                                     * Referenced by: '<Root>/Digital output '\n                                     */\n  real_T Digitaloutput_P4[15];         /* Expression: parDoChannels\n                                        * Referenced by: '<Root>/Digital output '\n                                        */\n  real_T Digitaloutput_P5_Size[2];  /* Computed Parameter: Digitaloutput_P5_Size\n                                     * Referenced by: '<Root>/Digital output '\n                                     */\n  real_T Digitaloutput_P5[15];         /* Expression: parDoInitValues\n                                        * Referenced by: '<Root>/Digital output '\n                                        */\n  real_T Digitaloutput_P6_Size[2];  /* Computed Parameter: Digitaloutput_P6_Size\n                                     * Referenced by: '<Root>/Digital output '\n                                     */\n  real_T Digitaloutput_P6[15];         /* Expression: parDoResets\n                                        * Referenced by: '<Root>/Digital output '\n                                        */\n  real_T Digitalinput_P1_Size[2];    /* Computed Parameter: Digitalinput_P1_Size\n                                      * Referenced by: '<Root>/Digital input '\n                                      */\n  real_T Digitalinput_P1;              /* Expression: parModuleId\n                                        * Referenced by: '<Root>/Digital input '\n                                        */\n  real_T Digitalinput_P2_Size[2];    /* Computed Parameter: Digitalinput_P2_Size\n                                      * Referenced by: '<Root>/Digital input '\n                                      */\n  real_T Digitalinput_P2;              /* Expression: parSampleTime\n                                        * Referenced by: '<Root>/Digital input '\n                                        */\n  real_T Digitalinput_P3_Size[2];    /* Computed Parameter: Digitalinput_P3_Size\n                                      * Referenced by: '<Root>/Digital input '\n                                      */\n  real_T Digitalinput_P3;              /* Expression: parPciSlot\n                                        * Referenced by: '<Root>/Digital input '\n                                        */\n  real_T Digitalinput_P4_Size[2];    /* Computed Parameter: Digitalinput_P4_Size\n                                      * Referenced by: '<Root>/Digital input '\n                                      */\n  real_T Digitalinput_P4;              /* Expression: parDiChannels\n                                        * Referenced by: '<Root>/Digital input '\n                                        */\n};\n\n/* Storage class 'PageSwitching' */\nextern ATTN_cal_type ATTN_cal_impl;\nextern ATTN_cal_type *ATTN_cal;\n\n#endif                                 /* RTW_HEADER_ATTN_cal_h_ */\n"},{"name":"multiword_types.h","type":"header","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * multiword_types.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.506\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Tue Dec 12 16:07:50 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef MULTIWORD_TYPES_H\n#define MULTIWORD_TYPES_H\n#include \"rtwtypes.h\"\n\n/*\n * Definitions supporting external data access\n */\ntypedef int64_T chunk_T;\ntypedef uint64_T uchunk_T;\n\n/*\n * MultiWord supporting definitions\n */\ntypedef long long longlong_T;\n\n/*\n * MultiWord types\n */\ntypedef struct {\n  uint64_T chunks[2];\n} int128m_T;\n\ntypedef struct {\n  int128m_T re;\n  int128m_T im;\n} cint128m_T;\n\ntypedef struct {\n  uint64_T chunks[2];\n} uint128m_T;\n\ntypedef struct {\n  uint128m_T re;\n  uint128m_T im;\n} cuint128m_T;\n\ntypedef struct {\n  uint64_T chunks[3];\n} int192m_T;\n\ntypedef struct {\n  int192m_T re;\n  int192m_T im;\n} cint192m_T;\n\ntypedef struct {\n  uint64_T chunks[3];\n} uint192m_T;\n\ntypedef struct {\n  uint192m_T re;\n  uint192m_T im;\n} cuint192m_T;\n\ntypedef struct {\n  uint64_T chunks[4];\n} int256m_T;\n\ntypedef struct {\n  int256m_T re;\n  int256m_T im;\n} cint256m_T;\n\ntypedef struct {\n  uint64_T chunks[4];\n} uint256m_T;\n\ntypedef struct {\n  uint256m_T re;\n  uint256m_T im;\n} cuint256m_T;\n\ntypedef struct {\n  uint64_T chunks[5];\n} int320m_T;\n\ntypedef struct {\n  int320m_T re;\n  int320m_T im;\n} cint320m_T;\n\ntypedef struct {\n  uint64_T chunks[5];\n} uint320m_T;\n\ntypedef struct {\n  uint320m_T re;\n  uint320m_T im;\n} cuint320m_T;\n\ntypedef struct {\n  uint64_T chunks[6];\n} int384m_T;\n\ntypedef struct {\n  int384m_T re;\n  int384m_T im;\n} cint384m_T;\n\ntypedef struct {\n  uint64_T chunks[6];\n} uint384m_T;\n\ntypedef struct {\n  uint384m_T re;\n  uint384m_T im;\n} cuint384m_T;\n\ntypedef struct {\n  uint64_T chunks[7];\n} int448m_T;\n\ntypedef struct {\n  int448m_T re;\n  int448m_T im;\n} cint448m_T;\n\ntypedef struct {\n  uint64_T chunks[7];\n} uint448m_T;\n\ntypedef struct {\n  uint448m_T re;\n  uint448m_T im;\n} cuint448m_T;\n\ntypedef struct {\n  uint64_T chunks[8];\n} int512m_T;\n\ntypedef struct {\n  int512m_T re;\n  int512m_T im;\n} cint512m_T;\n\ntypedef struct {\n  uint64_T chunks[8];\n} uint512m_T;\n\ntypedef struct {\n  uint512m_T re;\n  uint512m_T im;\n} cuint512m_T;\n\ntypedef struct {\n  uint64_T chunks[9];\n} int576m_T;\n\ntypedef struct {\n  int576m_T re;\n  int576m_T im;\n} cint576m_T;\n\ntypedef struct {\n  uint64_T chunks[9];\n} uint576m_T;\n\ntypedef struct {\n  uint576m_T re;\n  uint576m_T im;\n} cuint576m_T;\n\ntypedef struct {\n  uint64_T chunks[10];\n} int640m_T;\n\ntypedef struct {\n  int640m_T re;\n  int640m_T im;\n} cint640m_T;\n\ntypedef struct {\n  uint64_T chunks[10];\n} uint640m_T;\n\ntypedef struct {\n  uint640m_T re;\n  uint640m_T im;\n} cuint640m_T;\n\ntypedef struct {\n  uint64_T chunks[11];\n} int704m_T;\n\ntypedef struct {\n  int704m_T re;\n  int704m_T im;\n} cint704m_T;\n\ntypedef struct {\n  uint64_T chunks[11];\n} uint704m_T;\n\ntypedef struct {\n  uint704m_T re;\n  uint704m_T im;\n} cuint704m_T;\n\ntypedef struct {\n  uint64_T chunks[12];\n} int768m_T;\n\ntypedef struct {\n  int768m_T re;\n  int768m_T im;\n} cint768m_T;\n\ntypedef struct {\n  uint64_T chunks[12];\n} uint768m_T;\n\ntypedef struct {\n  uint768m_T re;\n  uint768m_T im;\n} cuint768m_T;\n\ntypedef struct {\n  uint64_T chunks[13];\n} int832m_T;\n\ntypedef struct {\n  int832m_T re;\n  int832m_T im;\n} cint832m_T;\n\ntypedef struct {\n  uint64_T chunks[13];\n} uint832m_T;\n\ntypedef struct {\n  uint832m_T re;\n  uint832m_T im;\n} cuint832m_T;\n\ntypedef struct {\n  uint64_T chunks[14];\n} int896m_T;\n\ntypedef struct {\n  int896m_T re;\n  int896m_T im;\n} cint896m_T;\n\ntypedef struct {\n  uint64_T chunks[14];\n} uint896m_T;\n\ntypedef struct {\n  uint896m_T re;\n  uint896m_T im;\n} cuint896m_T;\n\ntypedef struct {\n  uint64_T chunks[15];\n} int960m_T;\n\ntypedef struct {\n  int960m_T re;\n  int960m_T im;\n} cint960m_T;\n\ntypedef struct {\n  uint64_T chunks[15];\n} uint960m_T;\n\ntypedef struct {\n  uint960m_T re;\n  uint960m_T im;\n} cuint960m_T;\n\ntypedef struct {\n  uint64_T chunks[16];\n} int1024m_T;\n\ntypedef struct {\n  int1024m_T re;\n  int1024m_T im;\n} cint1024m_T;\n\ntypedef struct {\n  uint64_T chunks[16];\n} uint1024m_T;\n\ntypedef struct {\n  uint1024m_T re;\n  uint1024m_T im;\n} cuint1024m_T;\n\ntypedef struct {\n  uint64_T chunks[17];\n} int1088m_T;\n\ntypedef struct {\n  int1088m_T re;\n  int1088m_T im;\n} cint1088m_T;\n\ntypedef struct {\n  uint64_T chunks[17];\n} uint1088m_T;\n\ntypedef struct {\n  uint1088m_T re;\n  uint1088m_T im;\n} cuint1088m_T;\n\ntypedef struct {\n  uint64_T chunks[18];\n} int1152m_T;\n\ntypedef struct {\n  int1152m_T re;\n  int1152m_T im;\n} cint1152m_T;\n\ntypedef struct {\n  uint64_T chunks[18];\n} uint1152m_T;\n\ntypedef struct {\n  uint1152m_T re;\n  uint1152m_T im;\n} cuint1152m_T;\n\ntypedef struct {\n  uint64_T chunks[19];\n} int1216m_T;\n\ntypedef struct {\n  int1216m_T re;\n  int1216m_T im;\n} cint1216m_T;\n\ntypedef struct {\n  uint64_T chunks[19];\n} uint1216m_T;\n\ntypedef struct {\n  uint1216m_T re;\n  uint1216m_T im;\n} cuint1216m_T;\n\ntypedef struct {\n  uint64_T chunks[20];\n} int1280m_T;\n\ntypedef struct {\n  int1280m_T re;\n  int1280m_T im;\n} cint1280m_T;\n\ntypedef struct {\n  uint64_T chunks[20];\n} uint1280m_T;\n\ntypedef struct {\n  uint1280m_T re;\n  uint1280m_T im;\n} cuint1280m_T;\n\ntypedef struct {\n  uint64_T chunks[21];\n} int1344m_T;\n\ntypedef struct {\n  int1344m_T re;\n  int1344m_T im;\n} cint1344m_T;\n\ntypedef struct {\n  uint64_T chunks[21];\n} uint1344m_T;\n\ntypedef struct {\n  uint1344m_T re;\n  uint1344m_T im;\n} cuint1344m_T;\n\ntypedef struct {\n  uint64_T chunks[22];\n} int1408m_T;\n\ntypedef struct {\n  int1408m_T re;\n  int1408m_T im;\n} cint1408m_T;\n\ntypedef struct {\n  uint64_T chunks[22];\n} uint1408m_T;\n\ntypedef struct {\n  uint1408m_T re;\n  uint1408m_T im;\n} cuint1408m_T;\n\ntypedef struct {\n  uint64_T chunks[23];\n} int1472m_T;\n\ntypedef struct {\n  int1472m_T re;\n  int1472m_T im;\n} cint1472m_T;\n\ntypedef struct {\n  uint64_T chunks[23];\n} uint1472m_T;\n\ntypedef struct {\n  uint1472m_T re;\n  uint1472m_T im;\n} cuint1472m_T;\n\ntypedef struct {\n  uint64_T chunks[24];\n} int1536m_T;\n\ntypedef struct {\n  int1536m_T re;\n  int1536m_T im;\n} cint1536m_T;\n\ntypedef struct {\n  uint64_T chunks[24];\n} uint1536m_T;\n\ntypedef struct {\n  uint1536m_T re;\n  uint1536m_T im;\n} cuint1536m_T;\n\ntypedef struct {\n  uint64_T chunks[25];\n} int1600m_T;\n\ntypedef struct {\n  int1600m_T re;\n  int1600m_T im;\n} cint1600m_T;\n\ntypedef struct {\n  uint64_T chunks[25];\n} uint1600m_T;\n\ntypedef struct {\n  uint1600m_T re;\n  uint1600m_T im;\n} cuint1600m_T;\n\ntypedef struct {\n  uint64_T chunks[26];\n} int1664m_T;\n\ntypedef struct {\n  int1664m_T re;\n  int1664m_T im;\n} cint1664m_T;\n\ntypedef struct {\n  uint64_T chunks[26];\n} uint1664m_T;\n\ntypedef struct {\n  uint1664m_T re;\n  uint1664m_T im;\n} cuint1664m_T;\n\ntypedef struct {\n  uint64_T chunks[27];\n} int1728m_T;\n\ntypedef struct {\n  int1728m_T re;\n  int1728m_T im;\n} cint1728m_T;\n\ntypedef struct {\n  uint64_T chunks[27];\n} uint1728m_T;\n\ntypedef struct {\n  uint1728m_T re;\n  uint1728m_T im;\n} cuint1728m_T;\n\ntypedef struct {\n  uint64_T chunks[28];\n} int1792m_T;\n\ntypedef struct {\n  int1792m_T re;\n  int1792m_T im;\n} cint1792m_T;\n\ntypedef struct {\n  uint64_T chunks[28];\n} uint1792m_T;\n\ntypedef struct {\n  uint1792m_T re;\n  uint1792m_T im;\n} cuint1792m_T;\n\ntypedef struct {\n  uint64_T chunks[29];\n} int1856m_T;\n\ntypedef struct {\n  int1856m_T re;\n  int1856m_T im;\n} cint1856m_T;\n\ntypedef struct {\n  uint64_T chunks[29];\n} uint1856m_T;\n\ntypedef struct {\n  uint1856m_T re;\n  uint1856m_T im;\n} cuint1856m_T;\n\ntypedef struct {\n  uint64_T chunks[30];\n} int1920m_T;\n\ntypedef struct {\n  int1920m_T re;\n  int1920m_T im;\n} cint1920m_T;\n\ntypedef struct {\n  uint64_T chunks[30];\n} uint1920m_T;\n\ntypedef struct {\n  uint1920m_T re;\n  uint1920m_T im;\n} cuint1920m_T;\n\ntypedef struct {\n  uint64_T chunks[31];\n} int1984m_T;\n\ntypedef struct {\n  int1984m_T re;\n  int1984m_T im;\n} cint1984m_T;\n\ntypedef struct {\n  uint64_T chunks[31];\n} uint1984m_T;\n\ntypedef struct {\n  uint1984m_T re;\n  uint1984m_T im;\n} cuint1984m_T;\n\ntypedef struct {\n  uint64_T chunks[32];\n} int2048m_T;\n\ntypedef struct {\n  int2048m_T re;\n  int2048m_T im;\n} cint2048m_T;\n\ntypedef struct {\n  uint64_T chunks[32];\n} uint2048m_T;\n\ntypedef struct {\n  uint2048m_T re;\n  uint2048m_T im;\n} cuint2048m_T;\n\n#endif                                 /* MULTIWORD_TYPES_H */\n"},{"name":"rtGetInf.cpp","type":"source","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetInf.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.506\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Tue Dec 12 16:07:50 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"rtwtypes.h\"\n\nextern \"C\"\n{\n\n#include \"rtGetInf.h\"\n\n}\n\n#include <stddef.h>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#define NumBitsPerChar                 8U\n\nextern \"C\"\n{\n  /*\n   * Initialize rtInf needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real_T rtGetInf(void)\n  {\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n    real_T inf = 0.0;\n    if (bitsPerReal == 32U) {\n      inf = rtGetInfF();\n    } else {\n      uint16_T one = 1U;\n      enum {\n        LittleEndian,\n        BigEndian\n      } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\n      switch (machByteOrder) {\n       case LittleEndian:\n        {\n          union {\n            LittleEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0x7FF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          inf = tmpVal.fltVal;\n          break;\n        }\n\n       case BigEndian:\n        {\n          union {\n            BigEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0x7FF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          inf = tmpVal.fltVal;\n          break;\n        }\n      }\n    }\n\n    return inf;\n  }\n\n  /*\n   * Initialize rtInfF needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real32_T rtGetInfF(void)\n  {\n    IEEESingle infF;\n    infF.wordL.wordLuint = 0x7F800000U;\n    return infF.wordL.wordLreal;\n  }\n\n  /*\n   * Initialize rtMinusInf needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real_T rtGetMinusInf(void)\n  {\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n    real_T minf = 0.0;\n    if (bitsPerReal == 32U) {\n      minf = rtGetMinusInfF();\n    } else {\n      uint16_T one = 1U;\n      enum {\n        LittleEndian,\n        BigEndian\n      } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\n      switch (machByteOrder) {\n       case LittleEndian:\n        {\n          union {\n            LittleEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0xFFF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          minf = tmpVal.fltVal;\n          break;\n        }\n\n       case BigEndian:\n        {\n          union {\n            BigEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0xFFF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          minf = tmpVal.fltVal;\n          break;\n        }\n      }\n    }\n\n    return minf;\n  }\n\n  /*\n   * Initialize rtMinusInfF needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real32_T rtGetMinusInfF(void)\n  {\n    IEEESingle minfF;\n    minfF.wordL.wordLuint = 0xFF800000U;\n    return minfF.wordL.wordLreal;\n  }\n}\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetInf.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.506\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Tue Dec 12 16:07:50 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rtGetInf_h_\n#define RTW_HEADER_rtGetInf_h_\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#include \"rtwtypes.h\"\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern real_T rtGetInf(void);\n  extern real32_T rtGetInfF(void);\n  extern real_T rtGetMinusInf(void);\n  extern real32_T rtGetMinusInfF(void);\n\n#ifdef __cplusplus\n\n}                                      /* extern \"C\" */\n\n#endif\n#endif                                 /* RTW_HEADER_rtGetInf_h_ */\n"},{"name":"rtGetNaN.cpp","type":"source","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetNaN.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.506\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Tue Dec 12 16:07:50 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"rtwtypes.h\"\n\nextern \"C\"\n{\n\n#include \"rtGetNaN.h\"\n\n}\n\n#include <stddef.h>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#define NumBitsPerChar                 8U\n\nextern \"C\"\n{\n  /*\n   * Initialize rtNaN needed by the generated code.\n   * NaN is initialized as non-signaling. Assumes IEEE.\n   */\n  real_T rtGetNaN(void)\n  {\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n    real_T nan = 0.0;\n    if (bitsPerReal == 32U) {\n      nan = rtGetNaNF();\n    } else {\n      uint16_T one = 1U;\n      enum {\n        LittleEndian,\n        BigEndian\n      } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\n      switch (machByteOrder) {\n       case LittleEndian:\n        {\n          union {\n            LittleEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0xFFF80000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          nan = tmpVal.fltVal;\n          break;\n        }\n\n       case BigEndian:\n        {\n          union {\n            BigEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0x7FFFFFFFU;\n          tmpVal.bitVal.words.wordL = 0xFFFFFFFFU;\n          nan = tmpVal.fltVal;\n          break;\n        }\n      }\n    }\n\n    return nan;\n  }\n\n  /*\n   * Initialize rtNaNF needed by the generated code.\n   * NaN is initialized as non-signaling. Assumes IEEE.\n   */\n  real32_T rtGetNaNF(void)\n  {\n    IEEESingle nanF = { { 0.0F } };\n\n    uint16_T one = 1U;\n    enum {\n      LittleEndian,\n      BigEndian\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\n    switch (machByteOrder) {\n     case LittleEndian:\n      {\n        nanF.wordL.wordLuint = 0xFFC00000U;\n        break;\n      }\n\n     case BigEndian:\n      {\n        nanF.wordL.wordLuint = 0x7FFFFFFFU;\n        break;\n      }\n    }\n\n    return nanF.wordL.wordLreal;\n  }\n}\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetNaN.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.506\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Tue Dec 12 16:07:50 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rtGetNaN_h_\n#define RTW_HEADER_rtGetNaN_h_\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#include \"rtwtypes.h\"\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern real_T rtGetNaN(void);\n  extern real32_T rtGetNaNF(void);\n\n#ifdef __cplusplus\n\n}                                      /* extern \"C\" */\n\n#endif\n#endif                                 /* RTW_HEADER_rtGetNaN_h_ */\n"},{"name":"rt_nonfinite.cpp","type":"source","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rt_nonfinite.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.506\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Tue Dec 12 16:07:50 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\nextern \"C\"\n{\n\n#include \"rtGetNaN.h\"\n\n}\n\nextern \"C\"\n{\n\n#include \"rtGetInf.h\"\n\n}\n\n#include <stddef.h>\n#include \"rtwtypes.h\"\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#define NumBitsPerChar                 8U\n\nextern \"C\"\n{\n  real_T rtInf;\n  real_T rtMinusInf;\n  real_T rtNaN;\n  real32_T rtInfF;\n  real32_T rtMinusInfF;\n  real32_T rtNaNF;\n}\n\nextern \"C\"\n{\n  /*\n   * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\n   * generated code. NaN is initialized as non-signaling. Assumes IEEE.\n   */\n  void rt_InitInfAndNaN(size_t realSize)\n  {\n    (void) (realSize);\n    rtNaN = rtGetNaN();\n    rtNaNF = rtGetNaNF();\n    rtInf = rtGetInf();\n    rtInfF = rtGetInfF();\n    rtMinusInf = rtGetMinusInf();\n    rtMinusInfF = rtGetMinusInfF();\n  }\n\n  /* Test if value is infinite */\n  boolean_T rtIsInf(real_T value)\n  {\n    return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\n  }\n\n  /* Test if single-precision value is infinite */\n  boolean_T rtIsInfF(real32_T value)\n  {\n    return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\n  }\n\n  /* Test if value is not a number */\n  boolean_T rtIsNaN(real_T value)\n  {\n    boolean_T result = (boolean_T) 0;\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n    if (bitsPerReal == 32U) {\n      result = rtIsNaNF((real32_T)value);\n    } else {\n      union {\n        LittleEndianIEEEDouble bitVal;\n        real_T fltVal;\n      } tmpVal;\n\n      tmpVal.fltVal = value;\n      result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) ==\n                           0x7FF00000 &&\n                           ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\n                            (tmpVal.bitVal.words.wordL != 0) ));\n    }\n\n    return result;\n  }\n\n  /* Test if single-precision value is not a number */\n  boolean_T rtIsNaNF(real32_T value)\n  {\n    IEEESingle tmp;\n    tmp.wordL.wordLreal = value;\n    return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\n                       (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\n  }\n}\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rt_nonfinite.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.506\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Tue Dec 12 16:07:50 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rt_nonfinite_h_\n#define RTW_HEADER_rt_nonfinite_h_\n#include <stddef.h>\n#include \"rtwtypes.h\"\n#define NOT_USING_NONFINITE_LITERALS   1\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern real_T rtInf;\n  extern real_T rtMinusInf;\n  extern real_T rtNaN;\n  extern real32_T rtInfF;\n  extern real32_T rtMinusInfF;\n  extern real32_T rtNaNF;\n  extern void rt_InitInfAndNaN(size_t realSize);\n  extern boolean_T rtIsInf(real_T value);\n  extern boolean_T rtIsInfF(real32_T value);\n  extern boolean_T rtIsNaN(real_T value);\n  extern boolean_T rtIsNaNF(real32_T value);\n  struct BigEndianIEEEDouble {\n    struct {\n      uint32_T wordH;\n      uint32_T wordL;\n    } words;\n  };\n\n  struct LittleEndianIEEEDouble {\n    struct {\n      uint32_T wordL;\n      uint32_T wordH;\n    } words;\n  };\n\n  struct IEEESingle {\n    union {\n      real32_T wordLreal;\n      uint32_T wordLuint;\n    } wordL;\n  };\n\n#ifdef __cplusplus\n\n}                                      /* extern \"C\" */\n\n#endif\n#endif                                 /* RTW_HEADER_rt_nonfinite_h_ */\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtwtypes.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.506\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Tue Dec 12 16:07:50 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTWTYPES_H\n#define RTWTYPES_H\n#include \"tmwtypes.h\"\n#ifndef POINTER_T\n#define POINTER_T\n\ntypedef void * pointer_T;\n\n#endif\n\n/* Logical type definitions */\n#if (!defined(__cplusplus))\n#ifndef false\n#define false                          (0U)\n#endif\n\n#ifndef true\n#define true                           (1U)\n#endif\n#endif\n\n#ifndef INT64_T\n#define INT64_T\n\ntypedef long int64_T;\n\n#define MAX_int64_T                    ((int64_T)(9223372036854775807L))\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807L-1L))\n#endif\n\n#ifndef UINT64_T\n#define UINT64_T\n\ntypedef unsigned long uint64_T;\n\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFUL))\n#endif\n\n/*===========================================================================*\n * Additional complex number type definitions                                           *\n *===========================================================================*/\n#ifndef CINT64_T\n#define CINT64_T\n\ntypedef struct {\n  int64_T re;\n  int64_T im;\n} cint64_T;\n\n#endif\n\n#ifndef CUINT64_T\n#define CUINT64_T\n\ntypedef struct {\n  uint64_T re;\n  uint64_T im;\n} cuint64_T;\n\n#endif\n#endif                                 /* RTWTYPES_H */\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Interface files","code":"/*\n *  rtmodel.h:\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.506\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Tue Dec 12 16:07:50 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rtmodel_h_\n#define RTW_HEADER_rtmodel_h_\n#include \"ATTN.h\"\n#define GRTINTERFACE                   0\n#endif                                 /* RTW_HEADER_rtmodel_h_ */\n"},{"name":"sg_IO191_ad_s.c","type":"source","group":"interface","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw/../../../.speedgoat/speedgoatlib/R2023a/9.6.1.1_4/sg_blocks/analog","tag":"","groupDisplay":"Interface files","code":"// Copyright 2006-2023 Speedgoat GmbH\r\n\r\n#define S_FUNCTION_LEVEL    (0xd87+330-0xecf)\r\n#undef S_FUNCTION_NAME\r\n#define S_FUNCTION_NAME     sg_IO191_ad_s\r\n#include \"sg_IO191.h\"\r\n#ifndef MATLAB_MEX_FILE\r\n#include \"sg_printf.h\"\r\n#include \"sg_common.h\"\r\nvoid readPciBar(sg_PCIDevice*z7c46aa329e,int16_t bus,int16_t slot,int16_t z1e0fd5210f);\r\n#else\r\n#include \"mex.h\"\r\n#endif\r\n#include \"sg_callback.h\"\r\n#define ze13f49a01f           ssGetSFcnParam(S, (0x1421+4652-0x264d))\r\n#define z3832b85a32           ssGetSFcnParam(S, (0x82d+2280-0x1114))\r\n#define z702a26a5e9                ssGetSFcnParam(S, (0x141f+3266-0x20df))\r\n#define z3644586f49         ssGetSFcnParam(S, (0x6bc+3711-0x1538))\r\n#define z8d5c288b32         ssGetSFcnParam(S, (0x1a40+450-0x1bfe))\r\n#define zb66856d060         ssGetSFcnParam(S, (0x20ad+932-0x244c))\r\n#define z9876548c58         ssGetSFcnParam(S, (0x303+2144-0xb5d))\r\n#define zb093e77094      ssGetSFcnParam(S, (0x1650+3950-0x25b7))\r\n#define z2948f18e24        ssGetSFcnParam(S, (0x1310+1501-0x18e5))\r\n#define zdf24515981                           ((0x92c+2706-0x13b5))\r\n#define z7e2eeaa57c          ((0x1dfc+2294-0x26f2))\r\n#define zc0ced48ecf              ((0x770+2705-0x1200))\r\n#define z2e6483d505              ((0x110a+5601-0x26e9))\r\n#define zc5ce4cb81a              ((0x40d+302-0x53b))\r\n#define z0194338df7         ((0x21a0+274-0x22b2))\r\n#define z2b17e2ee3b              ((0x44b+4814-0x1718))\r\nstatic double zfc19727a48(uint32_t zf4d6a48e37);static char msg[z71934bf57c];static void mdlInitializeSizes(SimStruct*S){uint16_t i;ssSetNumSFcnParams(S,zdf24515981);if(ssGetNumSFcnParams(S)!=ssGetSFcnParamsCount(S)){sprintf(msg,\"\\x57\\x72\\x6f\\x6e\\x67\\x20\\x6e\\x75\\x6d\\x62\\x65\\x72\\x20\\x6f\\x66\\x20\\x69\\x6e\\x70\\x75\\x74\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x70\\x61\\x73\\x73\\x65\\x64\\x2e\" \"\\n\" \"\\x25\\x64\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x61\\x72\\x65\\x20\\x65\\x78\\x70\\x65\\x63\\x74\\x65\\x64\" \"\\n\",zdf24515981);ssSetErrorStatus(S,msg);return;}ssSetNumContStates(S,(0x49a+6035-0x1c2d));ssSetNumDiscStates(S,(0xbbd+3468-0x1949));if(!ssSetNumInputPorts(S,(0xebf+491-0x10aa)))return;if(!ssSetNumOutputPorts(S,(int)mxGetN(z3644586f49)))return;for(i=(0x26b+6461-0x1ba8);i<(int)mxGetN(z3644586f49);i++){ssSetOutputPortWidth(S,i,(0xdf5+2237-0x16b1));}ssSetNumSampleTimes(S,(0x5af+2164-0xe22));ssSetNumRWork(S,zc5ce4cb81a);ssSetNumIWork(S,z2e6483d505);ssSetNumPWork(S,z2b17e2ee3b);ssSetNumModes(S,(0x130+4427-0x127b));ssSetNumNonsampledZCs(S,(0x486+1293-0x993));for(i=(0x135a+368-0x14ca);i<zdf24515981;i++){ssSetSFcnParamTunable(S,i,(0x5eb+5912-0x1d03));}ssSetOptions(S,SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME|SS_OPTION_EXCEPTION_FREE_CODE|SS_OPTION_RUNTIME_EXCEPTION_FREE_CODE);}static void mdlInitializeSampleTimes(SimStruct*S){if(mxGetPr(z3832b85a32)[(0xbc9+611-0xe2c)]==-1.0){ssSetSampleTime(S,(0xf9d+3333-0x1ca2),INHERITED_SAMPLE_TIME);ssSetOffsetTime(S,(0xa0f+3396-0x1753),FIXED_IN_MINOR_STEP_OFFSET);}else{ssSetSampleTime(S,(0x2e3+889-0x65c),mxGetPr(z3832b85a32)[(0xb5d+6245-0x23c2)]);ssSetOffsetTime(S,(0xa80+96-0xae0),0.0);}ssSetModelReferenceSampleTimeDefaultInheritance(S);}\r\n#ifndef MATLAB_MEX_FILE\r\nstatic void sg_ModelLoad(SimStruct*S){}static void sg_ModelStart(SimStruct*S){sg_PCIDevice zeccbadd9b3;uint32_t bus,slot,za0d38ae598,ze5e89e1937,i;uint16_t z4e3026977c,zf91d71c6d9;volatile uint32_t*z27fd94ac66;if(mxGetN(z702a26a5e9)==(0x11b2+4500-0x2345)){bus=(0x8f8+5136-0x1d08);slot=(uint32_t)mxGetPr(z702a26a5e9)[(0xbc2+6909-0x26bf)];}else{bus=(uint32_t)mxGetPr(z702a26a5e9)[(0x730+109-0x79d)];slot=(uint32_t)mxGetPr(z702a26a5e9)[(0x17e1+1839-0x1f0f)];}za0d38ae598=((uint32_t)mxGetPr(ze13f49a01f)[(0x1cb2+361-0x1e1b)]);if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,za1afbacc4a,z78f5b4c5a6,z2bc00458b9,za0d38ae598,bus,slot)!=(0x3a8+8380-0x2464)){if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,zb765876dc5,z44a525e63d,za64fcbac7d,za0d38ae598,bus,slot)!=(0x83f+3255-0x14f6)){ssSetErrorStatus(S,pSgErrorStr);return;}}\r\n#ifdef _MSC_BUILD\r\nreadPciBar(&zeccbadd9b3,zeccbadd9b3.bus,zeccbadd9b3.slot,(0x6c4+3428-0x1428));\r\n#endif\r\nz27fd94ac66=(volatile uint32_t*)sg_mapMemory(&zeccbadd9b3,(0x168a+226-0x176a));zf91d71c6d9=(uint16_t)mxGetN(z3644586f49);ssSetPWorkValue(S,z0194338df7,(uint32_t*)z27fd94ac66);ssSetIWorkValue(S,z7e2eeaa57c,zf91d71c6d9);if(z27fd94ac66[REVISION]<zb5135f698e){sprintf(msg,\"\\x25\\x73\\x20\\x4d\\x6f\\x64\\x75\\x6c\\x65\\x20\\x49\\x44\\x20\\x25\\x64\\x20\\x46\\x69\\x72\\x6d\\x77\\x61\\x72\\x65\\x20\\x30\\x78\\x25\\x58\\x20\\x69\\x73\\x20\\x6f\\x75\\x74\\x64\\x61\\x74\\x65\\x64\\x2c\\x20\\x70\\x6c\\x65\\x61\\x73\\x65\\x20\\x63\\x6f\\x6e\\x74\\x61\\x63\\x74\\x20\\x53\\x70\\x65\\x65\\x64\\x67\\x6f\\x61\\x74\\x20\\x73\\x75\\x70\\x70\\x6f\\x72\\x74\\x2e\" \"\\n\",DEVNAME,za0d38ae598,z27fd94ac66[REVISION]);ssSetErrorStatus(S,msg);return;}z27fd94ac66[BRP]=((0x1ffa+403-0x218c)<<zbef81c3fd0);z27fd94ac66[z469883b65e]=(0x1175+2396-0x1ad1);z27fd94ac66[zfcd2c661f6]=(uint32_t)(z27fd94ac66[z24765e17f8]/z1a910f8330);SG_PRINTF_DEBUG(\"\\x41\\x44\\x43\\x5f\\x53\\x43\\x41\\x4e\\x5f\\x52\\x41\\x54\\x45\\x20\\x25\\x58\" \"\\n\",z27fd94ac66[zfcd2c661f6]);ze5e89e1937=(0x10f5+710-0x13bb);for(i=(0x7b8+7005-0x2315);i<zf91d71c6d9;i++){z4e3026977c=(uint16_t)mxGetPr(z3644586f49)[i]-(0x1eb+1714-0x89c);switch((uint16_t)mxGetPr(z9876548c58)[i]){case(0x7c7+6388-0x20ba):ze5e89e1937|=(z4eb3456176<<(z4e3026977c*(0x696+4149-0x16c7)));break;case(0x13bc+3824-0x22aa):ze5e89e1937|=(z7239c371e4<<(z4e3026977c*(0x95c+3508-0x170c)));break;case(0x7e9+429-0x993):ze5e89e1937|=(z65195ba21a<<(z4e3026977c*(0x10d6+3390-0x1e10)));break;case(0xb1b+1951-0x12b6):ze5e89e1937|=(z769e3cf99a<<(z4e3026977c*(0x10a3+377-0x1218)));break;case(0xd84+3455-0x1afe):ze5e89e1937|=(zad88ee04d7<<(z4e3026977c*(0x53d+7502-0x2287)));break;case(0x17d2+2662-0x2232):ze5e89e1937|=(z04726aa6f4<<(z4e3026977c*(0xb6f+4410-0x1ca5)));break;case(0x602+7248-0x224b):ze5e89e1937|=(zca8a2e109e<<(z4e3026977c*(0x9d4+6839-0x2487)));break;default:sprintf(msg,\"\\x41\\x6e\\x61\\x6c\\x6f\\x67\\x20\\x49\\x6e\\x70\\x75\\x74\\x73\\x20\\x75\\x6e\\x6b\\x6e\\x6f\\x77\\x6e\\x20\\x76\\x6f\\x6c\\x74\\x61\\x67\\x65\");ssSetErrorStatus(S,msg);break;}}z27fd94ac66[z3f2dd8a551]=ze5e89e1937;SG_PRINTF_DEBUG(\"\\x47\\x61\\x69\\x6e\\x20\\x72\\x65\\x67\\x69\\x73\\x74\\x65\\x72\\x3a\\x20\\x25\\x58\\x20\" \"\\n\",ze5e89e1937);ssSetIWorkValue(S,zc0ced48ecf,(0xfab+4387-0x20cd));}static void sg_ModelStep(SimStruct*S){uint16_t zf91d71c6d9=ssGetIWorkValue(S,z7e2eeaa57c);uint16_t z4d3816b14e=(uint16_t)mxGetPr(z3644586f49)[zf91d71c6d9-(0xd9+7701-0x1eed)]-(0x2211+510-0x240e);volatile uint32_t*z27fd94ac66=ssGetPWorkValue(S,z0194338df7);uint32_t ze77fa94a00=(uint32_t)mxGetPr(z8d5c288b32)[(0x8bb+460-0xa87)]-(0x1035+2325-0x1949);uint32_t i,z812c65ff2f,z297b36fb23,z41c8844f54;double*y;if((uint16_t)ssGetIWorkValue(S,zc0ced48ecf)==(0x2208+15-0x2216)){z27fd94ac66[z75b6a00559]=393322|((z4d3816b14e&(0x1666+1643-0x1cca))<<z690b1cd3dc)|(ze77fa94a00<<z0a8926012b)|((0xd23+2873-0x185b)<<z55588371ab);for(i=(0x19ec+199-0x1ab3);(z27fd94ac66[z75b6a00559]>>(0x29a+8557-0x23f7))>(0x46c+1030-0x86e);i++){if(i>1193000.0*1.0){sprintf(msg,\"\\x25\\x73\\x20\\x66\\x61\\x69\\x6c\\x65\\x64\\x20\\x74\\x6f\\x20\\x63\\x6f\\x6e\\x66\\x69\\x67\\x20\\x41\\x6e\\x61\\x6c\\x6f\\x67\\x20\\x69\\x6e\\x70\\x75\\x74\\x20\\x72\\x65\\x67\\x20\\x30\\x78\\x25\\x78\",DEVNAME,z27fd94ac66[z75b6a00559]>>(0x49a+8581-0x260f));ssSetErrorStatus(S,msg);return;}}ssSetIWorkValue(S,zc0ced48ecf,(0xf36+511-0x1135));}z41c8844f54=z27fd94ac66[zee1550bec3];for(i=(0x1c4+4708-0x1428);z41c8844f54<zf91d71c6d9;i++){if(i>1193000.0*2.0){sprintf(msg,\"\\x25\\x73\\x20\\x66\\x61\\x69\\x6c\\x65\\x64\\x20\\x74\\x6f\\x20\\x73\\x74\\x61\\x72\\x74\\x20\\x41\\x6e\\x61\\x6c\\x6f\\x67\\x20\\x69\\x6e\\x70\\x75\\x74\",DEVNAME);ssSetErrorStatus(S,msg);return;}z41c8844f54=z27fd94ac66[zee1550bec3];}for(i=(0x1db1+843-0x20fc);i<=z41c8844f54;i++){z297b36fb23=z27fd94ac66[zceb273b472];if(!(z297b36fb23&((0xbdf+1279-0x10dd)<<(0x256+8210-0x2249)))){for(z812c65ff2f=(0x18ba+2896-0x240a);z812c65ff2f<zf91d71c6d9;z812c65ff2f++){if(((uint16_t)mxGetPr(z3644586f49)[z812c65ff2f]-(0x854+693-0xb08))==(uint16_t)((z297b36fb23>>z09b806e22a)&(0x658+4661-0x1886))){y=ssGetOutputPortSignal(S,z812c65ff2f);y[(0x15ac+4118-0x25c2)]=zfc19727a48(z297b36fb23);break;}}}}z27fd94ac66[z75b6a00559]=393322|((z4d3816b14e&(0x3ea+1890-0xb45))<<z690b1cd3dc)|(ze77fa94a00<<z0a8926012b)|((0x303+95-0x361)<<\r\nz55588371ab);}static void sg_ModelStop(SimStruct*S){volatile uint32_t*z27fd94ac66=ssGetPWorkValue(S,z0194338df7);z27fd94ac66[BRP]=((0xb2b+1334-0x1060)<<zbef81c3fd0);}\r\n#endif  \r\nstatic double zfc19727a48(uint32_t zf4d6a48e37){double ze485f859ed;uint16_t z1044b54040=(zf4d6a48e37>>z2d5a35d68d)&(0x460+7091-0x200c);const double z3dec4d2bb3[(0xbf5+6672-0x25fd)]={24.576/32768,10.24/32768,5.12/32768,2.56/32768,1.28/32768,0.64/32768,65535,20.48/32768};if(((zf4d6a48e37>>z2858a50a43)&(0x1c5a+2555-0x2654))>(0x161d+1278-0x1b1b)){ze485f859ed=((((double)(zf4d6a48e37&65535))-z7935114df5)*z3dec4d2bb3[z1044b54040]);}else{ze485f859ed=(((double)(zf4d6a48e37&65535))*z3dec4d2bb3[z1044b54040]);}return ze485f859ed;}\r\n#include \"sg_sfcn_glue.h\"   \r\n\r\n"},{"name":"sg_IO191_da_s.c","type":"source","group":"interface","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw/../../../.speedgoat/speedgoatlib/R2023a/9.6.1.1_4/sg_blocks/analog","tag":"","groupDisplay":"Interface files","code":"// Copyright 2006-2023 Speedgoat GmbH\r\n\r\n#define S_FUNCTION_LEVEL    (0x115c+4425-0x22a3)\r\n#undef S_FUNCTION_NAME\r\n#define S_FUNCTION_NAME     sg_IO191_da_s\r\n#include \"sg_IO191.h\"\r\n#ifndef MATLAB_MEX_FILE\r\n#include \"sg_printf.h\"\r\n#include \"sg_common.h\"\r\nvoid readPciBar(sg_PCIDevice*z7c46aa329e,int16_t bus,int16_t slot,int16_t z1e0fd5210f);\r\n#else\r\n#include \"mex.h\"\r\n#endif\r\n#include \"sg_callback.h\"\r\n#define ze13f49a01f           ssGetSFcnParam(S, (0x1087+3465-0x1e10))\r\n#define z3832b85a32           ssGetSFcnParam(S, (0x1144+2969-0x1cdc))\r\n#define z702a26a5e9                ssGetSFcnParam(S, (0x660+1141-0xad3))\r\n#define zfa79626a1f        ssGetSFcnParam(S, (0x10ac+2040-0x18a1))\r\n#define z832477988f        ssGetSFcnParam(S, (0x1c80+1808-0x238c))\r\n#define ze4bd57db54     ssGetSFcnParam(S, (0x161b+2429-0x1f93))\r\n#define zc6e5e42eac       ssGetSFcnParam(S, (0xd37+1615-0x1380))\r\n#define zdf24515981                           ((0x1da7+1552-0x23b0))\r\n#define z2e6483d505              ((0x1151+3974-0x20d7))\r\n#define zc5ce4cb81a              ((0xbe1+209-0xcb2))\r\n#define z0194338df7         ((0x2103+180-0x21b7))\r\n#define z2b17e2ee3b              ((0x22+1846-0x757))\r\nstatic int32_t z58d7aabac0(uint32_t zc8abac822d,double z7e546ae0bf);static char msg[z71934bf57c];static void mdlInitializeSizes(SimStruct*S){uint16_t i;ssSetNumSFcnParams(S,zdf24515981);if(ssGetNumSFcnParams(S)!=ssGetSFcnParamsCount(S)){sprintf(msg,\"\\x57\\x72\\x6f\\x6e\\x67\\x20\\x6e\\x75\\x6d\\x62\\x65\\x72\\x20\\x6f\\x66\\x20\\x69\\x6e\\x70\\x75\\x74\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x70\\x61\\x73\\x73\\x65\\x64\\x2e\" \"\\n\" \"\\x25\\x64\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x61\\x72\\x65\\x20\\x65\\x78\\x70\\x65\\x63\\x74\\x65\\x64\" \"\\n\",zdf24515981);ssSetErrorStatus(S,msg);return;}ssSetNumContStates(S,(0x1b18+885-0x1e8d));ssSetNumDiscStates(S,(0x4d+3063-0xc44));if(!ssSetNumOutputPorts(S,(0x1f6+1692-0x892)))return;if(!ssSetNumInputPorts(S,(int)mxGetN(zfa79626a1f)))return;for(i=(0xa3f+2563-0x1442);i<(int)mxGetN(zfa79626a1f);i++){ssSetInputPortWidth(S,i,(0x1d1c+2074-0x2535));ssSetInputPortDirectFeedThrough(S,i,(0x496+6731-0x1ee0));ssSetInputPortRequiredContiguous(S,i,(0x205+938-0x5ae));}ssSetNumSampleTimes(S,(0x7c8+3155-0x141a));ssSetNumRWork(S,zc5ce4cb81a);ssSetNumIWork(S,z2e6483d505);ssSetNumPWork(S,z2b17e2ee3b);ssSetNumModes(S,(0xf24+2439-0x18ab));ssSetNumNonsampledZCs(S,(0x8e6+1662-0xf64));for(i=(0xdf9+3148-0x1a45);i<zdf24515981;i++){ssSetSFcnParamTunable(S,i,(0xfd7+1134-0x1445));}ssSetOptions(S,SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME|SS_OPTION_EXCEPTION_FREE_CODE|SS_OPTION_RUNTIME_EXCEPTION_FREE_CODE);}static void mdlInitializeSampleTimes(SimStruct*S){if(mxGetPr(z3832b85a32)[(0x13f3+1824-0x1b13)]==-1.0){ssSetSampleTime(S,(0x5bf+1780-0xcb3),INHERITED_SAMPLE_TIME);ssSetOffsetTime(S,(0x94c+4883-0x1c5f),FIXED_IN_MINOR_STEP_OFFSET);}else{ssSetSampleTime(S,(0xb6d+6577-0x251e),mxGetPr(z3832b85a32)[(0xccc+4368-0x1ddc)]);ssSetOffsetTime(S,(0x1f04+788-0x2218),0.0);}ssSetModelReferenceSampleTimeDefaultInheritance(S);}\r\n#ifndef MATLAB_MEX_FILE\r\nstatic void sg_ModelLoad(SimStruct*S){}static void sg_ModelStart(SimStruct*S){sg_PCIDevice zeccbadd9b3;uint32_t bus,slot,za0d38ae598;volatile uint32_t*z27fd94ac66;uint16_t z879ede9171=(uint16_t)mxGetN(zfa79626a1f);uint32_t z812c65ff2f,zc8abac822d,zc430a259a4;uint16_t i,z4e3026977c;int32_t z7711a772ed;double z7e546ae0bf;if(mxGetN(z702a26a5e9)==(0x11ca+257-0x12ca)){bus=(0xef0+5035-0x229b);slot=(uint32_t)mxGetPr(z702a26a5e9)[(0x8e9+5014-0x1c7f)];}else{bus=(uint32_t)mxGetPr(z702a26a5e9)[(0xffa+5633-0x25fb)];slot=(uint32_t)mxGetPr(z702a26a5e9)[(0x76+3457-0xdf6)];}za0d38ae598=((uint32_t)mxGetPr(ze13f49a01f)[(0x74f+3385-0x1488)]);if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,za1afbacc4a,z78f5b4c5a6,z2bc00458b9,za0d38ae598,bus,slot)!=(0x14cd+3154-0x211f)){if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,zb765876dc5,z44a525e63d,za64fcbac7d,za0d38ae598,bus,slot)!=(0x1d1+4045-0x119e)){ssSetErrorStatus(S,pSgErrorStr);return;}}\r\n#ifdef _MSC_BUILD\r\nreadPciBar(&zeccbadd9b3,zeccbadd9b3.bus,zeccbadd9b3.slot,(0x2c3+7285-0x1f38));\r\n#endif\r\nz27fd94ac66=(volatile uint32_t*)sg_mapMemory(&zeccbadd9b3,(0x12c2+3206-0x1f46));ssSetPWorkValue(S,z0194338df7,(uint32_t*)z27fd94ac66);for(i=(0x450+2145-0xcb1);i<z879ede9171;i++){zc430a259a4=(0xaea+2788-0x15ce);z4e3026977c=(uint16_t)mxGetPr(zfa79626a1f)[i]-(0x260+1861-0x9a4);zc8abac822d=(uint32_t)mxGetPr(z832477988f)[i]-(0xedc+3261-0x1b98);z7e546ae0bf=(double)mxGetPr(ze4bd57db54)[z4e3026977c];z7711a772ed=z58d7aabac0(zc8abac822d,z7e546ae0bf);zc430a259a4=(z7711a772ed&65535)|((z4e3026977c&(0x865+2053-0x105b))<<z18b319d394)|(zbec0ec695f<<z668ef58fc5);if(z27fd94ac66[REVISION]>=z5f130b7753){for(z812c65ff2f=(0x52+4871-0x1359);z27fd94ac66[zeeea544396]&((0x166d+167-0x1713)<<z579611d67f);z812c65ff2f++){if(z812c65ff2f>1193000.0*1.0){sprintf(msg,\"\\x25\\x73\\x20\\x41\\x6e\\x61\\x6c\\x6f\\x67\\x20\\x4f\\x75\\x74\\x70\\x75\\x74\\x20\\x53\\x50\\x49\\x20\\x69\\x73\\x20\\x62\\x75\\x73\\x79\",DEVNAME);ssSetErrorStatus(S,msg);return;}}z27fd94ac66[zeeea544396]=zc430a259a4;}else{z27fd94ac66[zeeea544396]=zc430a259a4;sg_wait_ns(z905251a4e4);}zc430a259a4=(zc8abac822d&65535)|((z4e3026977c&(0x155c+3961-0x24c6))<<z18b319d394)|(z4d4e3e315a<<z668ef58fc5);if(z27fd94ac66[REVISION]>=z5f130b7753){for(z812c65ff2f=(0x127c+2160-0x1aec);z27fd94ac66[zeeea544396]&((0x22e0+1009-0x26d0)<<z579611d67f);z812c65ff2f++){if(z812c65ff2f>1193000.0*1.0){sprintf(msg,\"\\x25\\x73\\x20\\x41\\x6e\\x61\\x6c\\x6f\\x67\\x20\\x4f\\x75\\x74\\x70\\x75\\x74\\x20\\x53\\x50\\x49\\x20\\x69\\x73\\x20\\x62\\x75\\x73\\x79\",DEVNAME);ssSetErrorStatus(S,msg);return;}}z27fd94ac66[zeeea544396]=zc430a259a4;}else{z27fd94ac66[zeeea544396]=zc430a259a4;sg_wait_ns(z905251a4e4);}}}static void sg_ModelStep(SimStruct*S){volatile uint32_t*z27fd94ac66=ssGetPWorkValue(S,z0194338df7);uint16_t zf91d71c6d9=(uint16_t)mxGetN(zfa79626a1f);uint32_t zc430a259a4,z26dbd73a5e,zc8abac822d;int32_t out;uint16_t i,z812c65ff2f,z4e3026977c,zd953a322a2,z2ce6e80f45;double*zc7fdaf6331;if(z27fd94ac66[REVISION]>=z5f130b7753){for(i=(0x1f7c+1906-0x26ee);i<zf91d71c6d9;i++){zc430a259a4=(0x9c6+1647-0x1035);z4e3026977c=(uint16_t)mxGetPr(zfa79626a1f)[i]-(0x6ea+700-0x9a5);zc7fdaf6331=(double*)ssGetInputPortRealSignal(S,i);zc8abac822d=(uint32_t)mxGetPr(z832477988f)[i]-(0x10b2+3359-0x1dd0);out=z58d7aabac0(zc8abac822d,zc7fdaf6331[(0xad3+5209-0x1f2c)]);zc430a259a4=(out&65535)|((z4e3026977c&(0xb3c+2889-0x1676))<<z18b319d394)|(zbec0ec695f<<z668ef58fc5);for(z26dbd73a5e=(0x2c3+5143-0x16da);z27fd94ac66[zeeea544396]&((0x1a70+2074-0x2289)<<z579611d67f);z26dbd73a5e++){if(z26dbd73a5e>1193000.0*1.0){sprintf(msg,\"\\x25\\x73\\x20\\x41\\x6e\\x61\\x6c\\x6f\\x67\\x20\\x4f\\x75\\x74\\x70\\x75\\x74\\x20\\x53\\x50\\x49\\x20\\x69\\x73\\x20\\x62\\x75\\x73\\x79\",DEVNAME);ssSetErrorStatus(S,msg);return;}}z27fd94ac66[zeeea544396]=zc430a259a4;}}else{if(zf91d71c6d9>(0x3c2+8185-0x23b9)){zd953a322a2=(0x59d+7459-0x22be);z2ce6e80f45=zf91d71c6d9;}else{zd953a322a2=zf91d71c6d9;z2ce6e80f45=(0x132+8860-0x23ce);}for(i=(0x2e5+2709-0xd7a);i<zd953a322a2;i++){zc430a259a4=(0x644+3281-0x1315);z4e3026977c=(uint16_t)mxGetPr(zfa79626a1f)[i]-(0x1334+4140-0x235f);zc7fdaf6331=(double*)ssGetInputPortRealSignal(S,i);zc8abac822d=(uint32_t)mxGetPr(z832477988f)[i]-(0x8ef+5876-0x1fe2);out=z58d7aabac0(zc8abac822d,zc7fdaf6331[(0x1e5b+1507-0x243e)]);zc430a259a4=(out&65535)|((z4e3026977c&(0x931+1765-0x1007))<<z18b319d394)|(zbec0ec695f<<z668ef58fc5);z27fd94ac66[zeeea544396]=zc430a259a4;sg_wait_ns(z7edc1a4c28);}sg_wait_ns(z7edc1a4c28);for(z812c65ff2f=i;z812c65ff2f<z2ce6e80f45;z812c65ff2f++){zc430a259a4=(0x2e8+7263-0x1f47);z4e3026977c=(uint16_t)mxGetPr(zfa79626a1f)[z812c65ff2f]-(0x109d+4671-0x22db);zc7fdaf6331=(double*)ssGetInputPortRealSignal(S,z812c65ff2f);zc8abac822d=(uint32_t)mxGetPr(z832477988f)[z812c65ff2f]-(0x6ec+3830-0x15e1);out=z58d7aabac0(zc8abac822d,zc7fdaf6331[(0x11+9277-0x244e)]);zc430a259a4=(out&65535)|((z4e3026977c&(0x5d3+5261-0x1a51))<<z18b319d394)|(zbec0ec695f<<z668ef58fc5);z27fd94ac66[zeeea544396]=zc430a259a4;sg_wait_ns(z905251a4e4);}}}static void sg_ModelStop(SimStruct*S){volatile uint32_t*z27fd94ac66=ssGetPWorkValue(S,z0194338df7);uint16_t z879ede9171=(uint16_t)mxGetN(zfa79626a1f);int32_t z7711a772ed;uint32_t z812c65ff2f,zc8abac822d,zc430a259a4;uint16_t i,\r\nz4e3026977c;double z7e546ae0bf;for(i=(0x22c+4901-0x1551);i<z879ede9171;i++){if((int)mxGetPr(zc6e5e42eac)[i]){zc430a259a4=(0x334+5769-0x19bd);z4e3026977c=(uint16_t)mxGetPr(zfa79626a1f)[i]-(0x14cc+4305-0x259c);zc8abac822d=(uint32_t)mxGetPr(z832477988f)[i]-(0xb94+6731-0x25de);z7e546ae0bf=(double)mxGetPr(ze4bd57db54)[z4e3026977c];z7711a772ed=z58d7aabac0(zc8abac822d,z7e546ae0bf);zc430a259a4=(z7711a772ed&65535)|((z4e3026977c&(0x1632+3041-0x2204))<<z18b319d394)|(zbec0ec695f<<z668ef58fc5);if(z27fd94ac66[REVISION]>=z5f130b7753){for(z812c65ff2f=(0xdc6+3965-0x1d43);z27fd94ac66[zeeea544396]&((0xf3f+5553-0x24ef)<<z579611d67f);z812c65ff2f++){if(z812c65ff2f>1193000.0*1.0){sprintf(msg,\"\\x25\\x73\\x20\\x41\\x6e\\x61\\x6c\\x6f\\x67\\x20\\x4f\\x75\\x74\\x70\\x75\\x74\\x20\\x53\\x50\\x49\\x20\\x69\\x73\\x20\\x62\\x75\\x73\\x79\",DEVNAME);ssSetErrorStatus(S,msg);return;}}z27fd94ac66[zeeea544396]=zc430a259a4;}else{z27fd94ac66[zeeea544396]=zc430a259a4;sg_wait_ns(z905251a4e4);}zc430a259a4=(zc8abac822d&65535)|((z4e3026977c&(0x302+3062-0xee9))<<z18b319d394)|(z4d4e3e315a<<z668ef58fc5);if(z27fd94ac66[REVISION]>=z5f130b7753){for(z812c65ff2f=(0x364+352-0x4c4);z27fd94ac66[zeeea544396]&((0xd3c+126-0xdb9)<<z579611d67f);z812c65ff2f++){if(z812c65ff2f>1193000.0*1.0){sprintf(msg,\"\\x25\\x73\\x20\\x41\\x6e\\x61\\x6c\\x6f\\x67\\x20\\x4f\\x75\\x74\\x70\\x75\\x74\\x20\\x53\\x50\\x49\\x20\\x69\\x73\\x20\\x62\\x75\\x73\\x79\",DEVNAME);ssSetErrorStatus(S,msg);return;}}z27fd94ac66[zeeea544396]=zc430a259a4;}else{z27fd94ac66[zeeea544396]=zc430a259a4;sg_wait_ns(z905251a4e4);}}}}\r\n#endif  \r\nstatic int32_t z58d7aabac0(uint32_t zc8abac822d,double z7e546ae0bf){double z2f029a8902=(0x4a4+220-0x580),ze9f1c9266b=(0x2aa+6656-0x1caa);int32_t out;switch(zc8abac822d){case(0x174b+2220-0x1ff7):z2f029a8902=13107.2;ze9f1c9266b=(0x3bc+8576-0x253c);break;case(0x15c0+1905-0x1d30):z2f029a8902=6553.6;ze9f1c9266b=(0x15dd+3376-0x230d);break;case(0x1653+3958-0x25c7):z2f029a8902=6553.6;ze9f1c9266b=32768;break;case(0xd84+4180-0x1dd5):z2f029a8902=3276.8;ze9f1c9266b=32768;break;case(0x7c3+3343-0x14ce):z2f029a8902=13107.2;ze9f1c9266b=32768;break;default:SG_PRINTF_INFO(\"\\x45\\x72\\x72\\x6f\\x72\\x3a\\x20\\x41\\x6e\\x61\\x6c\\x6f\\x67\\x20\\x4f\\x75\\x74\\x70\\x75\\x74\\x73\\x20\\x75\\x6e\\x6b\\x6e\\x6f\\x77\\x6e\\x20\\x76\\x6f\\x6c\\x74\\x61\\x67\\x65\");break;}out=(int32_t)((z7e546ae0bf*z2f029a8902)+ze9f1c9266b);if(out>z7935114df5){out=z7935114df5;}else if(out<(0x4f4+35-0x517)){out=(0x122b+4047-0x21fa);}return out;}\r\n#include \"sg_sfcn_glue.h\"   \r\n\r\n"},{"name":"sg_IO191_di_s.c","type":"source","group":"interface","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw/../../../.speedgoat/speedgoatlib/R2023a/9.6.1.1_4/sg_blocks/analog","tag":"","groupDisplay":"Interface files","code":"// Copyright 2006-2023 Speedgoat GmbH\r\n\r\n#define S_FUNCTION_LEVEL    (0x490+2482-0xe40)\r\n#undef S_FUNCTION_NAME\r\n#define S_FUNCTION_NAME     sg_IO191_di_s\r\n#include \"sg_IO191.h\"\r\n#ifndef MATLAB_MEX_FILE\r\n#include \"sg_printf.h\"\r\n#include \"sg_common.h\"\r\nvoid readPciBar(sg_PCIDevice*z7c46aa329e,int16_t bus,int16_t slot,int16_t z1e0fd5210f);\r\n#else\r\n#include \"mex.h\"\r\n#endif\r\n#include \"sg_callback.h\"\r\n#define ze13f49a01f           ssGetSFcnParam(S, (0x1759+2617-0x2192))\r\n#define z3832b85a32           ssGetSFcnParam(S, (0x5f8+3193-0x1270))\r\n#define z702a26a5e9                ssGetSFcnParam(S, (0x2c5+4208-0x1333))\r\n#define zb18e38a301           ssGetSFcnParam(S, (0xa61+4466-0x1bd0))\r\n#define zdf24515981                           ((0x16f8+3286-0x23ca))\r\n#define z2e6483d505              ((0x26a+8085-0x21ff))\r\n#define zc5ce4cb81a              ((0x11f5+4924-0x2531))\r\n#define z0194338df7         ((0x3c2+703-0x681))\r\n#define z2b17e2ee3b              ((0x147c+2948-0x1fff))\r\nstatic char msg[z71934bf57c];static void mdlInitializeSizes(SimStruct*S){uint16_t i;ssSetNumSFcnParams(S,zdf24515981);if(ssGetNumSFcnParams(S)!=ssGetSFcnParamsCount(S)){sprintf(msg,\"\\x57\\x72\\x6f\\x6e\\x67\\x20\\x6e\\x75\\x6d\\x62\\x65\\x72\\x20\\x6f\\x66\\x20\\x69\\x6e\\x70\\x75\\x74\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x70\\x61\\x73\\x73\\x65\\x64\\x2e\" \"\\n\" \"\\x25\\x64\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x61\\x72\\x65\\x20\\x65\\x78\\x70\\x65\\x63\\x74\\x65\\x64\" \"\\n\",zdf24515981);ssSetErrorStatus(S,msg);return;}ssSetNumContStates(S,(0xc7b+5592-0x2253));ssSetNumDiscStates(S,(0x1185+3229-0x1e22));if(!ssSetNumInputPorts(S,(0xb62+481-0xd43)))return;if(!ssSetNumOutputPorts(S,(int)mxGetN(zb18e38a301)))return;for(i=(0x1d13+145-0x1da4);i<(int)mxGetN(zb18e38a301);i++){ssSetOutputPortWidth(S,i,(0x486+5466-0x19df));ssSetOutputPortDataType(S,(0x56c+6929-0x207d),SS_DOUBLE);}ssSetNumSampleTimes(S,(0x1a08+2901-0x255c));ssSetNumRWork(S,zc5ce4cb81a);ssSetNumIWork(S,z2e6483d505);ssSetNumPWork(S,z2b17e2ee3b);ssSetNumModes(S,(0x1aad+2738-0x255f));ssSetNumNonsampledZCs(S,(0x1482+3272-0x214a));for(i=(0xd05+5164-0x2131);i<zdf24515981;i++){ssSetSFcnParamTunable(S,i,(0x12db+3246-0x1f89));}ssSetOptions(S,SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME|SS_OPTION_EXCEPTION_FREE_CODE|SS_OPTION_RUNTIME_EXCEPTION_FREE_CODE);}static void mdlInitializeSampleTimes(SimStruct*S){if(mxGetPr(z3832b85a32)[(0x2cd+619-0x538)]==-1.0){ssSetSampleTime(S,(0x136d+3208-0x1ff5),INHERITED_SAMPLE_TIME);ssSetOffsetTime(S,(0x19a0+2894-0x24ee),FIXED_IN_MINOR_STEP_OFFSET);}else{ssSetSampleTime(S,(0x574+6180-0x1d98),mxGetPr(z3832b85a32)[(0x662+3656-0x14aa)]);ssSetOffsetTime(S,(0xbd9+2070-0x13ef),0.0);}ssSetModelReferenceSampleTimeDefaultInheritance(S);}\r\n#ifndef MATLAB_MEX_FILE\r\nstatic void sg_ModelLoad(SimStruct*S){}static void sg_ModelStart(SimStruct*S){sg_PCIDevice zeccbadd9b3;uint32_t bus,slot,za0d38ae598;volatile uint32_t*z27fd94ac66;if(mxGetN(z702a26a5e9)==(0xb62+5554-0x2113)){bus=(0x10ed+5301-0x25a2);slot=(uint32_t)mxGetPr(z702a26a5e9)[(0x874+6135-0x206b)];}else{bus=(uint32_t)mxGetPr(z702a26a5e9)[(0xadd+5988-0x2241)];slot=(uint32_t)mxGetPr(z702a26a5e9)[(0x8cd+1253-0xdb1)];}za0d38ae598=((uint32_t)mxGetPr(ze13f49a01f)[(0x1749+1291-0x1c54)]);if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,za1afbacc4a,z78f5b4c5a6,z2bc00458b9,za0d38ae598,bus,slot)!=(0xf55+4351-0x2054)){if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,zb765876dc5,z44a525e63d,za64fcbac7d,za0d38ae598,bus,slot)!=(0x594+130-0x616)){ssSetErrorStatus(S,pSgErrorStr);return;}}\r\n#ifdef _MSC_BUILD\r\nreadPciBar(&zeccbadd9b3,zeccbadd9b3.bus,zeccbadd9b3.slot,(0x1252+4672-0x2492));\r\n#endif\r\nz27fd94ac66=(volatile uint32_t*)sg_mapMemory(&zeccbadd9b3,(0x189+4706-0x13e9));ssSetPWorkValue(S,z0194338df7,(uint32_t*)z27fd94ac66);}static void sg_ModelStep(SimStruct*S){volatile uint32_t*za42cf7dd4a=ssGetPWorkValue(S,z0194338df7);uint32_t i,input,z4e3026977c;double*y;input=za42cf7dd4a[z52eac5d033];for(i=(0x180b+74-0x1855);i<(uint32_t)mxGetN(zb18e38a301);i++){z4e3026977c=(uint32_t)mxGetPr(zb18e38a301)[i]-(0x2c4+612-0x527);y=ssGetOutputPortSignal(S,i);if(input&((0x2149+672-0x23e8)<<z4e3026977c)){y[(0x1c4c+1042-0x205e)]=(0x60f+1538-0xc10);}else{y[(0xcf3+2372-0x1637)]=(0xc11+4873-0x1f1a);}}}static void sg_ModelStop(SimStruct*S){}\r\n#endif  \r\n#include \"sg_sfcn_glue.h\"   \r\n\r\n"},{"name":"sg_IO191_do_s.c","type":"source","group":"interface","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw/../../../.speedgoat/speedgoatlib/R2023a/9.6.1.1_4/sg_blocks/analog","tag":"","groupDisplay":"Interface files","code":"// Copyright 2006-2023 Speedgoat GmbH\r\n\r\n#define S_FUNCTION_LEVEL    (0x5bf+2361-0xef6)\r\n#undef S_FUNCTION_NAME\r\n#define S_FUNCTION_NAME     sg_IO191_do_s\r\n#include \"sg_IO191.h\"\r\n#ifndef MATLAB_MEX_FILE\r\n#include \"sg_printf.h\"\r\n#include \"sg_common.h\"\r\nvoid readPciBar(sg_PCIDevice*z7c46aa329e,int16_t bus,int16_t slot,int16_t z1e0fd5210f);\r\n#else\r\n#include \"mex.h\"\r\n#endif\r\n#include \"sg_callback.h\"\r\n#define ze13f49a01f           ssGetSFcnParam(S, (0x13e0+4526-0x258e))\r\n#define z3832b85a32           ssGetSFcnParam(S, (0x182+5115-0x157c))\r\n#define z702a26a5e9                ssGetSFcnParam(S, (0xc01+464-0xdcf))\r\n#define z5bc3ce0d50           ssGetSFcnParam(S, (0x776+1601-0xdb4))\r\n#define z2d8f240c11           ssGetSFcnParam(S, (0x1772+625-0x19df))\r\n#define z1f9bebb47b             ssGetSFcnParam(S, (0x1683+2315-0x1f89))\r\n#define zdf24515981                           ((0xf52+4685-0x2199))\r\n#define z2e6483d505              ((0x9a8+3518-0x1766))\r\n#define zc5ce4cb81a              ((0x1263+4888-0x257b))\r\n#define z0194338df7         ((0x1786+2885-0x22cb))\r\n#define z2b17e2ee3b              ((0x17e9+3860-0x26fc))\r\n#define THRESHOLD               0.5\r\nstatic char msg[z71934bf57c];static void mdlInitializeSizes(SimStruct*S){uint16_t i;ssSetNumSFcnParams(S,zdf24515981);if(ssGetNumSFcnParams(S)!=ssGetSFcnParamsCount(S)){sprintf(msg,\"\\x57\\x72\\x6f\\x6e\\x67\\x20\\x6e\\x75\\x6d\\x62\\x65\\x72\\x20\\x6f\\x66\\x20\\x69\\x6e\\x70\\x75\\x74\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x70\\x61\\x73\\x73\\x65\\x64\\x2e\" \"\\n\" \"\\x25\\x64\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x61\\x72\\x65\\x20\\x65\\x78\\x70\\x65\\x63\\x74\\x65\\x64\" \"\\n\",zdf24515981);ssSetErrorStatus(S,msg);return;}ssSetNumContStates(S,(0x140a+1006-0x17f8));ssSetNumDiscStates(S,(0x1616+685-0x18c3));if(!ssSetNumOutputPorts(S,(0x13da+1201-0x188b)))return;if(!ssSetNumInputPorts(S,(int)mxGetN(z5bc3ce0d50)))return;for(i=(0x46b+7087-0x201a);i<(int)mxGetN(z5bc3ce0d50);i++){ssSetInputPortWidth(S,i,(0xe05+6052-0x25a8));ssSetInputPortDirectFeedThrough(S,i,(0xed2+5455-0x2420));ssSetInputPortRequiredContiguous(S,i,(0x12af+3337-0x1fb7));}ssSetNumSampleTimes(S,(0x1528+613-0x178c));ssSetNumRWork(S,zc5ce4cb81a);ssSetNumIWork(S,z2e6483d505);ssSetNumPWork(S,z2b17e2ee3b);ssSetNumModes(S,(0x4cd+6065-0x1c7e));ssSetNumNonsampledZCs(S,(0x117a+4372-0x228e));for(i=(0xf68+410-0x1102);i<zdf24515981;i++){ssSetSFcnParamTunable(S,i,(0x3d8+8140-0x23a4));}ssSetOptions(S,SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME|SS_OPTION_EXCEPTION_FREE_CODE|SS_OPTION_RUNTIME_EXCEPTION_FREE_CODE);}static void mdlInitializeSampleTimes(SimStruct*S){if(mxGetPr(z3832b85a32)[(0x9fa+5271-0x1e91)]==-1.0){ssSetSampleTime(S,(0x11bd+334-0x130b),INHERITED_SAMPLE_TIME);ssSetOffsetTime(S,(0x1899+3649-0x26da),FIXED_IN_MINOR_STEP_OFFSET);}else{ssSetSampleTime(S,(0x136d+1483-0x1938),mxGetPr(z3832b85a32)[(0xbe9+1888-0x1349)]);ssSetOffsetTime(S,(0x46+6698-0x1a70),0.0);}ssSetModelReferenceSampleTimeDefaultInheritance(S);}\r\n#ifndef MATLAB_MEX_FILE\r\nstatic void sg_ModelLoad(SimStruct*S){}static void sg_ModelStart(SimStruct*S){sg_PCIDevice zeccbadd9b3;uint32_t zf91d71c6d9=(uint32_t)mxGetN(z5bc3ce0d50);volatile uint32_t*z27fd94ac66;uint32_t bus,slot,za0d38ae598,zcb341ffb0e,i;if(mxGetN(z702a26a5e9)==(0x9d9+408-0xb70)){bus=(0x149+2546-0xb3b);slot=(uint32_t)mxGetPr(z702a26a5e9)[(0x140a+3821-0x22f7)];}else{bus=(uint32_t)mxGetPr(z702a26a5e9)[(0x7c+6885-0x1b61)];slot=(uint32_t)mxGetPr(z702a26a5e9)[(0x3d3+2043-0xbcd)];}za0d38ae598=((uint32_t)mxGetPr(ze13f49a01f)[(0x1799+3688-0x2601)]);if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,za1afbacc4a,z78f5b4c5a6,z2bc00458b9,za0d38ae598,bus,slot)!=(0x662+3015-0x1229)){if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,zb765876dc5,z44a525e63d,za64fcbac7d,za0d38ae598,bus,slot)!=(0x69c+69-0x6e1)){ssSetErrorStatus(S,pSgErrorStr);return;}}\r\n#ifdef _MSC_BUILD\r\nreadPciBar(&zeccbadd9b3,zeccbadd9b3.bus,zeccbadd9b3.slot,(0xe31+1798-0x1537));\r\n#endif\r\nz27fd94ac66=(volatile uint32_t*)sg_mapMemory(&zeccbadd9b3,(0xd58+5538-0x22f8));ssSetPWorkValue(S,z0194338df7,(uint32_t*)z27fd94ac66);zcb341ffb0e=z27fd94ac66[z52eac5d033];for(i=(0xb41+4562-0x1d13);i<zf91d71c6d9;i++){if((int)mxGetPr(z2d8f240c11)[i]>THRESHOLD){zcb341ffb0e|=((0xda2+5684-0x23d5)<<((uint32_t)mxGetPr(z5bc3ce0d50)[i]-(0x157d+4050-0x254e)));}else{zcb341ffb0e&=~((0x2d6+837-0x61a)<<((uint32_t)mxGetPr(z5bc3ce0d50)[i]-(0x153f+221-0x161b)));}}z27fd94ac66[z52eac5d033]=zcb341ffb0e;}static void sg_ModelStep(SimStruct*S){volatile uint32_t*z27fd94ac66=ssGetPWorkValue(S,z0194338df7);uint16_t z344fcf0ef3;uint32_t i,zcb341ffb0e;double output;double*zc7fdaf6331;z344fcf0ef3=(uint16_t)mxGetN(z5bc3ce0d50);zcb341ffb0e=(0x4fa+3413-0x124f);for(i=(0x36+8129-0x1ff7);i<z344fcf0ef3;i++){zc7fdaf6331=(double*)ssGetInputPortRealSignal(S,i);output=zc7fdaf6331[(0x19e1+2812-0x24dd)];if(output>THRESHOLD){zcb341ffb0e|=((0x671+3271-0x1337)<<((uint16_t)mxGetPr(z5bc3ce0d50)[i]-(0xab+1594-0x6e4)));}}z27fd94ac66[z52eac5d033]=zcb341ffb0e;}static void sg_ModelStop(SimStruct*S){volatile uint32_t*z27fd94ac66=ssGetPWorkValue(S,z0194338df7);uint32_t zf91d71c6d9=(uint32_t)mxGetN(z5bc3ce0d50);uint32_t i,zcb341ffb0e;zcb341ffb0e=z27fd94ac66[z52eac5d033];for(i=(0x651+2318-0xf5f);i<zf91d71c6d9;i++){if((int)mxGetPr(z1f9bebb47b)[i]==(0x127d+4999-0x2603)){if((int)mxGetPr(z2d8f240c11)[i]>THRESHOLD){zcb341ffb0e|=((0x11fa+1665-0x187a)<<((uint32_t)mxGetPr(z5bc3ce0d50)[i]-(0x996+7480-0x26cd)));}else{zcb341ffb0e&=~((0x1a70+576-0x1caf)<<((uint32_t)mxGetPr(z5bc3ce0d50)[i]-(0x85f+5265-0x1cef)));}}}z27fd94ac66[z52eac5d033]=zcb341ffb0e;}\r\n#endif  \r\n#include \"sg_sfcn_glue.h\"   \r\n\r\n"},{"name":"sg_IO191_setup_s.c","type":"source","group":"interface","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw/../../../.speedgoat/speedgoatlib/R2023a/9.6.1.1_4/sg_blocks/analog","tag":"","groupDisplay":"Interface files","code":"// Copyright 2006-2023 Speedgoat GmbH\r\n\r\n#define S_FUNCTION_LEVEL    (0x10cb+2737-0x1b7a)\r\n#undef S_FUNCTION_NAME\r\n#define S_FUNCTION_NAME     sg_IO191_setup_s\r\n#include \"sg_IO191.h\"\r\n#ifndef MATLAB_MEX_FILE\r\n#include \"sg_printf.h\"\r\n#include \"sg_common.h\"\r\nvoid readPciBar(sg_PCIDevice*z7c46aa329e,int16_t bus,int16_t slot,int16_t z1e0fd5210f);\r\n#else\r\n#include \"mex.h\"\r\n#endif\r\n#include \"sg_callback.h\"\r\n#define z702a26a5e9                ssGetSFcnParam(S, (0x154+6099-0x1927))\r\n#define ze13f49a01f           ssGetSFcnParam(S, (0xaa2+2017-0x1282))\r\n#define z1e0b67709d       ssGetSFcnParam(S, (0x7b7+749-0xaa2))\r\n#define z3644586f49         ssGetSFcnParam(S, (0x1a0c+2186-0x2293))\r\n#define z8d5c288b32         ssGetSFcnParam(S, (0x42b+217-0x500))\r\n#define z9876548c58         ssGetSFcnParam(S, (0xff7+3171-0x1c55))\r\n#define zfa79626a1f        ssGetSFcnParam(S, (0xb19+229-0xbf8))\r\n#define z832477988f        ssGetSFcnParam(S, (0xcbc+1663-0x1334))\r\n#define z4526a8632b         ssGetSFcnParam(S, (0xc27+2227-0x14d2))\r\n#define zdf24515981                           ((0xe83+6110-0x2658))\r\n#define z2e6483d505              ((0x1e94+1092-0x22d8))\r\n#define z8caad2a8e6              ((0x551+1754-0xc2b))\r\n#define z5bfe7a2613            ((0x1341+4557-0x250d))\r\n#define zc5ce4cb81a              ((0x1152+4077-0x213d))\r\n#define z0194338df7         ((0x841+6504-0x21a9))\r\n#define z2b17e2ee3b              ((0x1e5+7568-0x1f74))\r\nstatic char msg[z71934bf57c];static void mdlInitializeSizes(SimStruct*S){uint16_t i;ssSetNumSFcnParams(S,zdf24515981);if(ssGetNumSFcnParams(S)!=ssGetSFcnParamsCount(S)){sprintf(msg,\"\\x57\\x72\\x6f\\x6e\\x67\\x20\\x6e\\x75\\x6d\\x62\\x65\\x72\\x20\\x6f\\x66\\x20\\x69\\x6e\\x70\\x75\\x74\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x70\\x61\\x73\\x73\\x65\\x64\\x2e\" \"\\n\" \"\\x25\\x64\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x61\\x72\\x65\\x20\\x65\\x78\\x70\\x65\\x63\\x74\\x65\\x64\" \"\\n\",zdf24515981);ssSetErrorStatus(S,msg);return;}ssSetNumContStates(S,(0x2e0+9175-0x26b7));ssSetNumDiscStates(S,(0xa2b+4369-0x1b3c));if(!ssSetNumInputPorts(S,(0x2070+1166-0x24fe)))return;if(!ssSetNumOutputPorts(S,(0x46+573-0x283)))return;ssSetNumSampleTimes(S,(0x16a5+3548-0x2480));ssSetNumRWork(S,zc5ce4cb81a);ssSetNumIWork(S,z2e6483d505);ssSetNumPWork(S,z2b17e2ee3b);ssSetNumModes(S,(0xecd+231-0xfb4));ssSetNumNonsampledZCs(S,(0x147f+2175-0x1cfe));for(i=(0x8c2+6705-0x22f3);i<zdf24515981;i++){ssSetSFcnParamTunable(S,i,(0x72d+7595-0x24d8));}ssSetOptions(S,SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME|SS_OPTION_EXCEPTION_FREE_CODE|SS_OPTION_RUNTIME_EXCEPTION_FREE_CODE|SS_OPTION_PLACE_ASAP);}static void mdlInitializeSampleTimes(SimStruct*S){ssSetSampleTime(S,(0x21b6+431-0x2365),INHERITED_SAMPLE_TIME);ssSetOffsetTime(S,(0xc59+5933-0x2386),FIXED_IN_MINOR_STEP_OFFSET);ssSetModelReferenceSampleTimeDefaultInheritance(S);}\r\n#ifndef MATLAB_MEX_FILE\r\nstatic void sg_ModelLoad(SimStruct*S){}static void sg_ModelStart(SimStruct*S){sg_PCIDevice zeccbadd9b3;uint32_t bus,slot,za0d38ae598,i;uint16_t z4e3026977c,z0e26ef1137;volatile uint32_t*z27fd94ac66;if(mxGetN(z702a26a5e9)==(0x2413+265-0x251b)){bus=(0x1286+3641-0x20bf);slot=(uint32_t)mxGetPr(z702a26a5e9)[(0xb13+5593-0x20ec)];}else{bus=(uint32_t)mxGetPr(z702a26a5e9)[(0x1ea3+159-0x1f42)];slot=(uint32_t)mxGetPr(z702a26a5e9)[(0x9dd+2573-0x13e9)];}za0d38ae598=((uint32_t)mxGetPr(ze13f49a01f)[(0xba+8255-0x20f9)]);if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,za1afbacc4a,z78f5b4c5a6,z2bc00458b9,za0d38ae598,bus,slot)!=(0x1bed+1278-0x20eb)){if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,zb765876dc5,z44a525e63d,za64fcbac7d,za0d38ae598,bus,slot)!=(0x160+861-0x4bd)){ssSetErrorStatus(S,pSgErrorStr);return;}}\r\n#ifdef _MSC_BUILD\r\nreadPciBar(&zeccbadd9b3,zeccbadd9b3.bus,zeccbadd9b3.slot,(0x3bb+8030-0x2319));\r\n#endif\r\nz27fd94ac66=(volatile uint32_t*)sg_mapMemory(&zeccbadd9b3,(0x1017+4953-0x236e));ssSetPWorkValue(S,z0194338df7,(uint32_t*)z27fd94ac66);SG_PRINTF_DEBUG(\"\\x25\\x73\\x3a\\x20\\x46\\x50\\x47\\x41\\x20\\x72\\x65\\x76\\x20\\x30\\x78\\x25\\x58\" \"\\n\",DEVNAME,z27fd94ac66[REVISION]);z0e26ef1137=(0x3d2+7874-0x2294);for(i=(0xf05+2232-0x17bd);i<(uint32_t)mxGetN(z4526a8632b);i++){z4e3026977c=(uint32_t)mxGetPr(z4526a8632b)[i];if(z4e3026977c==(0xdb5+5768-0x243c)){z0e26ef1137=(0x21f3+336-0x2342);}else{z0e26ef1137|=((0xf52+2401-0x18b2)<<(z4e3026977c+(0x145c+4654-0x2684)));}}z27fd94ac66[zef0a03cb9f]=z0e26ef1137;}static void sg_ModelStep(SimStruct*S){}static void sg_ModelStop(SimStruct*S){}\r\n#endif  \r\n#include \"sg_sfcn_glue.h\"   \r\n\r\n"},{"name":"main.cpp","type":"source","group":"legacy","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Other files","code":"/* Main generated for Simulink Real-Time model ATTN */\n#include <ModelInfo.hpp>\n#include <utilities.hpp>\n#include \"ATTN.h\"\n#include \"rte_ATTN_parameters.h\"\n\n/* Task descriptors */\nslrealtime::TaskInfo task_1( 0u, std::bind(ATTN_step), slrealtime::TaskInfo::PERIODIC, 0.001, 0, 40);\n\n/* Executable base address for XCP */\n#ifdef __linux__\nextern char __executable_start;\nstatic uintptr_t const base_address = reinterpret_cast<uintptr_t>(&__executable_start);\n#else\n/* Set 0 as placeholder, to be parsed later from /proc filesystem */\nstatic uintptr_t const base_address = 0;\n#endif\n\n/* Model descriptor */\nslrealtime::ModelInfo ATTN_Info =\n{\n    \"ATTN\",\n    ATTN_initialize,\n    ATTN_terminate,\n    []()->char const*& { return ATTN_M->errorStatus; },\n    []()->unsigned char& { return ATTN_M->Timing.stopRequestedFlag; },\n    { task_1 },\n    slrealtime::getSegmentVector()\n};\n\nint main(int argc, char *argv[]) {\n    slrealtime::BaseAddress::set(base_address);\n    return slrealtime::runModel(argc, argv, ATTN_Info);\n}\n"},{"name":"rt_matrx.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2023a/rtw/c/src","tag":"","groupDisplay":"Other files","code":"/* File    : rt_matrx.c\n * Abstract:\n *      Implements stand alone matrix access and creation routines.\n *\tThere are two types of MATLAB objects which can be \"passed\" to\n *\tthe generated code, a 2D real matrix and a string. Strings are\n *\tpassed as 2D real matrices. The first two elements of an S-function\n *\tparameters are the row and column (m and n) dimensions respectively.\n *\tThese are followed by the matrix data.\n */\n\n\n\n/*\n * Copyright 1994-2022 The MathWorks, Inc.\n */\n\n/*==========*\n * Includes *\n *==========*/\n\n#if defined(MDL_REF_SIM_TGT)\n#undef MATLAB_MEX_FILE\n#endif\n\n#if defined(MATLAB_MEX_FILE)\n# error \"rt_matrix cannot be used within a mex file. It is for codegen only.\"\n#endif\n\n#include <string.h>    /* for strlen */\n#include \"rt_matrx.h\"\n\n#include <stddef.h> /* needed for size_t and NULL */\n#include <float.h>  /* needed for definition of eps */\n\n/*==========*\n * Typedefs *\n *==========*/\n\n#ifndef rt_typedefs_h\n#define rt_typedefs_h\n\n#if !defined(TYPEDEF_MX_ARRAY)\n# define TYPEDEF_MX_ARRAY\n  typedef real_T mxArray;\n#endif\n\ntypedef real_T mxChar;\n\n#if !defined(TMW_NAME_LENGTH_MAX)\n#define TMW_NAME_LENGTH_MAX 64\n#endif\n#define mxMAXNAM  TMW_NAME_LENGTH_MAX\t/* maximum name length */\n\ntypedef enum {\n    mxREAL,\n    mxCOMPLEX\n} mxComplexity;\n\n#endif /* rt_typedefs_h */\n\n/*==================*\n * Extern variables *\n *==================*/\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nextern real_T rtInf;\nextern real_T rtMinusInf;\nextern real_T rtNaN;\n\n#ifdef __cplusplus\n}\n#endif\n\n/*=======================================*\n * Defines for mx Routines and constants *\n *=======================================*/\n\n\n#define mxCalloc(n,size) \\\n        calloc(n,size)\n\n#define mxCreateCharArray(ndim, dims) \\\n        mxCreateNumericArray(ndim, dims, mxCHAR_CLASS);\n\n#define mxDestroyArray(pa) \\\n        if (pa) free(pa)\n\n/* NOTE: You cannot mxFree(mxGetPr(pa)) !!! */\n#define mxFree(ptr) \\\n        if(ptr)free(ptr)\n\n#define mxGetClassID(pa) \\\n        mxDOUBLE_CLASS\n\n/* NOTE: mxGetClassName(pa) returns \"double\" even on a character array */\n#define mxGetClassName(pa) \\\n        \"double\"\n\n#define mxGetData(pa) \\\n        ((void *)(&((pa)[2])))\n\n#define mxGetElementSize(pa) \\\n        (sizeof(real_T))\n\n#define mxGetInf() \\\n        rtInf\n\n#define mxGetM(pa) \\\n        ((size_t) ((pa)[0]))\n#define mxGetN(pa) \\\n        ((size_t) ((pa)[1]))\n\n#define mxGetNaN() \\\n        rtNaN\n\n#define mxGetNumberOfDimensions(pa) \\\n        (2)\n#define mxGetNumberOfElements(pa) \\\n        (mxGetM(pa)*mxGetN(pa))\n\n/* NOTE: mxGetPr() of an empty matrix does NOT return NULL */\n#define mxGetPr(pa) \\\n        ( &((pa)[2]) )\n\n/* NOTE: mxGetDoubles() of an empty matrix does NOT return NULL */\n#define mxGetDoubles(pa) \\\n        ( &((pa)[2]) )\n\n#define mxGetScalar(pa) \\\n        ((pa)[2])\n\n#define mxIsComplex(pa) \\\n        false\n\n#define mxIsDouble(pa) \\\n        true\n\n#define mxIsEmpty(pa) \\\n        (mxGetM(pa)==0 || mxGetN(pa)==0)\n\n#define mxIsFinite(r) \\\n        ((r)>rtMinusInf && (r)<rtInf)\n\n#define mxIsInf(r) \\\n        ((r)==rtInf || (r)==rtMinusInf)\n\n#define mxIsInt16(pa) \\\n        false\n\n#define mxIsInt32(pa) \\\n        false\n\n#define mxIsInt8(pa) \\\n        false\n\n#define mxIsLogical(pa) \\\n        false\n\n#define mxIsNumeric(pa) \\\n        true\n\n#define mxIsSingle(pa) \\\n        false\n\n#define mxIsSparse(pa) \\\n        false\n\n#define mxIsStruct(pa) \\\n        false\n\n#define mxIsUint16(pa) \\\n        false\n\n#define mxIsUint32(pa) \\\n        false\n\n#define mxIsUint8(pa) \\\n        false\n\n#define mxMalloc(n) \\\n        malloc(n)\n\n#define mxRealloc(p,n) \\\n        realloc(p,n)\n\n/*==============*\n * Local macros *\n *==============*/\n#define _mxSetM(pa,m) \\\n        (pa)[0] = ((int)(m))\n\n#define _mxSetN(pa,n) \\\n        (pa)[1] = ((int)(n))\n\n\n/*==========================*\n * Visible/extern functions *\n *=========================*/\n\n/* Function: mxCreateCharMatrixFromStrings ====================================\n * Abstract:\n *\tCreate a string array initialized to the strings in str.\n */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nmxArray *rt_mxCreateCharMatrixFromStrings(int_T m, const char_T **str)\n{\n    int_T nchars;\n    int_T i, n;\n    mxArray *pa;\n\n    n = 0;\n    for (i = 0; i < m; ++i) {\n\tnchars = (int_T)strlen(str[i]);\n\tif (nchars > n) {\n\t    n = nchars;\n\t}\n    }\n\n    pa = (mxArray *)malloc((m*n+2)*sizeof(real_T));\n    if(pa!=NULL) {\n\tmxChar *chars;\n\tint_T  j;\n\t_mxSetM(pa, m);\n\t_mxSetN(pa, n);\n\tchars = mxGetPr(pa);\n\tfor (j = 0; j < m; ++j) {\n\t    const char_T *src  = str[j];\n\t    mxChar *dest = chars + j;\n\n\t    nchars = (int_T)strlen(src);\n\t    i = nchars;\n\t    while (i--) {\n\t\t*dest = *src++;\n\t\t dest += m;\n\t    }\n\t    i = n - nchars;\n\t    while (i--) {\n\t\t*dest = 0.0;\n\t\tdest += m;\n\t    }\n\t}\n    }\n    return pa;\n} /* end mxCreateCharMatrixFromStrings */\n\n#ifdef __cplusplus\n}\n#endif\n\n/* Function: mxCreateString ===================================================\n * Abstract:\n *\tCreate a 1-by-n string array initialized to null terminated string\n *\twhere n is the length of the string.\n */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nmxArray *rt_mxCreateString(const char *str)\n{\n    int_T   len = (int_T)strlen(str);\n\n    mxArray *pa = (mxArray *)malloc((len+2)*sizeof(real_T));\n\n    if(pa!=NULL) {\n\treal_T *pr;\n\tconst unsigned char *ustr_ptr = (const unsigned char *) str;\n\n\t_mxSetM(pa, 1);\n\t_mxSetN(pa, len);\n\tpr = mxGetPr(pa);\n\twhile (len--) {\n            *pr++ = (real_T)*ustr_ptr++;\n        }\n    }\n    return(pa);\n\n} /* end mxCreateString */\n\n#ifdef __cplusplus\n}\n#endif\n\n/* Function: mxCreateDoubleMatrix =============================================\n * Abstract:\n *\tCreate a two-dimensional array to hold real_T data,\n *\tinitialize each data element to 0.\n */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nmxArray *rt_mxCreateDoubleMatrix(int m, int n, mxComplexity flag)\n{\n    if (flag == mxREAL) {\n        mxArray *pa = (mxArray *)calloc(m*n+2, sizeof(real_T));\n        if(pa!=NULL) {\n            _mxSetM(pa, m);\n            _mxSetN(pa, n);\n        }\n        return(pa);\n    } else {\n        return(NULL);\n    }\n\n} /* end mxCreateDoubleMatrix */\n\n#ifdef __cplusplus\n}\n#endif\n\n/* Function: mxCreateNumericArray =============================================\n * Abstract:\n *\tCreate a numeric array and initialize all its data elements to 0.\n */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nmxArray *rt_mxCreateNumericArray(int_T ndims, const mwSize *dims, \n                                        mxClassID classid, mxComplexity flag)\n{\n    if (ndims == 2 && classid==mxDOUBLE_CLASS) {\n        return(rt_mxCreateDoubleMatrix((int)(dims[0]), (int)(dims[1]), flag));\n    } else {\n        return(NULL);\n    }\n\n} /* end mxCreateNumericArray */\n\n#ifdef __cplusplus\n}\n#endif\n\n/* Function: mxDuplicateArray =================================================\n * Abstract:\n *\tMake a deep copy of an array, return a pointer to the copy.\n */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nmxArray *rt_mxDuplicateArray(const mxArray *pa)\n{\n\n    size_t   nbytes = (mxGetNumberOfElements(pa)+2)*mxGetElementSize(pa);\n    mxArray *pcopy = (mxArray *)malloc(nbytes);\n\n    if (pcopy!=NULL) {\n\t(void)memcpy(pcopy, pa, nbytes);\n    }\n    return(pcopy);\n\n} /* end mxDuplicateArray */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n/* Function: mxGetDimensions ==================================================\n * Abstract:\n *\tGet pointer to dimension array\n */\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nconst mwSize *rt_mxGetDimensions(const mxArray *pa)\n{\n    static mwSize dims[2];\n    dims[0] = mxGetM(pa);\n    dims[1] = mxGetN(pa);\n    return dims;\n} /* end mxGetDimensions */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n/* Function: mxGetEps =========================================================\n * Abstract:\n *\tReturn eps, the difference between 1.0 and the least value\n *\tgreater than 1.0 that is representable as a real_T.\n */\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nreal_T rt_mxGetEps(void)\n{\n    return (sizeof(double)==sizeof(real_T)) ? DBL_EPSILON : FLT_EPSILON;\n}\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n/* Function: mxGetString ======================================================\n * Abstract:\n *\tConverts a string array to a C-style string.\n */\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nint_T rt_mxGetString(const mxArray *pa, char_T *buf, int_T buflen)\n{\n    int_T        nchars;\n    const real_T *pr;\n    char_T       *pc;\n    int_T        truncate = 0;\n\n    nchars = (int_T)mxGetNumberOfElements(pa);\n    if (nchars >= buflen) {\n\t/* leave room for null byte */\n\tnchars = buflen - 1;\n\ttruncate = 1;\n    }\n    pc = buf;\n    pr = mxGetPr(pa);\n    while (nchars--) {\n\t*pc++ = (char) (*pr++ + .5);\n    }\n    *pc = '\\0';\n    return truncate;\n} /* end mxGetString */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n#define mxCreateCharMatrixFromStrings(m, str) \\\n        rt_mxCreateCharMatrixFromStrings(m, str)\n\n#define mxCreateString(str) \\\n        rt_mxCreateString(str) \n\n#define mxCreateDoubleMatrix(m, n, flag) \\\n        rt_mxCreateDoubleMatrix(m, n, flag)\n\n#define mxCreateNumericArray(ndims, dims, classid, flag) \\\n        rt_mxCreateNumericArray(ndims, dims, classid, flag)\n\n#define mxDuplicateArray(pa) \\\n        rt_mxDuplicateArray(pa)\n\n#define mxGetDimensions(pa) \\\n        rt_mxGetDimensions(pa)\n\n#define mxGetEps() \\\n        rt_mxGetEps()\n\n#define mxGetString(pa, buf, buflen) \\\n        rt_mxGetString(pa, buf, buflen)\n\n/*=========================*\n * Unsupported mx Routines *\n *=========================*/\n\n#define mxCalcSingleSubscript(pa,nsubs,subs) \\\n        mxCalcSingleSubscript_is_not_supported_in_Simulink_Coder\n\n#define mxCreateCellArray(ndim,dims) \\\n        mxCreateCellArray_is_not_supported_in_Simulink_Coder\n\n#define mxCreateCellMatrix(m,n) \\\n        mxCreateCellMatrix_is_not_supported_in_Simulink_Coder\n\n#define mxCreateSparse(pm,pn,pnzmax,pcmplx_flg) \\\n        mxCreateSparse_is_not_supported_in_Simulink_Coder\n\n#define mxCreateStructArray(ndim,dims,nfields,fieldnames) \\\n        mxCreateStructArray_is_not_supported_in_Simulink_Coder\n\n#define mxCreateStructMatrix(m,n,nfields,fieldnames) \\\n        mxCreateStructMatrix_is_not_supported_in_Simulink_Coder\n\n#define mxGetCell(pa,i) \\\n        mxGetCell_is_not_supported_in_Simulink_Coder\n\n#define mxGetField(pa,i,fieldname) \\\n        mxGetField_is_not_supported_in_Simulink_Coder\n\n#define mxGetFieldByNumber(s,i,fieldnum) \\\n        mxGetFieldByNumber_is_not_supported_in_Simulink_Coder\n\n#define mxGetFieldNameByNumber(pa,n) \\\n        mxGetFieldNameByNumber_is_not_supported_in_Simulink_Coder\n\n#define mxGetFieldNumber(pa,fieldname) \\\n        mxGetFieldNumber_is_not_supported_in_Simulink_Coder\n\n#define mxGetImagData(pa) \\\n        mxGetImagData_is_not_supported_in_Simulink_Coder\n\n#define mxGetIr(ppa) \\\n        mxGetIr_is_not_supported_in_Simulink_Coder\n\n#define mxGetJc(ppa) \\\n        mxGetJc_is_not_supported_in_Simulink_Coder\n\n#define mxGetNumberOfFields(pa) \\\n        mxGetNumberOfFields_is_not_supported_in_Simulink_Coder\n\n#define mxGetNzmax(pa) \\\n        mxGetNzmax_is_not_supported_in_Simulink_Coder\n\n#define mxGetPi(pa) \\\n        mxGetPi_is_not_supported_in_Simulink_Coder\n\n#define mxIsFromGlobalWS(pa) \\\n        mxIsFromGlobalWS_is_not_supported_in_Simulink_Coder\n\n#define mxIsNaN(r) \\\n        mxIsNaN_is_not_supported_in_Simulink_Coder\n\n#define mxIsChar(pa) \\\n        mxIsChar_is_not_supported_in_Simulink_Coder\n\n#define mxIsClass(pa,class) \\\n        mxIsClass_is_not_supported_in_Simulink_Coder\n\n#define mxIsCell(pa) \\\n        mxIsCell_is_not_supported_in_Simulink_Coder\n\n#define mxSetCell(pa,i,value) \\\n        mxSetCell_is_not_supported_in_Simulink_Coder\n\n#define mxSetClassName(pa,classname) \\\n        mxSetClassName_is_not_supported_in_Simulink_Coder\n\n#define mxSetData(pa,pr) \\\n        mxSetData_is_not_supported_in_Simulink_Coder\n\n#define mxSetDimensions(pa, size, ndims) \\\n        mxSetDimensions_is_not_supported_in_Simulink_Coder\n\n#define mxSetField(pa,i,fieldname,value) \\\n        mxSetField_is_not_supported_in_Simulink_Coder\n\n#define mxSetFieldByNumber(pa, index, fieldnum, value) \\\n        mxSetFieldByNumber_is_not_supported_in_Simulink_Coder\n\n#define mxSetFromGlobalWS(pa,global) \\\n        mxSetFromGlobalWS_is_not_supported_in_Simulink_Coder\n\n#define mxSetImagData(pa,pv) \\\n        mxSetImagData_is_not_supported_in_Simulink_Coder\n\n#define mxSetIr(ppa,ir) \\\n        mxSetIr_is_not_supported_in_Simulink_Coder\n\n#define mxSetJc(ppa,jc) \\\n        mxSetJc_is_not_supported_in_Simulink_Coder\n\n#define mxSetM(pa, m) \\\n        mxSetM_is_not_supported_in_Simulink_Coder\n\n#define mxSetN(pa, m) \\\n        mxSetN_is_not_supported_in_Simulink_Coder\n\n#define mxSetPr(pa,pr) \\\n        mxSetPr_is_not_supported_in_Simulink_Coder\n\n#define mxSetNzmax(pa,nzmax) \\\n        mxSetNzmax_is_not_supported_in_Simulink_Coder\n\n#define mxSetPi(pa,pv) \\\n        mxSetPi_is_not_supported_in_Simulink_Coder\n\n\n\n/*==========================*\n * Unsupported mex routines *\n *==========================*/\n\n#define mexPrintAssertion(test,fname,linenum,message) \\\n        mexPrintAssertion_is_not_supported_by_Simulink_Coder\n\n#define mexEvalString(str) \\\n        mexEvalString_is_not_supported_by_Simulink_Coder\n\n#define mexErrMsgTxt(str) \\\n        mexErrMsgTxt_is_not_supported_by_Simulink_Coder\n\n#define mexWarnMsgTxt(warning_msg) \\\n        mexWarnMsgTxt_is_not_supported_by_Simulink_Coder\n\n#define mexPrintf \\\n        mexPrintf_is_not_supported_by_Simulink_Coder\n\n#define mexMakeArrayPersistent(pa) \\\n        mexMakeArrayPersistent_is_not_supported_by_Simulink_Coder\n\n#define mexMakeMemoryPersistent(ptr) \\\n        mexMakeMemoryPersistent_is_not_supported_by_Simulink_Coder\n\n#define mexLock() \\\n        mexLock_is_not_supported_by_Simulink_Coder\n\n#define mexUnlock() \\\n        mexUnlock_is_not_supported_by_Simulink_Coder\n\n#define mexFunctionName() \\\n        mexFunctionName_is_not_supported_by_Simulink_Coder\n\n#define mexIsLocked() \\\n        mexIsLocked_is_not_supported_by_Simulink_Coder\n\n#define mexGetFunctionHandle() \\\n        mexGetFunctionHandle_is_not_supported_by_Simulink_Coder\n\n#define mexCallMATLABFunction() \\\n        mexCallMATLABFunction_is_not_supported_by_Simulink_Coder\n\n#define mexRegisterFunction() \\\n        mexRegisterFunction_is_not_supported_by_Simulink_Coder\n\n#define mexSet(handle,property,value) \\\n        mexSet_is_not_supported_by_Simulink_Coder\n\n#define mexGet(handle,property) \\\n        mexGet_is_not_supported_by_Simulink_Coder\n\n#define mexCallMATLAB(nlhs,plhs,nrhs,prhs,fcn) \\\n        mexCallMATLAB_is_not_supported_by_Simulink_Coder\n\n#define mexSetTrapFlag(flag) \\\n        mexSetTrapFlag_is_not_supported_by_Simulink_Coder\n\n#define mexUnlink(a) \\\n        mexUnlink_is_not_supported_by_Simulink_Coderw\n\n#define mexSubsAssign(plhs,sub,nsubs,prhs) \\\n        mexSubsAssign_is_not_supported_by_Simulink_Coder\n\n#define mexSubsReference(prhs,subs,nsubs) \\\n        mexSubsReference_is_not_supported_by_Simulink_Coder\n\n#define mexPrintAssertion(test,fname,linenum,message) \\\n        mexPrintAssertion_is_not_supported_by_Simulink_Coder\n\n#define mexAddFlops(count) \\\n        mexAddFlops_is_not_supported_by_Simulink_Coder\n\n#define mexIsGlobal(pa) \\\n        mexIsGlobal_is_not_supported_by_Simulink_Coder\n\n#define mexAtExit(fcn) \\\n        mexAtExit_is_not_supported_by_Simulink_Coder\n\n/* [EOF] rt_matrx.c */\n"},{"name":"rt_printf.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2023a/rtw/c/src","tag":"","groupDisplay":"Other files","code":"/* Copyright 1994-2015 The MathWorks, Inc.\n *\n * File: rt_printf.c\n *\n * Abstract:\n *      Stub I/O printf facility for systems which don't have stdio.\n *\n */\n\n\n\n/* Function: rtPrintfNoOp ======================================================\n * Abstract:\n *      Maps ssPrintf to rtPrintfNoOp if HAVESTDIO is not defined (see\n *      simstruct.h\n */\nint rtPrintfNoOp(const char *fmt, ...)\n{\n    /* do nothing */\n    return(fmt == (const char *)0); /* use fmt to quiet unused var warning */\n}\n\n\n/* [eof] rt_printf.c */\n"},{"name":"rte_ATTN_parameters.cpp","type":"source","group":"legacy","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Other files","code":"#include \"rte_ATTN_parameters.h\"\n#include \"ATTN.h\"\n#include \"ATTN_cal.h\"\n\nextern ATTN_cal_type ATTN_cal_impl;\nnamespace slrealtime\n{\n  /* Description of SEGMENTS */\n  SegmentVector segmentInfo {\n    { (void*)&ATTN_cal_impl, (void**)&ATTN_cal, sizeof(ATTN_cal_type), 2 }\n  };\n\n  SegmentVector &getSegmentVector(void)\n  {\n    return segmentInfo;\n  }\n}                                      // slrealtime\n"},{"name":"rte_ATTN_parameters.h","type":"header","group":"other","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef _RTE_ATTN_PARAMETERS_H\n#define _RTE_ATTN_PARAMETERS_H\n#include \"rtwtypes.h\"\n#include \"SegmentInfo.hpp\"\n\nnamespace slrealtime\n{\n  SegmentVector &getSegmentVector(void);\n}                                      // slrealtime\n\n#endif\n"},{"name":"slrealtime_datatype_ground.cpp","type":"source","group":"legacy","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Other files","code":"#include \"slrtdatatypes.h\"\n\nconst serialfifoptr serialfifoground = { 0, 0, 0 };\n\nconst bcmsglist1553 bcmsg1553ground = { 0, 0, 0, 0 };\n\nconst bcstatus1553 bcstatground = { 0, 0, 0, 0, 0, 0 };\n\nconst bmmsglist1553 bmmsg1553ground = { 0, 0, 0, 0 };\n"}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true}};