<<<<<<< HEAD
var dataJson = {"arch":{"ispc":false,"isunix":true,"ismac":false},"build":"ATTN","ref":false,"files":[{"name":"ATTN.cpp","type":"source","group":"model","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * ATTN.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.461\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Nov 30 11:48:11 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"ATTN.h\"\n#include \"rtwtypes.h\"\n#include \"ATTN_private.h\"\n#include \"ATTN_cal.h\"\n#include <cstring>\n#include <cmath>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n/* Named constants for MATLAB Function: '<S3>/MATLAB Function2' */\nconst int32_T ATTN_CALL_EVENT = -1;\n\n/* Named constants for MATLAB Function: '<Root>/MATLAB Function' */\nconst int32_T ATTN_CALL_EVENT_n = -1;\nconst real_T ATTN_RGND = 0.0;          /* real_T ground */\n\n/* Block signals (default storage) */\nB_ATTN_T ATTN_B;\n\n/* Block states (default storage) */\nDW_ATTN_T ATTN_DW;\n\n/* Real-time model */\nRT_MODEL_ATTN_T ATTN_M_ = RT_MODEL_ATTN_T();\nRT_MODEL_ATTN_T *const ATTN_M = &ATTN_M_;\n\n/* Forward declaration for local functions */\nstatic real_T ATTN_rand(void);\n\n/*\n * System initialize for atomic system:\n *    '<S3>/MATLAB Function2'\n *    '<S4>/MATLAB Function1'\n */\nvoid ATTN_MATLABFunction2_Init(DW_MATLABFunction2_ATTN_T *localDW)\n{\n  localDW->sfEvent = ATTN_CALL_EVENT;\n  localDW->t0_not_empty = false;\n  localDW->y0_not_empty = false;\n  localDW->is_active_c3_ATTN = 0U;\n}\n\n/*\n * Output and update for atomic system:\n *    '<S3>/MATLAB Function2'\n *    '<S4>/MATLAB Function1'\n */\nvoid ATTN_MATLABFunction2(real_T rtu_trigger, real_T rtu_duration, real_T\n  rtu_amp, real_T rtu_t, B_MATLABFunction2_ATTN_T *localB,\n  DW_MATLABFunction2_ATTN_T *localDW)\n{\n  real_T increment;\n  localDW->sfEvent = ATTN_CALL_EVENT;\n  increment = rtu_amp / (rtu_duration * 1000.0 / 2.0);\n  if (rtu_trigger != 0.0) {\n    localDW->t0 = rtu_t;\n    localDW->t0_not_empty = true;\n    localB->y = 0.0;\n    localDW->y0 = 0.0;\n    localDW->y0_not_empty = true;\n  } else if (localDW->t0_not_empty) {\n    real_T tmp;\n    tmp = rtu_t - localDW->t0;\n    if (tmp <= rtu_duration / 2.0) {\n      localB->y = localDW->y0 + increment;\n      localDW->y0 = localB->y;\n    } else if (tmp <= rtu_duration) {\n      localB->y = localDW->y0 - increment;\n      increment = localB->y;\n      if (increment > 0.0) {\n        localB->y = increment;\n      } else {\n        localB->y = 0.0;\n      }\n\n      localDW->y0 = localB->y;\n    } else {\n      localB->y = 0.0;\n    }\n  } else {\n    localB->y = 0.0;\n  }\n}\n\n/* Function for MATLAB Function: '<Root>/MATLAB Function' */\nstatic real_T ATTN_rand(void)\n{\n  real_T r;\n  uint32_T u[2];\n  if (ATTN_DW.method == 4U) {\n    int32_T k;\n    uint32_T mti;\n    uint32_T y;\n    k = static_cast<int32_T>(ATTN_DW.state / 127773U);\n    mti = (ATTN_DW.state - static_cast<uint32_T>(k) * 127773U) * 16807U;\n    y = 2836U * static_cast<uint32_T>(k);\n    if (mti < y) {\n      mti = ~(y - mti) & 2147483647U;\n    } else {\n      mti -= y;\n    }\n\n    r = static_cast<real_T>(mti) * 4.6566128752457969E-10;\n    ATTN_DW.state = mti;\n  } else if (ATTN_DW.method == 5U) {\n    uint32_T mti;\n    uint32_T y;\n    mti = 69069U * ATTN_DW.state_p[0] + 1234567U;\n    y = ATTN_DW.state_p[1] << 13 ^ ATTN_DW.state_p[1];\n    y ^= y >> 17;\n    y ^= y << 5;\n    ATTN_DW.state_p[0] = mti;\n    ATTN_DW.state_p[1] = y;\n    r = static_cast<real_T>(mti + y) * 2.328306436538696E-10;\n  } else {\n    /* ========================= COPYRIGHT NOTICE ============================ */\n    /*  This is a uniform (0,1) pseudorandom number generator based on:        */\n    /*                                                                         */\n    /*  A C-program for MT19937, with initialization improved 2002/1/26.       */\n    /*  Coded by Takuji Nishimura and Makoto Matsumoto.                        */\n    /*                                                                         */\n    /*  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,      */\n    /*  All rights reserved.                                                   */\n    /*                                                                         */\n    /*  Redistribution and use in source and binary forms, with or without     */\n    /*  modification, are permitted provided that the following conditions     */\n    /*  are met:                                                               */\n    /*                                                                         */\n    /*    1. Redistributions of source code must retain the above copyright    */\n    /*       notice, this list of conditions and the following disclaimer.     */\n    /*                                                                         */\n    /*    2. Redistributions in binary form must reproduce the above copyright */\n    /*       notice, this list of conditions and the following disclaimer      */\n    /*       in the documentation and/or other materials provided with the     */\n    /*       distribution.                                                     */\n    /*                                                                         */\n    /*    3. The names of its contributors may not be used to endorse or       */\n    /*       promote products derived from this software without specific      */\n    /*       prior written permission.                                         */\n    /*                                                                         */\n    /*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    */\n    /*  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT      */\n    /*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  */\n    /*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT  */\n    /*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  */\n    /*  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT       */\n    /*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  */\n    /*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  */\n    /*  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    */\n    /*  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE */\n    /*  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */\n    /*                                                                         */\n    /* =============================   END   ================================= */\n    int32_T exitg1;\n    do {\n      int32_T k;\n      uint32_T mti;\n      exitg1 = 0;\n      for (k = 0; k < 2; k++) {\n        uint32_T y;\n        mti = ATTN_DW.state_k[624] + 1U;\n        if (mti >= 625U) {\n          for (int32_T kk = 0; kk < 227; kk++) {\n            mti = (ATTN_DW.state_k[kk + 1] & 2147483647U) | (ATTN_DW.state_k[kk]\n              & 2147483648U);\n            if ((mti & 1U) == 0U) {\n              mti >>= 1U;\n            } else {\n              mti = mti >> 1U ^ 2567483615U;\n            }\n\n            ATTN_DW.state_k[kk] = ATTN_DW.state_k[kk + 397] ^ mti;\n          }\n\n          for (int32_T kk = 0; kk < 396; kk++) {\n            mti = (ATTN_DW.state_k[kk + 227] & 2147483648U) |\n              (ATTN_DW.state_k[kk + 228] & 2147483647U);\n            if ((mti & 1U) == 0U) {\n              mti >>= 1U;\n            } else {\n              mti = mti >> 1U ^ 2567483615U;\n            }\n\n            ATTN_DW.state_k[kk + 227] = ATTN_DW.state_k[kk] ^ mti;\n          }\n\n          mti = (ATTN_DW.state_k[623] & 2147483648U) | (ATTN_DW.state_k[0] &\n            2147483647U);\n          if ((mti & 1U) == 0U) {\n            mti >>= 1U;\n          } else {\n            mti = mti >> 1U ^ 2567483615U;\n          }\n\n          ATTN_DW.state_k[623] = ATTN_DW.state_k[396] ^ mti;\n          mti = 1U;\n        }\n\n        y = ATTN_DW.state_k[static_cast<int32_T>(mti) - 1];\n        ATTN_DW.state_k[624] = mti;\n        y ^= y >> 11U;\n        y ^= y << 7U & 2636928640U;\n        y ^= y << 15U & 4022730752U;\n        u[k] = y >> 18U ^ y;\n      }\n\n      r = (static_cast<real_T>(u[0] >> 5U) * 6.7108864E+7 + static_cast<real_T>\n           (u[1] >> 6U)) * 1.1102230246251565E-16;\n      if (r == 0.0) {\n        boolean_T b_isvalid;\n        if ((ATTN_DW.state_k[624] >= 1U) && (ATTN_DW.state_k[624] < 625U)) {\n          boolean_T exitg2;\n          b_isvalid = false;\n          k = 1;\n          exitg2 = false;\n          while ((!exitg2) && (k < 625)) {\n            if (ATTN_DW.state_k[k - 1] == 0U) {\n              k++;\n            } else {\n              b_isvalid = true;\n              exitg2 = true;\n            }\n          }\n        } else {\n          b_isvalid = false;\n        }\n\n        if (!b_isvalid) {\n          mti = 5489U;\n          ATTN_DW.state_k[0] = 5489U;\n          for (k = 0; k < 623; k++) {\n            mti = ((mti >> 30U ^ mti) * 1812433253U + static_cast<uint32_T>(k))\n              + 1U;\n            ATTN_DW.state_k[k + 1] = mti;\n          }\n\n          ATTN_DW.state_k[624] = 624U;\n        }\n      } else {\n        exitg1 = 1;\n      }\n    } while (exitg1 == 0);\n  }\n\n  return r;\n}\n\n/* Model step function */\nvoid ATTN_step(void)\n{\n  real_T b_y1;\n\n  /* Memory: '<Root>/Memory8' */\n  ATTN_B.Memory8 = ATTN_DW.Memory8_PreviousInput;\n\n  /* Memory: '<Root>/Memory2' */\n  ATTN_B.Memory2 = ATTN_DW.Memory2_PreviousInput;\n\n  /* Memory: '<Root>/Memory1' */\n  ATTN_B.Memory1 = ATTN_DW.Memory1_PreviousInput;\n\n  /* Memory: '<Root>/Memory' */\n  ATTN_B.Memory = ATTN_DW.Memory_PreviousInput;\n\n  /* S-Function (sg_IO191_setup_s): '<Root>/Setup ' */\n\n  /* Level2 S-Function Block: '<Root>/Setup ' (sg_IO191_setup_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[0];\n    sfcnOutputs(rts,0);\n  }\n\n  /* S-Function (sg_IO191_ad_s): '<Root>/Analog input ' */\n\n  /* Level2 S-Function Block: '<Root>/Analog input ' (sg_IO191_ad_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[1];\n    sfcnOutputs(rts,0);\n  }\n\n  /* DiscreteFilter: '<Root>/Discrete Filter' */\n  b_y1 = ATTN_B.lickometer_piezo;\n  b_y1 -= ATTN_cal->DiscreteFilter_DenCoef[1] * ATTN_DW.DiscreteFilter_states;\n  b_y1 /= ATTN_cal->DiscreteFilter_DenCoef[0];\n  ATTN_DW.DiscreteFilter_tmp = b_y1;\n  b_y1 = ATTN_cal->DiscreteFilter_NumCoef * ATTN_DW.DiscreteFilter_tmp;\n\n  /* DiscreteFilter: '<Root>/Discrete Filter' */\n  ATTN_B.DiscreteFilter = b_y1;\n\n  /* Memory: '<Root>/Memory11' */\n  ATTN_B.Memory11 = ATTN_DW.Memory11_PreviousInput;\n\n  /* Memory: '<Root>/Memory7' */\n  ATTN_B.Memory7 = ATTN_DW.Memory7_PreviousInput;\n\n  /* MATLAB Function: '<Root>/MATLAB Function1' incorporates:\n   *  Constant: '<Root>/Thrd'\n   */\n  ATTN_DW.sfEvent_b = ATTN_CALL_EVENT_n;\n  if (std::abs(ATTN_B.DiscreteFilter) > ATTN_cal->Thrd_Value) {\n    b_y1 = ATTN_B.Memory11 + 1.0;\n    ATTN_B.y2 = ATTN_B.Memory7;\n  } else {\n    b_y1 = 0.0;\n    ATTN_B.y2 = 0.0;\n  }\n\n  if ((b_y1 > 20.0) && (ATTN_B.Memory7 == 0.0)) {\n    ATTN_B.Lick = 1.0;\n    ATTN_B.y2 = 1.0;\n  } else {\n    ATTN_B.Lick = 0.0;\n  }\n\n  ATTN_B.y1 = b_y1;\n\n  /* End of MATLAB Function: '<Root>/MATLAB Function1' */\n\n  /* Clock: '<Root>/Clock' */\n  ATTN_B.clock_time = ATTN_M->Timing.t[0];\n\n  /* Memory: '<Root>/Memory3' */\n  ATTN_B.Memory3 = ATTN_DW.Memory3_PreviousInput;\n\n  /* Memory: '<Root>/Memory4' */\n  ATTN_B.Memory4 = ATTN_DW.Memory4_PreviousInput;\n\n  /* Memory: '<Root>/Memory9' */\n  ATTN_B.Memory9 = ATTN_DW.Memory9_PreviousInput;\n\n  /* Memory: '<Root>/Memory5' */\n  ATTN_B.Memory5 = ATTN_DW.Memory5_PreviousInput;\n\n  /* Memory: '<Root>/Memory6' */\n  ATTN_B.Memory6 = ATTN_DW.Memory6_PreviousInput;\n\n  /* Memory: '<Root>/Memory10' */\n  ATTN_B.Memory10 = ATTN_DW.Memory10_PreviousInput;\n\n  /* Constant: '<Root>/trainingStage' */\n  ATTN_B.training_stage = ATTN_cal->trainingStage;\n\n  /* MATLAB Function: '<Root>/MATLAB Function' incorporates:\n   *  Constant: '<Root>/rewardDuration'\n   *  Constant: '<Root>/targetSide'\n   *  Constant: '<Root>/triangleDuration'\n   */\n  ATTN_DW.sfEvent_e = ATTN_CALL_EVENT_n;\n  ATTN_B.counter_out = ATTN_B.Memory4 + 1.0;\n  switch (static_cast<int32_T>(ATTN_B.training_stage)) {\n   case 1:\n    switch (static_cast<int32_T>(ATTN_B.Memory2)) {\n     case 1:\n      ATTN_B.npxlsAcq_out = 1.0;\n      ATTN_B.state_out = 2.0;\n      ATTN_B.localTime_out = 1.0;\n      ATTN_B.trialNum_out = 1.0;\n      ATTN_B.right_trigger_out = 0.0;\n      ATTN_B.left_trigger_out = 0.0;\n      ATTN_B.numLicks_out = 0.0;\n      b_y1 = 4.0;\n      while ((b_y1 >= 9.0) || (b_y1 <= 5.0)) {\n        b_y1 = ATTN_rand();\n        b_y1 = std::log(b_y1);\n        b_y1 *= -7.0;\n      }\n\n      ATTN_B.delay_out = ATTN_B.clock_time + b_y1;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = 0.0;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 2:\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n      } else {\n        ATTN_B.state_out = 3.0;\n      }\n\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.delay_out = ATTN_B.Memory5;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 3:\n      if (ATTN_rand() <= 0.8) {\n        if (ATTN_cal->targetSide != 0.0) {\n          ATTN_B.right_trigger_out = 1.0;\n          ATTN_B.left_trigger_out = 0.0;\n        } else {\n          ATTN_B.left_trigger_out = 1.0;\n          ATTN_B.right_trigger_out = 0.0;\n        }\n\n        ATTN_B.was_target_out = 0.0;\n      } else {\n        if (ATTN_cal->targetSide != 0.0) {\n          ATTN_B.left_trigger_out = 1.0;\n          ATTN_B.right_trigger_out = 0.0;\n        } else {\n          ATTN_B.right_trigger_out = 1.0;\n          ATTN_B.left_trigger_out = 0.0;\n        }\n\n        ATTN_B.was_target_out = 1.0;\n      }\n\n      ATTN_B.state_out = 4.0;\n      ATTN_B.delay_out = ATTN_B.clock_time + 0.2;\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 4:\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n        ATTN_B.delay_out = ATTN_B.Memory5;\n      } else if (ATTN_B.Memory10 != 0.0) {\n        ATTN_B.state_out = 5.0;\n        ATTN_B.delay_out = ATTN_B.clock_time + 1.0;\n      } else {\n        ATTN_B.state_out = 6.0;\n        ATTN_B.delay_out = ATTN_B.clock_time + 1.0;\n      }\n\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.left_trigger_out = 0.0;\n      ATTN_B.right_trigger_out = 0.0;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 5:\n      ATTN_B.reward_trigger_out = 1.0;\n      ATTN_B.state_out = 6.0;\n      ATTN_B.delay_out = ATTN_B.Memory5;\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 6:\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n      } else {\n        ATTN_B.state_out = 1.0;\n      }\n\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.delay_out = ATTN_B.Memory5;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     default:\n      ATTN_B.state_out = ATTN_B.Memory2;\n      ATTN_B.localTime_out = ATTN_B.Memory1;\n      ATTN_B.trialNum_out = ATTN_B.Memory;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.delay_out = ATTN_B.Memory5;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n    }\n    break;\n\n   case 2:\n    switch (static_cast<int32_T>(ATTN_B.Memory2)) {\n     case 1:\n      ATTN_B.npxlsAcq_out = 1.0;\n      ATTN_B.state_out = 2.0;\n      ATTN_B.localTime_out = 1.0;\n      ATTN_B.trialNum_out = 1.0;\n      ATTN_B.right_trigger_out = 0.0;\n      ATTN_B.left_trigger_out = 0.0;\n      ATTN_B.numLicks_out = 0.0;\n      b_y1 = 4.0;\n      while ((b_y1 >= 9.0) || (b_y1 <= 5.0)) {\n        b_y1 = ATTN_rand();\n        b_y1 = std::log(b_y1);\n        b_y1 *= -7.0;\n      }\n\n      ATTN_B.delay_out = ATTN_B.clock_time + b_y1;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 2:\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n      } else {\n        ATTN_B.state_out = 3.0;\n      }\n\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.delay_out = ATTN_B.Memory5;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 3:\n      if (ATTN_rand() <= 0.5) {\n        if (ATTN_cal->targetSide != 0.0) {\n          ATTN_B.right_trigger_out = 1.0;\n          ATTN_B.left_trigger_out = 0.0;\n        } else {\n          ATTN_B.left_trigger_out = 1.0;\n          ATTN_B.right_trigger_out = 0.0;\n        }\n\n        ATTN_B.was_target_out = 0.0;\n      } else {\n        if (ATTN_cal->targetSide != 0.0) {\n          ATTN_B.left_trigger_out = 1.0;\n          ATTN_B.right_trigger_out = 0.0;\n        } else {\n          ATTN_B.right_trigger_out = 1.0;\n          ATTN_B.left_trigger_out = 0.0;\n        }\n\n        ATTN_B.was_target_out = 1.0;\n      }\n\n      ATTN_B.state_out = 4.0;\n      ATTN_B.delay_out = ATTN_B.clock_time + 0.2;\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 4:\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n        ATTN_B.delay_out = ATTN_B.Memory5;\n      } else {\n        ATTN_B.state_out = 5.0;\n        ATTN_B.delay_out = ATTN_B.clock_time + 1.5;\n      }\n\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.left_trigger_out = 0.0;\n      ATTN_B.right_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 5:\n      if (ATTN_B.Lick != 0.0) {\n        ATTN_B.numLicks_out = ATTN_B.Memory9 + 1.0;\n      } else {\n        ATTN_B.numLicks_out = ATTN_B.Memory9;\n      }\n\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n      } else if ((ATTN_B.Memory9 != 0.0) && (ATTN_B.Memory10 != 0.0)) {\n        ATTN_B.state_out = 6.0;\n      } else {\n        ATTN_B.state_out = 1.0;\n      }\n\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.delay_out = ATTN_B.Memory5;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 6:\n      ATTN_B.reward_trigger_out = 1.0;\n      ATTN_B.state_out = 7.0;\n      ATTN_B.delay_out = ATTN_B.clock_time + 0.5;\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 7:\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n      } else {\n        ATTN_B.state_out = 1.0;\n      }\n\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.delay_out = ATTN_B.Memory5;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     default:\n      ATTN_B.state_out = ATTN_B.Memory2;\n      ATTN_B.localTime_out = ATTN_B.Memory1;\n      ATTN_B.trialNum_out = ATTN_B.Memory;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.delay_out = ATTN_B.Memory5;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n    }\n    break;\n\n   case 3:\n    switch (static_cast<int32_T>(ATTN_B.Memory2)) {\n     case 1:\n      ATTN_B.npxlsAcq_out = 1.0;\n      ATTN_B.state_out = 2.0;\n      ATTN_B.localTime_out = 1.0;\n      ATTN_B.trialNum_out = 1.0;\n      ATTN_B.right_trigger_out = 0.0;\n      ATTN_B.left_trigger_out = 0.0;\n      if ((!(ATTN_B.Memory10 != 0.0)) && (!(ATTN_B.Memory9 != 0.0))) {\n        b_y1 = 1.0;\n        while ((b_y1 >= 4.0) || (b_y1 <= 2.0)) {\n          b_y1 = ATTN_rand();\n          b_y1 = std::log(b_y1);\n          b_y1 *= -3.0;\n        }\n\n        ATTN_B.delay_out = ATTN_B.clock_time + b_y1;\n      } else {\n        b_y1 = 4.0;\n        while ((b_y1 >= 9.0) || (b_y1 <= 5.0)) {\n          b_y1 = ATTN_rand();\n          b_y1 = std::log(b_y1);\n          b_y1 *= -7.0;\n        }\n\n        ATTN_B.delay_out = ATTN_B.clock_time + b_y1;\n      }\n\n      ATTN_B.numLicks_out = 0.0;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = 0.0;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 2:\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n      } else {\n        ATTN_B.state_out = 3.0;\n      }\n\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.delay_out = ATTN_B.Memory5;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 3:\n      if (ATTN_rand() <= 0.8) {\n        if (ATTN_cal->targetSide != 0.0) {\n          ATTN_B.right_trigger_out = 1.0;\n          ATTN_B.left_trigger_out = 0.0;\n        } else {\n          ATTN_B.left_trigger_out = 1.0;\n          ATTN_B.right_trigger_out = 0.0;\n        }\n\n        ATTN_B.was_target_out = 0.0;\n      } else {\n        if (ATTN_cal->targetSide != 0.0) {\n          ATTN_B.left_trigger_out = 1.0;\n          ATTN_B.right_trigger_out = 0.0;\n        } else {\n          ATTN_B.right_trigger_out = 1.0;\n          ATTN_B.left_trigger_out = 0.0;\n        }\n\n        ATTN_B.was_target_out = 1.0;\n      }\n\n      ATTN_B.state_out = 4.0;\n      ATTN_B.delay_out = ATTN_B.clock_time + 0.2;\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 4:\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n        ATTN_B.delay_out = ATTN_B.Memory5;\n      } else {\n        ATTN_B.state_out = 5.0;\n        ATTN_B.delay_out = ATTN_B.clock_time + 1.0;\n      }\n\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.left_trigger_out = 0.0;\n      ATTN_B.right_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 5:\n      if ((ATTN_B.Memory10 != 0.0) && (ATTN_rand() < 0.2)) {\n        ATTN_B.numLicks_out = ATTN_B.Memory9 + 1.0;\n      } else if ((!(ATTN_B.Memory10 != 0.0)) && (ATTN_rand() < 0.001)) {\n        ATTN_B.numLicks_out = ATTN_B.Memory9 + 1.0;\n      } else {\n        ATTN_B.numLicks_out = ATTN_B.Memory9;\n      }\n\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n      } else if ((ATTN_B.Memory9 != 0.0) && (ATTN_B.Memory10 != 0.0)) {\n        ATTN_B.state_out = 6.0;\n      } else {\n        ATTN_B.state_out = 1.0;\n      }\n\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.delay_out = ATTN_B.Memory5;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 6:\n      ATTN_B.reward_trigger_out = 1.0;\n      ATTN_B.state_out = 7.0;\n      ATTN_B.delay_out = ATTN_B.clock_time + 0.5;\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 7:\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n      } else {\n        ATTN_B.state_out = 1.0;\n      }\n\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.delay_out = ATTN_B.Memory5;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     default:\n      ATTN_B.state_out = ATTN_B.Memory2;\n      ATTN_B.localTime_out = ATTN_B.Memory1;\n      ATTN_B.trialNum_out = ATTN_B.Memory;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.delay_out = ATTN_B.Memory5;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n    }\n    break;\n\n   case 111:\n    if (static_cast<int32_T>(ATTN_B.Memory2) == 1) {\n      ATTN_B.npxlsAcq_out = 0.0;\n      ATTN_B.localTime_out = 1.0;\n      ATTN_B.trialNum_out = 1.0;\n      ATTN_B.right_trigger_out = 0.0;\n      ATTN_B.left_trigger_out = 0.0;\n      ATTN_B.delay_out = ATTN_B.clock_time + 5.0;\n      ATTN_B.numLicks_out = 0.0;\n      ATTN_B.reward_trigger_out = 1.0;\n      ATTN_B.was_target_out = 0.0;\n      ATTN_B.reward_duration_out = 0.03;\n      ATTN_B.state_out = 2.0;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n    } else {\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n        ATTN_B.reward_trigger_out = 0.0;\n        ATTN_B.delay_out = ATTN_B.Memory5;\n        ATTN_B.reward_duration_out = 0.03;\n      } else {\n        ATTN_B.state_out = ATTN_B.Memory2 + 1.0;\n        ATTN_B.reward_trigger_out = 1.0;\n        ATTN_B.delay_out = ATTN_B.clock_time + 5.0;\n        ATTN_B.reward_duration_out = 0.03;\n      }\n\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n    }\n    break;\n\n   case 222:\n    if (static_cast<int32_T>(ATTN_B.Memory2) == 1) {\n      ATTN_B.npxlsAcq_out = 0.0;\n      ATTN_B.localTime_out = 1.0;\n      ATTN_B.trialNum_out = 1.0;\n      if (ATTN_cal->targetSide != 0.0) {\n        ATTN_B.right_trigger_out = 1.0;\n        ATTN_B.left_trigger_out = 0.0;\n      } else {\n        ATTN_B.left_trigger_out = 1.0;\n        ATTN_B.right_trigger_out = 0.0;\n      }\n\n      ATTN_B.delay_out = ATTN_B.clock_time + 10.0;\n      ATTN_B.numLicks_out = 0.0;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = 0.0;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.state_out = 2.0;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n    } else {\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n        ATTN_B.delay_out = ATTN_B.Memory5;\n        ATTN_B.left_trigger_out = 0.0;\n        ATTN_B.right_trigger_out = 0.0;\n      } else {\n        ATTN_B.state_out = ATTN_B.Memory2 + 1.0;\n        ATTN_B.delay_out = ATTN_B.clock_time + 10.0;\n        if (ATTN_cal->targetSide != 0.0) {\n          ATTN_B.right_trigger_out = 1.0;\n          ATTN_B.left_trigger_out = 0.0;\n        } else {\n          ATTN_B.left_trigger_out = 1.0;\n          ATTN_B.right_trigger_out = 0.0;\n        }\n      }\n\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n    }\n    break;\n\n   default:\n    if (static_cast<int32_T>(ATTN_B.Memory2) == 1) {\n      ATTN_B.npxlsAcq_out = 0.0;\n      ATTN_B.localTime_out = 1.0;\n      ATTN_B.trialNum_out = 1.0;\n      if (ATTN_cal->targetSide != 0.0) {\n        ATTN_B.right_trigger_out = 1.0;\n        ATTN_B.left_trigger_out = 0.0;\n      } else {\n        ATTN_B.left_trigger_out = 1.0;\n        ATTN_B.right_trigger_out = 0.0;\n      }\n\n      ATTN_B.delay_out = ATTN_B.clock_time + 10.0;\n      ATTN_B.numLicks_out = 0.0;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = 0.0;\n      ATTN_B.stim_duration_out = 0.05;\n      ATTN_B.state_out = 2.0;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n    } else {\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n        ATTN_B.delay_out = ATTN_B.Memory5;\n        ATTN_B.left_trigger_out = 0.0;\n        ATTN_B.right_trigger_out = 0.0;\n        ATTN_B.stim_duration_out = (ATTN_B.Memory2 - 1.0) * 0.05;\n      } else {\n        ATTN_B.state_out = ATTN_B.Memory2 + 1.0;\n        ATTN_B.delay_out = ATTN_B.clock_time + 10.0;\n        if (ATTN_cal->targetSide != 0.0) {\n          ATTN_B.right_trigger_out = 1.0;\n          ATTN_B.left_trigger_out = 0.0;\n        } else {\n          ATTN_B.left_trigger_out = 1.0;\n          ATTN_B.right_trigger_out = 0.0;\n        }\n\n        ATTN_B.stim_duration_out = 0.05 * ATTN_B.Memory2;\n      }\n\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n    }\n    break;\n  }\n\n  /* End of MATLAB Function: '<Root>/MATLAB Function' */\n\n  /* Clock: '<S4>/Clock1' */\n  ATTN_B.Clock1 = ATTN_M->Timing.t[0];\n\n  /* MATLAB Function: '<S4>/MATLAB Function1' incorporates:\n   *  Constant: '<Root>/triangleAmplitude'\n   */\n  ATTN_MATLABFunction2(ATTN_B.Memory8, ATTN_B.stim_duration_out,\n                       ATTN_cal->triangleAmplitude, ATTN_B.Clock1,\n                       &ATTN_B.sf_MATLABFunction1_d,\n                       &ATTN_DW.sf_MATLABFunction1_d);\n\n  /* Clock: '<S3>/Clock2' */\n  ATTN_B.Clock2 = ATTN_M->Timing.t[0];\n\n  /* MATLAB Function: '<S3>/MATLAB Function2' incorporates:\n   *  Constant: '<Root>/triangleAmplitude'\n   */\n  ATTN_MATLABFunction2(ATTN_B.Memory6, ATTN_B.stim_duration_out,\n                       ATTN_cal->triangleAmplitude, ATTN_B.Clock2,\n                       &ATTN_B.sf_MATLABFunction2, &ATTN_DW.sf_MATLABFunction2);\n\n  /* S-Function (sg_IO191_da_s): '<Root>/Analog output ' */\n\n  /* Level2 S-Function Block: '<Root>/Analog output ' (sg_IO191_da_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[2];\n    sfcnOutputs(rts,0);\n  }\n\n  /* DiscretePulseGenerator: '<Root>/Whisker Trig' */\n  b_y1 = ATTN_cal->T_whisk / 2.0;\n\n  /* DiscretePulseGenerator: '<Root>/Whisker Trig' */\n  ATTN_B.whiskCam_trig = (ATTN_DW.clockTickCounter < b_y1) &&\n    (ATTN_DW.clockTickCounter >= 0) ? ATTN_cal->WhiskerTrig_Amp : 0.0;\n\n  /* DiscretePulseGenerator: '<Root>/Whisker Trig' */\n  if (ATTN_DW.clockTickCounter >= ATTN_cal->T_whisk - 1.0) {\n    ATTN_DW.clockTickCounter = 0;\n  } else {\n    ATTN_DW.clockTickCounter++;\n  }\n\n  /* DiscretePulseGenerator: '<Root>/Npxls Trig' */\n  b_y1 = ATTN_cal->T_npxls / 2.0;\n\n  /* DiscretePulseGenerator: '<Root>/Npxls Trig' */\n  ATTN_B.npxls_trig = (ATTN_DW.clockTickCounter_n < b_y1) &&\n    (ATTN_DW.clockTickCounter_n >= 0) ? ATTN_cal->NpxlsTrig_Amp : 0.0;\n\n  /* DiscretePulseGenerator: '<Root>/Npxls Trig' */\n  if (ATTN_DW.clockTickCounter_n >= ATTN_cal->T_npxls - 1.0) {\n    ATTN_DW.clockTickCounter_n = 0;\n  } else {\n    ATTN_DW.clockTickCounter_n++;\n  }\n\n  /* DiscretePulseGenerator: '<Root>/Pupil Trig' */\n  b_y1 = ATTN_cal->T_pupil / 2.0;\n\n  /* DiscretePulseGenerator: '<Root>/Pupil Trig' */\n  ATTN_B.pupilCam_trig = (ATTN_DW.clockTickCounter_c < b_y1) &&\n    (ATTN_DW.clockTickCounter_c >= 0) ? ATTN_cal->PupilTrig_Amp : 0.0;\n\n  /* DiscretePulseGenerator: '<Root>/Pupil Trig' */\n  if (ATTN_DW.clockTickCounter_c >= ATTN_cal->T_pupil - 1.0) {\n    ATTN_DW.clockTickCounter_c = 0;\n  } else {\n    ATTN_DW.clockTickCounter_c++;\n  }\n\n  /* Clock: '<S5>/Clock1' */\n  ATTN_B.Clock1_b = ATTN_M->Timing.t[0];\n\n  /* MATLAB Function: '<S5>/MATLAB Function1' incorporates:\n   *  Constant: '<S5>/Constant4'\n   */\n  ATTN_DW.sfEvent_a = ATTN_CALL_EVENT_n;\n  if (ATTN_B.reward_trigger_out != 0.0) {\n    ATTN_DW.t0_p = ATTN_B.Clock1_b;\n    ATTN_DW.t0_not_empty_p = true;\n    ATTN_B.y = ATTN_cal->Constant4_Value;\n  } else if (ATTN_DW.t0_not_empty_p) {\n    if (ATTN_B.Clock1_b - ATTN_DW.t0_p <= ATTN_B.reward_duration_out) {\n      ATTN_B.y = ATTN_cal->Constant4_Value;\n    } else {\n      ATTN_B.y = 0.0;\n    }\n  } else {\n    ATTN_B.y = 0.0;\n  }\n\n  /* End of MATLAB Function: '<S5>/MATLAB Function1' */\n\n  /* Clock: '<S6>/Clock1' */\n  ATTN_B.Clock1_l = ATTN_M->Timing.t[0];\n\n  /* MATLAB Function: '<S6>/MATLAB Function1' */\n  ATTN_DW.sfEvent = ATTN_CALL_EVENT_n;\n  if (ATTN_B.onsetTone_trig != 0.0) {\n    ATTN_B.tonePulse = 1.0;\n    ATTN_DW.t0 = ATTN_B.Clock1_l;\n    ATTN_DW.t0_not_empty = true;\n  } else if (ATTN_DW.t0_not_empty) {\n    ATTN_B.tonePulse = (ATTN_B.Clock1_l - ATTN_DW.t0 < 1.5);\n  } else {\n    ATTN_B.tonePulse = 0.0;\n  }\n\n  /* End of MATLAB Function: '<S6>/MATLAB Function1' */\n\n  /* S-Function (sg_IO191_do_s): '<Root>/Digital output ' */\n\n  /* Level2 S-Function Block: '<Root>/Digital output ' (sg_IO191_do_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[3];\n    sfcnOutputs(rts,0);\n  }\n\n  /* S-Function (sg_IO191_di_s): '<Root>/Digital input ' */\n\n  /* Level2 S-Function Block: '<Root>/Digital input ' (sg_IO191_di_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[4];\n    sfcnOutputs(rts,0);\n  }\n\n  /* RateTransition generated from: '<Root>/Digital input ' */\n  ATTN_B.HiddenRateTransitionForToWks_In = ATTN_B.PulseGen1Hz;\n\n  /* RelationalOperator: '<Root>/Relational Operator' incorporates:\n   *  Constant: '<Root>/Constant'\n   */\n  ATTN_B.RelationalOperator = (ATTN_B.counter_out >= ATTN_cal->maxFrame);\n\n  /* Stop: '<Root>/Stop Simulation' */\n  if (ATTN_B.RelationalOperator) {\n    rtmSetStopRequested(ATTN_M, 1);\n  }\n\n  /* End of Stop: '<Root>/Stop Simulation' */\n\n  /* Update for Memory: '<Root>/Memory8' */\n  ATTN_DW.Memory8_PreviousInput = ATTN_B.right_trigger_out;\n\n  /* Update for Memory: '<Root>/Memory2' */\n  ATTN_DW.Memory2_PreviousInput = ATTN_B.state_out;\n\n  /* Update for Memory: '<Root>/Memory1' */\n  ATTN_DW.Memory1_PreviousInput = ATTN_B.localTime_out;\n\n  /* Update for Memory: '<Root>/Memory' */\n  ATTN_DW.Memory_PreviousInput = ATTN_B.trialNum_out;\n\n  /* Update for DiscreteFilter: '<Root>/Discrete Filter' */\n  ATTN_DW.DiscreteFilter_states = ATTN_DW.DiscreteFilter_tmp;\n\n  /* Update for Memory: '<Root>/Memory11' */\n  ATTN_DW.Memory11_PreviousInput = ATTN_B.y1;\n\n  /* Update for Memory: '<Root>/Memory7' */\n  ATTN_DW.Memory7_PreviousInput = ATTN_B.y2;\n\n  /* Update for Memory: '<Root>/Memory3' */\n  ATTN_DW.Memory3_PreviousInput = ATTN_B.npxlsAcq_out;\n\n  /* Update for Memory: '<Root>/Memory4' */\n  ATTN_DW.Memory4_PreviousInput = ATTN_B.counter_out;\n\n  /* Update for Memory: '<Root>/Memory9' */\n  ATTN_DW.Memory9_PreviousInput = ATTN_B.numLicks_out;\n\n  /* Update for Memory: '<Root>/Memory5' */\n  ATTN_DW.Memory5_PreviousInput = ATTN_B.delay_out;\n\n  /* Update for Memory: '<Root>/Memory6' */\n  ATTN_DW.Memory6_PreviousInput = ATTN_B.left_trigger_out;\n\n  /* Update for Memory: '<Root>/Memory10' */\n  ATTN_DW.Memory10_PreviousInput = ATTN_B.was_target_out;\n\n  /* Update absolute time for base rate */\n  /* The \"clockTick0\" counts the number of times the code of this task has\n   * been executed. The absolute time is the multiplication of \"clockTick0\"\n   * and \"Timing.stepSize0\". Size of \"clockTick0\" ensures timer will not\n   * overflow during the application lifespan selected.\n   * Timer of this task consists of two 32 bit unsigned integers.\n   * The two integers represent the low bits Timing.clockTick0 and the high bits\n   * Timing.clockTickH0. When the low bit overflows to 0, the high bits increment.\n   */\n  if (!(++ATTN_M->Timing.clockTick0)) {\n    ++ATTN_M->Timing.clockTickH0;\n  }\n\n  ATTN_M->Timing.t[0] = ATTN_M->Timing.clockTick0 * ATTN_M->Timing.stepSize0 +\n    ATTN_M->Timing.clockTickH0 * ATTN_M->Timing.stepSize0 * 4294967296.0;\n\n  {\n    /* Update absolute timer for sample time: [0.001s, 0.0s] */\n    /* The \"clockTick1\" counts the number of times the code of this task has\n     * been executed. The absolute time is the multiplication of \"clockTick1\"\n     * and \"Timing.stepSize1\". Size of \"clockTick1\" ensures timer will not\n     * overflow during the application lifespan selected.\n     * Timer of this task consists of two 32 bit unsigned integers.\n     * The two integers represent the low bits Timing.clockTick1 and the high bits\n     * Timing.clockTickH1. When the low bit overflows to 0, the high bits increment.\n     */\n    if (!(++ATTN_M->Timing.clockTick1)) {\n      ++ATTN_M->Timing.clockTickH1;\n    }\n\n    ATTN_M->Timing.t[1] = ATTN_M->Timing.clockTick1 * ATTN_M->Timing.stepSize1 +\n      ATTN_M->Timing.clockTickH1 * ATTN_M->Timing.stepSize1 * 4294967296.0;\n  }\n}\n\n/* Model initialize function */\nvoid ATTN_initialize(void)\n{\n  /* Registration code */\n\n  /* initialize non-finites */\n  rt_InitInfAndNaN(sizeof(real_T));\n\n  {\n    /* Setup solver object */\n    rtsiSetSimTimeStepPtr(&ATTN_M->solverInfo, &ATTN_M->Timing.simTimeStep);\n    rtsiSetTPtr(&ATTN_M->solverInfo, &rtmGetTPtr(ATTN_M));\n    rtsiSetStepSizePtr(&ATTN_M->solverInfo, &ATTN_M->Timing.stepSize0);\n    rtsiSetErrorStatusPtr(&ATTN_M->solverInfo, (&rtmGetErrorStatus(ATTN_M)));\n    rtsiSetRTModelPtr(&ATTN_M->solverInfo, ATTN_M);\n  }\n\n  rtsiSetSimTimeStep(&ATTN_M->solverInfo, MAJOR_TIME_STEP);\n  rtsiSetSolverName(&ATTN_M->solverInfo,\"FixedStepDiscrete\");\n  ATTN_M->solverInfoPtr = (&ATTN_M->solverInfo);\n\n  /* Initialize timing info */\n  {\n    int_T *mdlTsMap = ATTN_M->Timing.sampleTimeTaskIDArray;\n    mdlTsMap[0] = 0;\n    mdlTsMap[1] = 1;\n\n    /* polyspace +2 MISRA2012:D4.1 [Justified:Low] \"ATTN_M points to\n       static memory which is guaranteed to be non-NULL\" */\n    ATTN_M->Timing.sampleTimeTaskIDPtr = (&mdlTsMap[0]);\n    ATTN_M->Timing.sampleTimes = (&ATTN_M->Timing.sampleTimesArray[0]);\n    ATTN_M->Timing.offsetTimes = (&ATTN_M->Timing.offsetTimesArray[0]);\n\n    /* task periods */\n    ATTN_M->Timing.sampleTimes[0] = (0.0);\n    ATTN_M->Timing.sampleTimes[1] = (0.001);\n\n    /* task offsets */\n    ATTN_M->Timing.offsetTimes[0] = (0.0);\n    ATTN_M->Timing.offsetTimes[1] = (0.0);\n  }\n\n  rtmSetTPtr(ATTN_M, &ATTN_M->Timing.tArray[0]);\n\n  {\n    int_T *mdlSampleHits = ATTN_M->Timing.sampleHitArray;\n    mdlSampleHits[0] = 1;\n    mdlSampleHits[1] = 1;\n    ATTN_M->Timing.sampleHits = (&mdlSampleHits[0]);\n  }\n\n  rtmSetTFinal(ATTN_M, -1);\n  ATTN_M->Timing.stepSize0 = 0.001;\n  ATTN_M->Timing.stepSize1 = 0.001;\n  ATTN_M->solverInfoPtr = (&ATTN_M->solverInfo);\n  ATTN_M->Timing.stepSize = (0.001);\n  rtsiSetFixedStepSize(&ATTN_M->solverInfo, 0.001);\n  rtsiSetSolverMode(&ATTN_M->solverInfo, SOLVER_MODE_SINGLETASKING);\n\n  /* block I/O */\n  (void) std::memset((static_cast<void *>(&ATTN_B)), 0,\n                     sizeof(B_ATTN_T));\n\n  /* states (dwork) */\n  (void) std::memset(static_cast<void *>(&ATTN_DW), 0,\n                     sizeof(DW_ATTN_T));\n\n  /* child S-Function registration */\n  {\n    RTWSfcnInfo *sfcnInfo = &ATTN_M->NonInlinedSFcns.sfcnInfo;\n    ATTN_M->sfcnInfo = (sfcnInfo);\n    rtssSetErrorStatusPtr(sfcnInfo, (&rtmGetErrorStatus(ATTN_M)));\n    ATTN_M->Sizes.numSampTimes = (2);\n    rtssSetNumRootSampTimesPtr(sfcnInfo, &ATTN_M->Sizes.numSampTimes);\n    ATTN_M->NonInlinedSFcns.taskTimePtrs[0] = (&rtmGetTPtr(ATTN_M)[0]);\n    ATTN_M->NonInlinedSFcns.taskTimePtrs[1] = (&rtmGetTPtr(ATTN_M)[1]);\n    rtssSetTPtrPtr(sfcnInfo,ATTN_M->NonInlinedSFcns.taskTimePtrs);\n    rtssSetTStartPtr(sfcnInfo, &rtmGetTStart(ATTN_M));\n    rtssSetTFinalPtr(sfcnInfo, &rtmGetTFinal(ATTN_M));\n    rtssSetTimeOfLastOutputPtr(sfcnInfo, &rtmGetTimeOfLastOutput(ATTN_M));\n    rtssSetStepSizePtr(sfcnInfo, &ATTN_M->Timing.stepSize);\n    rtssSetStopRequestedPtr(sfcnInfo, &rtmGetStopRequested(ATTN_M));\n    rtssSetDerivCacheNeedsResetPtr(sfcnInfo, &ATTN_M->derivCacheNeedsReset);\n    rtssSetZCCacheNeedsResetPtr(sfcnInfo, &ATTN_M->zCCacheNeedsReset);\n    rtssSetContTimeOutputInconsistentWithStateAtMajorStepPtr(sfcnInfo,\n      &ATTN_M->CTOutputIncnstWithState);\n    rtssSetSampleHitsPtr(sfcnInfo, &ATTN_M->Timing.sampleHits);\n    rtssSetPerTaskSampleHitsPtr(sfcnInfo, &ATTN_M->Timing.perTaskSampleHits);\n    rtssSetSimModePtr(sfcnInfo, &ATTN_M->simMode);\n    rtssSetSolverInfoPtr(sfcnInfo, &ATTN_M->solverInfoPtr);\n  }\n\n  ATTN_M->Sizes.numSFcns = (5);\n\n  /* register each child */\n  {\n    (void) std::memset(static_cast<void *>\n                       (&ATTN_M->NonInlinedSFcns.childSFunctions[0]), 0,\n                       5*sizeof(SimStruct));\n    ATTN_M->childSfunctions = (&ATTN_M->NonInlinedSFcns.childSFunctionPtrs[0]);\n\n    {\n      int_T i;\n      for (i = 0; i < 5; i++) {\n        ATTN_M->childSfunctions[i] = (&ATTN_M->NonInlinedSFcns.childSFunctions[i]);\n      }\n    }\n\n    /* Level2 S-Function Block: ATTN/<Root>/Setup  (sg_IO191_setup_s) */\n    {\n      SimStruct *rts = ATTN_M->childSfunctions[0];\n\n      /* timing info */\n      time_T *sfcnPeriod = ATTN_M->NonInlinedSFcns.Sfcn0.sfcnPeriod;\n      time_T *sfcnOffset = ATTN_M->NonInlinedSFcns.Sfcn0.sfcnOffset;\n      int_T *sfcnTsMap = ATTN_M->NonInlinedSFcns.Sfcn0.sfcnTsMap;\n      (void) std::memset(static_cast<void*>(sfcnPeriod), 0,\n                         sizeof(time_T)*1);\n      (void) std::memset(static_cast<void*>(sfcnOffset), 0,\n                         sizeof(time_T)*1);\n      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);\n      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);\n      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);\n\n      {\n        ssSetBlkInfo2Ptr(rts, &ATTN_M->NonInlinedSFcns.blkInfo2[0]);\n      }\n\n      _ssSetBlkInfo2PortInfo2Ptr(rts,\n        &ATTN_M->NonInlinedSFcns.inputOutputPortInfo2[0]);\n\n      /* Set up the mdlInfo pointer */\n      ssSetRTWSfcnInfo(rts, ATTN_M->sfcnInfo);\n\n      /* Allocate memory of model methods 2 */\n      {\n        ssSetModelMethods2(rts, &ATTN_M->NonInlinedSFcns.methods2[0]);\n      }\n\n      /* Allocate memory of model methods 3 */\n      {\n        ssSetModelMethods3(rts, &ATTN_M->NonInlinedSFcns.methods3[0]);\n      }\n\n      /* Allocate memory of model methods 4 */\n      {\n        ssSetModelMethods4(rts, &ATTN_M->NonInlinedSFcns.methods4[0]);\n      }\n\n      /* Allocate memory for states auxilliary information */\n      {\n        ssSetStatesInfo2(rts, &ATTN_M->NonInlinedSFcns.statesInfo2[0]);\n        ssSetPeriodicStatesInfo(rts, &ATTN_M->\n          NonInlinedSFcns.periodicStatesInfo[0]);\n      }\n\n      /* path info */\n      ssSetModelName(rts, \"Setup \");\n      ssSetPath(rts, \"ATTN/Setup \");\n      ssSetRTModel(rts,ATTN_M);\n      ssSetParentSS(rts, (NULL));\n      ssSetRootSS(rts, rts);\n      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);\n\n      /* parameters */\n      {\n        mxArray **sfcnParams = (mxArray **)\n          &ATTN_M->NonInlinedSFcns.Sfcn0.params;\n        ssSetSFcnParamsCount(rts, 9);\n        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);\n        ssSetSFcnParam(rts, 0, (mxArray*)ATTN_cal->Setup_P1_Size);\n        ssSetSFcnParam(rts, 1, (mxArray*)ATTN_cal->Setup_P2_Size);\n        ssSetSFcnParam(rts, 2, (mxArray*)ATTN_cal->Setup_P3_Size);\n        ssSetSFcnParam(rts, 3, (mxArray*)ATTN_cal->Setup_P4_Size);\n        ssSetSFcnParam(rts, 4, (mxArray*)ATTN_cal->Setup_P5_Size);\n        ssSetSFcnParam(rts, 5, (mxArray*)ATTN_cal->Setup_P6_Size);\n        ssSetSFcnParam(rts, 6, (mxArray*)ATTN_cal->Setup_P7_Size);\n        ssSetSFcnParam(rts, 7, (mxArray*)ATTN_cal->Setup_P8_Size);\n        ssSetSFcnParam(rts, 8, (mxArray*)ATTN_cal->Setup_P9_Size);\n      }\n\n      /* work vectors */\n      ssSetRWork(rts, (real_T *) &ATTN_DW.Setup_RWORK[0]);\n      ssSetPWork(rts, (void **) &ATTN_DW.Setup_PWORK);\n\n      {\n        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)\n          &ATTN_M->NonInlinedSFcns.Sfcn0.dWork;\n        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)\n          &ATTN_M->NonInlinedSFcns.Sfcn0.dWorkAux;\n        ssSetSFcnDWork(rts, dWorkRecord);\n        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);\n        ssSetNumDWorkAsInt(rts, 2);\n\n        /* RWORK */\n        ssSetDWorkWidthAsInt(rts, 0, 2);\n        ssSetDWorkDataType(rts, 0,SS_DOUBLE);\n        ssSetDWorkComplexSignal(rts, 0, 0);\n        ssSetDWork(rts, 0, &ATTN_DW.Setup_RWORK[0]);\n\n        /* PWORK */\n        ssSetDWorkWidthAsInt(rts, 1, 1);\n        ssSetDWorkDataType(rts, 1,SS_POINTER);\n        ssSetDWorkComplexSignal(rts, 1, 0);\n        ssSetDWork(rts, 1, &ATTN_DW.Setup_PWORK);\n      }\n\n      /* registration */\n      sg_IO191_setup_s(rts);\n      sfcnInitializeSizes(rts);\n      sfcnInitializeSampleTimes(rts);\n\n      /* adjust sample time */\n      ssSetSampleTime(rts, 0, 0.001);\n      ssSetOffsetTime(rts, 0, 0.0);\n      sfcnTsMap[0] = 1;\n\n      /* set compiled values of dynamic vector attributes */\n      ssSetNumNonsampledZCsAsInt(rts, 0);\n\n      /* Update connectivity flags for each port */\n      /* Update the BufferDstPort flags for each input port */\n    }\n\n    /* Level2 S-Function Block: ATTN/<Root>/Analog input  (sg_IO191_ad_s) */\n    {\n      SimStruct *rts = ATTN_M->childSfunctions[1];\n\n      /* timing info */\n      time_T *sfcnPeriod = ATTN_M->NonInlinedSFcns.Sfcn1.sfcnPeriod;\n      time_T *sfcnOffset = ATTN_M->NonInlinedSFcns.Sfcn1.sfcnOffset;\n      int_T *sfcnTsMap = ATTN_M->NonInlinedSFcns.Sfcn1.sfcnTsMap;\n      (void) std::memset(static_cast<void*>(sfcnPeriod), 0,\n                         sizeof(time_T)*1);\n      (void) std::memset(static_cast<void*>(sfcnOffset), 0,\n                         sizeof(time_T)*1);\n      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);\n      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);\n      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);\n\n      {\n        ssSetBlkInfo2Ptr(rts, &ATTN_M->NonInlinedSFcns.blkInfo2[1]);\n      }\n\n      _ssSetBlkInfo2PortInfo2Ptr(rts,\n        &ATTN_M->NonInlinedSFcns.inputOutputPortInfo2[1]);\n\n      /* Set up the mdlInfo pointer */\n      ssSetRTWSfcnInfo(rts, ATTN_M->sfcnInfo);\n\n      /* Allocate memory of model methods 2 */\n      {\n        ssSetModelMethods2(rts, &ATTN_M->NonInlinedSFcns.methods2[1]);\n      }\n\n      /* Allocate memory of model methods 3 */\n      {\n        ssSetModelMethods3(rts, &ATTN_M->NonInlinedSFcns.methods3[1]);\n      }\n\n      /* Allocate memory of model methods 4 */\n      {\n        ssSetModelMethods4(rts, &ATTN_M->NonInlinedSFcns.methods4[1]);\n      }\n\n      /* Allocate memory for states auxilliary information */\n      {\n        ssSetStatesInfo2(rts, &ATTN_M->NonInlinedSFcns.statesInfo2[1]);\n        ssSetPeriodicStatesInfo(rts, &ATTN_M->\n          NonInlinedSFcns.periodicStatesInfo[1]);\n      }\n\n      /* outputs */\n      {\n        ssSetPortInfoForOutputs(rts,\n          &ATTN_M->NonInlinedSFcns.Sfcn1.outputPortInfo[0]);\n        ssSetPortInfoForOutputs(rts,\n          &ATTN_M->NonInlinedSFcns.Sfcn1.outputPortInfo[0]);\n        _ssSetNumOutputPorts(rts, 2);\n        _ssSetPortInfo2ForOutputUnits(rts,\n          &ATTN_M->NonInlinedSFcns.Sfcn1.outputPortUnits[0]);\n        ssSetOutputPortUnit(rts, 0, 0);\n        ssSetOutputPortUnit(rts, 1, 0);\n        _ssSetPortInfo2ForOutputCoSimAttribute(rts,\n          &ATTN_M->NonInlinedSFcns.Sfcn1.outputPortCoSimAttribute[0]);\n        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);\n        ssSetOutputPortIsContinuousQuantity(rts, 1, 0);\n\n        /* port 0 */\n        {\n          _ssSetOutputPortNumDimensions(rts, 0, 1);\n          ssSetOutputPortWidthAsInt(rts, 0, 1);\n          ssSetOutputPortSignal(rts, 0, ((real_T *) &ATTN_B.Analoginput_o1));\n        }\n\n        /* port 1 */\n        {\n          _ssSetOutputPortNumDimensions(rts, 1, 1);\n          ssSetOutputPortWidthAsInt(rts, 1, 1);\n          ssSetOutputPortSignal(rts, 1, ((real_T *) &ATTN_B.lickometer_piezo));\n        }\n      }\n\n      /* path info */\n      ssSetModelName(rts, \"Analog input \");\n      ssSetPath(rts, \"ATTN/Analog input \");\n      ssSetRTModel(rts,ATTN_M);\n      ssSetParentSS(rts, (NULL));\n      ssSetRootSS(rts, rts);\n      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);\n\n      /* parameters */\n      {\n        mxArray **sfcnParams = (mxArray **)\n          &ATTN_M->NonInlinedSFcns.Sfcn1.params;\n        ssSetSFcnParamsCount(rts, 9);\n        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);\n        ssSetSFcnParam(rts, 0, (mxArray*)ATTN_cal->Analoginput_P1_Size);\n        ssSetSFcnParam(rts, 1, (mxArray*)ATTN_cal->Analoginput_P2_Size);\n        ssSetSFcnParam(rts, 2, (mxArray*)ATTN_cal->Analoginput_P3_Size);\n        ssSetSFcnParam(rts, 3, (mxArray*)ATTN_cal->Analoginput_P4_Size);\n        ssSetSFcnParam(rts, 4, (mxArray*)ATTN_cal->Analoginput_P5_Size);\n        ssSetSFcnParam(rts, 5, (mxArray*)ATTN_cal->Analoginput_P6_Size);\n        ssSetSFcnParam(rts, 6, (mxArray*)ATTN_cal->Analoginput_P7_Size);\n        ssSetSFcnParam(rts, 7, (mxArray*)ATTN_cal->Analoginput_P8_Size);\n        ssSetSFcnParam(rts, 8, (mxArray*)ATTN_cal->Analoginput_P9_Size);\n      }\n\n      /* work vectors */\n      ssSetIWork(rts, (int_T *) &ATTN_DW.Analoginput_IWORK[0]);\n      ssSetPWork(rts, (void **) &ATTN_DW.Analoginput_PWORK);\n\n      {\n        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)\n          &ATTN_M->NonInlinedSFcns.Sfcn1.dWork;\n        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)\n          &ATTN_M->NonInlinedSFcns.Sfcn1.dWorkAux;\n        ssSetSFcnDWork(rts, dWorkRecord);\n        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);\n        ssSetNumDWorkAsInt(rts, 2);\n\n        /* IWORK */\n        ssSetDWorkWidthAsInt(rts, 0, 2);\n        ssSetDWorkDataType(rts, 0,SS_INTEGER);\n        ssSetDWorkComplexSignal(rts, 0, 0);\n        ssSetDWork(rts, 0, &ATTN_DW.Analoginput_IWORK[0]);\n\n        /* PWORK */\n        ssSetDWorkWidthAsInt(rts, 1, 1);\n        ssSetDWorkDataType(rts, 1,SS_POINTER);\n        ssSetDWorkComplexSignal(rts, 1, 0);\n        ssSetDWork(rts, 1, &ATTN_DW.Analoginput_PWORK);\n      }\n\n      /* registration */\n      sg_IO191_ad_s(rts);\n      sfcnInitializeSizes(rts);\n      sfcnInitializeSampleTimes(rts);\n\n      /* adjust sample time */\n      ssSetSampleTime(rts, 0, 0.001);\n      ssSetOffsetTime(rts, 0, 0.0);\n      sfcnTsMap[0] = 1;\n\n      /* set compiled values of dynamic vector attributes */\n      ssSetNumNonsampledZCsAsInt(rts, 0);\n\n      /* Update connectivity flags for each port */\n      _ssSetOutputPortConnected(rts, 0, 0);\n      _ssSetOutputPortConnected(rts, 1, 1);\n      _ssSetOutputPortBeingMerged(rts, 0, 0);\n      _ssSetOutputPortBeingMerged(rts, 1, 0);\n\n      /* Update the BufferDstPort flags for each input port */\n    }\n\n    /* Level2 S-Function Block: ATTN/<Root>/Analog output  (sg_IO191_da_s) */\n    {\n      SimStruct *rts = ATTN_M->childSfunctions[2];\n\n      /* timing info */\n      time_T *sfcnPeriod = ATTN_M->NonInlinedSFcns.Sfcn2.sfcnPeriod;\n      time_T *sfcnOffset = ATTN_M->NonInlinedSFcns.Sfcn2.sfcnOffset;\n      int_T *sfcnTsMap = ATTN_M->NonInlinedSFcns.Sfcn2.sfcnTsMap;\n      (void) std::memset(static_cast<void*>(sfcnPeriod), 0,\n                         sizeof(time_T)*1);\n      (void) std::memset(static_cast<void*>(sfcnOffset), 0,\n                         sizeof(time_T)*1);\n      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);\n      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);\n      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);\n\n      {\n        ssSetBlkInfo2Ptr(rts, &ATTN_M->NonInlinedSFcns.blkInfo2[2]);\n      }\n\n      _ssSetBlkInfo2PortInfo2Ptr(rts,\n        &ATTN_M->NonInlinedSFcns.inputOutputPortInfo2[2]);\n\n      /* Set up the mdlInfo pointer */\n      ssSetRTWSfcnInfo(rts, ATTN_M->sfcnInfo);\n\n      /* Allocate memory of model methods 2 */\n      {\n        ssSetModelMethods2(rts, &ATTN_M->NonInlinedSFcns.methods2[2]);\n      }\n\n      /* Allocate memory of model methods 3 */\n      {\n        ssSetModelMethods3(rts, &ATTN_M->NonInlinedSFcns.methods3[2]);\n      }\n\n      /* Allocate memory of model methods 4 */\n      {\n        ssSetModelMethods4(rts, &ATTN_M->NonInlinedSFcns.methods4[2]);\n      }\n\n      /* Allocate memory for states auxilliary information */\n      {\n        ssSetStatesInfo2(rts, &ATTN_M->NonInlinedSFcns.statesInfo2[2]);\n        ssSetPeriodicStatesInfo(rts, &ATTN_M->\n          NonInlinedSFcns.periodicStatesInfo[2]);\n      }\n\n      /* inputs */\n      {\n        _ssSetNumInputPorts(rts, 2);\n        ssSetPortInfoForInputs(rts, &ATTN_M->\n          NonInlinedSFcns.Sfcn2.inputPortInfo[0]);\n        ssSetPortInfoForInputs(rts, &ATTN_M->\n          NonInlinedSFcns.Sfcn2.inputPortInfo[0]);\n        _ssSetPortInfo2ForInputUnits(rts,\n          &ATTN_M->NonInlinedSFcns.Sfcn2.inputPortUnits[0]);\n        ssSetInputPortUnit(rts, 0, 0);\n        ssSetInputPortUnit(rts, 1, 0);\n        _ssSetPortInfo2ForInputCoSimAttribute(rts,\n          &ATTN_M->NonInlinedSFcns.Sfcn2.inputPortCoSimAttribute[0]);\n        ssSetInputPortIsContinuousQuantity(rts, 0, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 1, 0);\n\n        /* port 0 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 0, 1);\n          ssSetInputPortSignal(rts, 0, &ATTN_B.sf_MATLABFunction1_d.y);\n          _ssSetInputPortNumDimensions(rts, 0, 1);\n          ssSetInputPortWidthAsInt(rts, 0, 1);\n        }\n\n        /* port 1 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 1, 1);\n          ssSetInputPortSignal(rts, 1, &ATTN_B.sf_MATLABFunction2.y);\n          _ssSetInputPortNumDimensions(rts, 1, 1);\n          ssSetInputPortWidthAsInt(rts, 1, 1);\n        }\n      }\n\n      /* path info */\n      ssSetModelName(rts, \"Analog output \");\n      ssSetPath(rts, \"ATTN/Analog output \");\n      ssSetRTModel(rts,ATTN_M);\n      ssSetParentSS(rts, (NULL));\n      ssSetRootSS(rts, rts);\n      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);\n\n      /* parameters */\n      {\n        mxArray **sfcnParams = (mxArray **)\n          &ATTN_M->NonInlinedSFcns.Sfcn2.params;\n        ssSetSFcnParamsCount(rts, 7);\n        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);\n        ssSetSFcnParam(rts, 0, (mxArray*)ATTN_cal->Analogoutput_P1_Size);\n        ssSetSFcnParam(rts, 1, (mxArray*)ATTN_cal->Analogoutput_P2_Size);\n        ssSetSFcnParam(rts, 2, (mxArray*)ATTN_cal->Analogoutput_P3_Size);\n        ssSetSFcnParam(rts, 3, (mxArray*)ATTN_cal->Analogoutput_P4_Size);\n        ssSetSFcnParam(rts, 4, (mxArray*)ATTN_cal->Analogoutput_P5_Size);\n        ssSetSFcnParam(rts, 5, (mxArray*)ATTN_cal->Analogoutput_P6_Size);\n        ssSetSFcnParam(rts, 6, (mxArray*)ATTN_cal->Analogoutput_P7_Size);\n      }\n\n      /* work vectors */\n      ssSetPWork(rts, (void **) &ATTN_DW.Analogoutput_PWORK);\n\n      {\n        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)\n          &ATTN_M->NonInlinedSFcns.Sfcn2.dWork;\n        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)\n          &ATTN_M->NonInlinedSFcns.Sfcn2.dWorkAux;\n        ssSetSFcnDWork(rts, dWorkRecord);\n        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);\n        ssSetNumDWorkAsInt(rts, 1);\n\n        /* PWORK */\n        ssSetDWorkWidthAsInt(rts, 0, 1);\n        ssSetDWorkDataType(rts, 0,SS_POINTER);\n        ssSetDWorkComplexSignal(rts, 0, 0);\n        ssSetDWork(rts, 0, &ATTN_DW.Analogoutput_PWORK);\n      }\n\n      /* registration */\n      sg_IO191_da_s(rts);\n      sfcnInitializeSizes(rts);\n      sfcnInitializeSampleTimes(rts);\n\n      /* adjust sample time */\n      ssSetSampleTime(rts, 0, 0.001);\n      ssSetOffsetTime(rts, 0, 0.0);\n      sfcnTsMap[0] = 1;\n\n      /* set compiled values of dynamic vector attributes */\n      ssSetNumNonsampledZCsAsInt(rts, 0);\n\n      /* Update connectivity flags for each port */\n      _ssSetInputPortConnected(rts, 0, 1);\n      _ssSetInputPortConnected(rts, 1, 1);\n\n      /* Update the BufferDstPort flags for each input port */\n      ssSetInputPortBufferDstPort(rts, 0, -1);\n      ssSetInputPortBufferDstPort(rts, 1, -1);\n    }\n\n    /* Level2 S-Function Block: ATTN/<Root>/Digital output  (sg_IO191_do_s) */\n    {\n      SimStruct *rts = ATTN_M->childSfunctions[3];\n\n      /* timing info */\n      time_T *sfcnPeriod = ATTN_M->NonInlinedSFcns.Sfcn3.sfcnPeriod;\n      time_T *sfcnOffset = ATTN_M->NonInlinedSFcns.Sfcn3.sfcnOffset;\n      int_T *sfcnTsMap = ATTN_M->NonInlinedSFcns.Sfcn3.sfcnTsMap;\n      (void) std::memset(static_cast<void*>(sfcnPeriod), 0,\n                         sizeof(time_T)*1);\n      (void) std::memset(static_cast<void*>(sfcnOffset), 0,\n                         sizeof(time_T)*1);\n      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);\n      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);\n      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);\n\n      {\n        ssSetBlkInfo2Ptr(rts, &ATTN_M->NonInlinedSFcns.blkInfo2[3]);\n      }\n\n      _ssSetBlkInfo2PortInfo2Ptr(rts,\n        &ATTN_M->NonInlinedSFcns.inputOutputPortInfo2[3]);\n\n      /* Set up the mdlInfo pointer */\n      ssSetRTWSfcnInfo(rts, ATTN_M->sfcnInfo);\n\n      /* Allocate memory of model methods 2 */\n      {\n        ssSetModelMethods2(rts, &ATTN_M->NonInlinedSFcns.methods2[3]);\n      }\n\n      /* Allocate memory of model methods 3 */\n      {\n        ssSetModelMethods3(rts, &ATTN_M->NonInlinedSFcns.methods3[3]);\n      }\n\n      /* Allocate memory of model methods 4 */\n      {\n        ssSetModelMethods4(rts, &ATTN_M->NonInlinedSFcns.methods4[3]);\n      }\n\n      /* Allocate memory for states auxilliary information */\n      {\n        ssSetStatesInfo2(rts, &ATTN_M->NonInlinedSFcns.statesInfo2[3]);\n        ssSetPeriodicStatesInfo(rts, &ATTN_M->\n          NonInlinedSFcns.periodicStatesInfo[3]);\n      }\n\n      /* inputs */\n      {\n        _ssSetNumInputPorts(rts, 15);\n        ssSetPortInfoForInputs(rts, &ATTN_M->\n          NonInlinedSFcns.Sfcn3.inputPortInfo[0]);\n        ssSetPortInfoForInputs(rts, &ATTN_M->\n          NonInlinedSFcns.Sfcn3.inputPortInfo[0]);\n        _ssSetPortInfo2ForInputUnits(rts,\n          &ATTN_M->NonInlinedSFcns.Sfcn3.inputPortUnits[0]);\n        ssSetInputPortUnit(rts, 0, 0);\n        ssSetInputPortUnit(rts, 1, 0);\n        ssSetInputPortUnit(rts, 2, 0);\n        ssSetInputPortUnit(rts, 3, 0);\n        ssSetInputPortUnit(rts, 4, 0);\n        ssSetInputPortUnit(rts, 5, 0);\n        ssSetInputPortUnit(rts, 6, 0);\n        ssSetInputPortUnit(rts, 7, 0);\n        ssSetInputPortUnit(rts, 8, 0);\n        ssSetInputPortUnit(rts, 9, 0);\n        ssSetInputPortUnit(rts, 10, 0);\n        ssSetInputPortUnit(rts, 11, 0);\n        ssSetInputPortUnit(rts, 12, 0);\n        ssSetInputPortUnit(rts, 13, 0);\n        ssSetInputPortUnit(rts, 14, 0);\n        _ssSetPortInfo2ForInputCoSimAttribute(rts,\n          &ATTN_M->NonInlinedSFcns.Sfcn3.inputPortCoSimAttribute[0]);\n        ssSetInputPortIsContinuousQuantity(rts, 0, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 1, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 2, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 3, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 4, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 5, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 6, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 7, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 8, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 9, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 10, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 11, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 12, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 13, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 14, 0);\n\n        /* port 0 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 0, 1);\n          ssSetInputPortSignal(rts, 0, &ATTN_B.whiskCam_trig);\n          _ssSetInputPortNumDimensions(rts, 0, 1);\n          ssSetInputPortWidthAsInt(rts, 0, 1);\n        }\n\n        /* port 1 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 1, 1);\n          ssSetInputPortSignal(rts, 1, &ATTN_B.npxls_trig);\n          _ssSetInputPortNumDimensions(rts, 1, 1);\n          ssSetInputPortWidthAsInt(rts, 1, 1);\n        }\n\n        /* port 2 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 2, 1);\n          ssSetInputPortSignal(rts, 2, &ATTN_B.pupilCam_trig);\n          _ssSetInputPortNumDimensions(rts, 2, 1);\n          ssSetInputPortWidthAsInt(rts, 2, 1);\n        }\n\n        /* port 3 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 3, 1);\n          ssSetInputPortSignal(rts, 3, &ATTN_B.npxlsAcq_out);\n          _ssSetInputPortNumDimensions(rts, 3, 1);\n          ssSetInputPortWidthAsInt(rts, 3, 1);\n        }\n\n        /* port 4 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 4, 1);\n          ssSetInputPortSignal(rts, 4, &ATTN_B.y);\n          _ssSetInputPortNumDimensions(rts, 4, 1);\n          ssSetInputPortWidthAsInt(rts, 4, 1);\n        }\n\n        /* port 5 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 5, 1);\n          ssSetInputPortSignal(rts, 5, (const_cast<real_T*>(&ATTN_RGND)));\n          _ssSetInputPortNumDimensions(rts, 5, 1);\n          ssSetInputPortWidthAsInt(rts, 5, 1);\n        }\n\n        /* port 6 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 6, 1);\n          ssSetInputPortSignal(rts, 6, (const_cast<real_T*>(&ATTN_RGND)));\n          _ssSetInputPortNumDimensions(rts, 6, 1);\n          ssSetInputPortWidthAsInt(rts, 6, 1);\n        }\n\n        /* port 7 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 7, 1);\n          ssSetInputPortSignal(rts, 7, (const_cast<real_T*>(&ATTN_RGND)));\n          _ssSetInputPortNumDimensions(rts, 7, 1);\n          ssSetInputPortWidthAsInt(rts, 7, 1);\n        }\n\n        /* port 8 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 8, 1);\n          ssSetInputPortSignal(rts, 8, (const_cast<real_T*>(&ATTN_RGND)));\n          _ssSetInputPortNumDimensions(rts, 8, 1);\n          ssSetInputPortWidthAsInt(rts, 8, 1);\n        }\n\n        /* port 9 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 9, 1);\n          ssSetInputPortSignal(rts, 9, (const_cast<real_T*>(&ATTN_RGND)));\n          _ssSetInputPortNumDimensions(rts, 9, 1);\n          ssSetInputPortWidthAsInt(rts, 9, 1);\n        }\n\n        /* port 10 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 10, 1);\n          ssSetInputPortSignal(rts, 10, (const_cast<real_T*>(&ATTN_RGND)));\n          _ssSetInputPortNumDimensions(rts, 10, 1);\n          ssSetInputPortWidthAsInt(rts, 10, 1);\n        }\n\n        /* port 11 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 11, 1);\n          ssSetInputPortSignal(rts, 11, (const_cast<real_T*>(&ATTN_RGND)));\n          _ssSetInputPortNumDimensions(rts, 11, 1);\n          ssSetInputPortWidthAsInt(rts, 11, 1);\n        }\n\n        /* port 12 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 12, 1);\n          ssSetInputPortSignal(rts, 12, (const_cast<real_T*>(&ATTN_RGND)));\n          _ssSetInputPortNumDimensions(rts, 12, 1);\n          ssSetInputPortWidthAsInt(rts, 12, 1);\n        }\n\n        /* port 13 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 13, 1);\n          ssSetInputPortSignal(rts, 13, (const_cast<real_T*>(&ATTN_RGND)));\n          _ssSetInputPortNumDimensions(rts, 13, 1);\n          ssSetInputPortWidthAsInt(rts, 13, 1);\n        }\n\n        /* port 14 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 14, 1);\n          ssSetInputPortSignal(rts, 14, &ATTN_B.tonePulse);\n          _ssSetInputPortNumDimensions(rts, 14, 1);\n          ssSetInputPortWidthAsInt(rts, 14, 1);\n        }\n      }\n\n      /* path info */\n      ssSetModelName(rts, \"Digital output \");\n      ssSetPath(rts, \"ATTN/Digital output \");\n      ssSetRTModel(rts,ATTN_M);\n      ssSetParentSS(rts, (NULL));\n      ssSetRootSS(rts, rts);\n      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);\n\n      /* parameters */\n      {\n        mxArray **sfcnParams = (mxArray **)\n          &ATTN_M->NonInlinedSFcns.Sfcn3.params;\n        ssSetSFcnParamsCount(rts, 6);\n        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);\n        ssSetSFcnParam(rts, 0, (mxArray*)ATTN_cal->Digitaloutput_P1_Size);\n        ssSetSFcnParam(rts, 1, (mxArray*)ATTN_cal->Digitaloutput_P2_Size);\n        ssSetSFcnParam(rts, 2, (mxArray*)ATTN_cal->Digitaloutput_P3_Size);\n        ssSetSFcnParam(rts, 3, (mxArray*)ATTN_cal->Digitaloutput_P4_Size);\n        ssSetSFcnParam(rts, 4, (mxArray*)ATTN_cal->Digitaloutput_P5_Size);\n        ssSetSFcnParam(rts, 5, (mxArray*)ATTN_cal->Digitaloutput_P6_Size);\n      }\n\n      /* work vectors */\n      ssSetPWork(rts, (void **) &ATTN_DW.Digitaloutput_PWORK);\n\n      {\n        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)\n          &ATTN_M->NonInlinedSFcns.Sfcn3.dWork;\n        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)\n          &ATTN_M->NonInlinedSFcns.Sfcn3.dWorkAux;\n        ssSetSFcnDWork(rts, dWorkRecord);\n        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);\n        ssSetNumDWorkAsInt(rts, 1);\n\n        /* PWORK */\n        ssSetDWorkWidthAsInt(rts, 0, 1);\n        ssSetDWorkDataType(rts, 0,SS_POINTER);\n        ssSetDWorkComplexSignal(rts, 0, 0);\n        ssSetDWork(rts, 0, &ATTN_DW.Digitaloutput_PWORK);\n      }\n\n      /* registration */\n      sg_IO191_do_s(rts);\n      sfcnInitializeSizes(rts);\n      sfcnInitializeSampleTimes(rts);\n\n      /* adjust sample time */\n      ssSetSampleTime(rts, 0, 0.001);\n      ssSetOffsetTime(rts, 0, 0.0);\n      sfcnTsMap[0] = 1;\n\n      /* set compiled values of dynamic vector attributes */\n      ssSetNumNonsampledZCsAsInt(rts, 0);\n\n      /* Update connectivity flags for each port */\n      _ssSetInputPortConnected(rts, 0, 1);\n      _ssSetInputPortConnected(rts, 1, 1);\n      _ssSetInputPortConnected(rts, 2, 1);\n      _ssSetInputPortConnected(rts, 3, 1);\n      _ssSetInputPortConnected(rts, 4, 1);\n      _ssSetInputPortConnected(rts, 5, 0);\n      _ssSetInputPortConnected(rts, 6, 0);\n      _ssSetInputPortConnected(rts, 7, 0);\n      _ssSetInputPortConnected(rts, 8, 0);\n      _ssSetInputPortConnected(rts, 9, 0);\n      _ssSetInputPortConnected(rts, 10, 0);\n      _ssSetInputPortConnected(rts, 11, 0);\n      _ssSetInputPortConnected(rts, 12, 0);\n      _ssSetInputPortConnected(rts, 13, 0);\n      _ssSetInputPortConnected(rts, 14, 1);\n\n      /* Update the BufferDstPort flags for each input port */\n      ssSetInputPortBufferDstPort(rts, 0, -1);\n      ssSetInputPortBufferDstPort(rts, 1, -1);\n      ssSetInputPortBufferDstPort(rts, 2, -1);\n      ssSetInputPortBufferDstPort(rts, 3, -1);\n      ssSetInputPortBufferDstPort(rts, 4, -1);\n      ssSetInputPortBufferDstPort(rts, 5, -1);\n      ssSetInputPortBufferDstPort(rts, 6, -1);\n      ssSetInputPortBufferDstPort(rts, 7, -1);\n      ssSetInputPortBufferDstPort(rts, 8, -1);\n      ssSetInputPortBufferDstPort(rts, 9, -1);\n      ssSetInputPortBufferDstPort(rts, 10, -1);\n      ssSetInputPortBufferDstPort(rts, 11, -1);\n      ssSetInputPortBufferDstPort(rts, 12, -1);\n      ssSetInputPortBufferDstPort(rts, 13, -1);\n      ssSetInputPortBufferDstPort(rts, 14, -1);\n    }\n\n    /* Level2 S-Function Block: ATTN/<Root>/Digital input  (sg_IO191_di_s) */\n    {\n      SimStruct *rts = ATTN_M->childSfunctions[4];\n\n      /* timing info */\n      time_T *sfcnPeriod = ATTN_M->NonInlinedSFcns.Sfcn4.sfcnPeriod;\n      time_T *sfcnOffset = ATTN_M->NonInlinedSFcns.Sfcn4.sfcnOffset;\n      int_T *sfcnTsMap = ATTN_M->NonInlinedSFcns.Sfcn4.sfcnTsMap;\n      (void) std::memset(static_cast<void*>(sfcnPeriod), 0,\n                         sizeof(time_T)*1);\n      (void) std::memset(static_cast<void*>(sfcnOffset), 0,\n                         sizeof(time_T)*1);\n      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);\n      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);\n      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);\n\n      {\n        ssSetBlkInfo2Ptr(rts, &ATTN_M->NonInlinedSFcns.blkInfo2[4]);\n      }\n\n      _ssSetBlkInfo2PortInfo2Ptr(rts,\n        &ATTN_M->NonInlinedSFcns.inputOutputPortInfo2[4]);\n\n      /* Set up the mdlInfo pointer */\n      ssSetRTWSfcnInfo(rts, ATTN_M->sfcnInfo);\n\n      /* Allocate memory of model methods 2 */\n      {\n        ssSetModelMethods2(rts, &ATTN_M->NonInlinedSFcns.methods2[4]);\n      }\n\n      /* Allocate memory of model methods 3 */\n      {\n        ssSetModelMethods3(rts, &ATTN_M->NonInlinedSFcns.methods3[4]);\n      }\n\n      /* Allocate memory of model methods 4 */\n      {\n        ssSetModelMethods4(rts, &ATTN_M->NonInlinedSFcns.methods4[4]);\n      }\n\n      /* Allocate memory for states auxilliary information */\n      {\n        ssSetStatesInfo2(rts, &ATTN_M->NonInlinedSFcns.statesInfo2[4]);\n        ssSetPeriodicStatesInfo(rts, &ATTN_M->\n          NonInlinedSFcns.periodicStatesInfo[4]);\n      }\n\n      /* outputs */\n      {\n        ssSetPortInfoForOutputs(rts,\n          &ATTN_M->NonInlinedSFcns.Sfcn4.outputPortInfo[0]);\n        ssSetPortInfoForOutputs(rts,\n          &ATTN_M->NonInlinedSFcns.Sfcn4.outputPortInfo[0]);\n        _ssSetNumOutputPorts(rts, 1);\n        _ssSetPortInfo2ForOutputUnits(rts,\n          &ATTN_M->NonInlinedSFcns.Sfcn4.outputPortUnits[0]);\n        ssSetOutputPortUnit(rts, 0, 0);\n        _ssSetPortInfo2ForOutputCoSimAttribute(rts,\n          &ATTN_M->NonInlinedSFcns.Sfcn4.outputPortCoSimAttribute[0]);\n        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);\n\n        /* port 0 */\n        {\n          _ssSetOutputPortNumDimensions(rts, 0, 1);\n          ssSetOutputPortWidthAsInt(rts, 0, 1);\n          ssSetOutputPortSignal(rts, 0, ((real_T *) &ATTN_B.PulseGen1Hz));\n        }\n      }\n\n      /* path info */\n      ssSetModelName(rts, \"Digital input \");\n      ssSetPath(rts, \"ATTN/Digital input \");\n      ssSetRTModel(rts,ATTN_M);\n      ssSetParentSS(rts, (NULL));\n      ssSetRootSS(rts, rts);\n      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);\n\n      /* parameters */\n      {\n        mxArray **sfcnParams = (mxArray **)\n          &ATTN_M->NonInlinedSFcns.Sfcn4.params;\n        ssSetSFcnParamsCount(rts, 4);\n        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);\n        ssSetSFcnParam(rts, 0, (mxArray*)ATTN_cal->Digitalinput_P1_Size);\n        ssSetSFcnParam(rts, 1, (mxArray*)ATTN_cal->Digitalinput_P2_Size);\n        ssSetSFcnParam(rts, 2, (mxArray*)ATTN_cal->Digitalinput_P3_Size);\n        ssSetSFcnParam(rts, 3, (mxArray*)ATTN_cal->Digitalinput_P4_Size);\n      }\n\n      /* work vectors */\n      ssSetPWork(rts, (void **) &ATTN_DW.Digitalinput_PWORK);\n\n      {\n        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)\n          &ATTN_M->NonInlinedSFcns.Sfcn4.dWork;\n        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)\n          &ATTN_M->NonInlinedSFcns.Sfcn4.dWorkAux;\n        ssSetSFcnDWork(rts, dWorkRecord);\n        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);\n        ssSetNumDWorkAsInt(rts, 1);\n\n        /* PWORK */\n        ssSetDWorkWidthAsInt(rts, 0, 1);\n        ssSetDWorkDataType(rts, 0,SS_POINTER);\n        ssSetDWorkComplexSignal(rts, 0, 0);\n        ssSetDWork(rts, 0, &ATTN_DW.Digitalinput_PWORK);\n      }\n\n      /* registration */\n      sg_IO191_di_s(rts);\n      sfcnInitializeSizes(rts);\n      sfcnInitializeSampleTimes(rts);\n\n      /* adjust sample time */\n      ssSetSampleTime(rts, 0, 0.001);\n      ssSetOffsetTime(rts, 0, 0.0);\n      sfcnTsMap[0] = 1;\n\n      /* set compiled values of dynamic vector attributes */\n      ssSetNumNonsampledZCsAsInt(rts, 0);\n\n      /* Update connectivity flags for each port */\n      _ssSetOutputPortConnected(rts, 0, 1);\n      _ssSetOutputPortBeingMerged(rts, 0, 0);\n\n      /* Update the BufferDstPort flags for each input port */\n    }\n  }\n\n  /* Start for S-Function (sg_IO191_setup_s): '<Root>/Setup ' */\n  /* Level2 S-Function Block: '<Root>/Setup ' (sg_IO191_setup_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[0];\n    sfcnStart(rts);\n    if (ssGetErrorStatus(rts) != (NULL))\n      return;\n  }\n\n  /* Start for S-Function (sg_IO191_ad_s): '<Root>/Analog input ' */\n  /* Level2 S-Function Block: '<Root>/Analog input ' (sg_IO191_ad_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[1];\n    sfcnStart(rts);\n    if (ssGetErrorStatus(rts) != (NULL))\n      return;\n  }\n\n  /* Start for Constant: '<Root>/trainingStage' */\n  ATTN_B.training_stage = ATTN_cal->trainingStage;\n\n  /* Start for S-Function (sg_IO191_da_s): '<Root>/Analog output ' */\n  /* Level2 S-Function Block: '<Root>/Analog output ' (sg_IO191_da_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[2];\n    sfcnStart(rts);\n    if (ssGetErrorStatus(rts) != (NULL))\n      return;\n  }\n\n  /* Start for S-Function (sg_IO191_do_s): '<Root>/Digital output ' */\n  /* Level2 S-Function Block: '<Root>/Digital output ' (sg_IO191_do_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[3];\n    sfcnStart(rts);\n    if (ssGetErrorStatus(rts) != (NULL))\n      return;\n  }\n\n  /* Start for S-Function (sg_IO191_di_s): '<Root>/Digital input ' */\n  /* Level2 S-Function Block: '<Root>/Digital input ' (sg_IO191_di_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[4];\n    sfcnStart(rts);\n    if (ssGetErrorStatus(rts) != (NULL))\n      return;\n  }\n\n  {\n    static const uint32_T tmp[625] = { 5489U, 1301868182U, 2938499221U,\n      2950281878U, 1875628136U, 751856242U, 944701696U, 2243192071U, 694061057U,\n      219885934U, 2066767472U, 3182869408U, 485472502U, 2336857883U, 1071588843U,\n      3418470598U, 951210697U, 3693558366U, 2923482051U, 1793174584U,\n      2982310801U, 1586906132U, 1951078751U, 1808158765U, 1733897588U,\n      431328322U, 4202539044U, 530658942U, 1714810322U, 3025256284U, 3342585396U,\n      1937033938U, 2640572511U, 1654299090U, 3692403553U, 4233871309U,\n      3497650794U, 862629010U, 2943236032U, 2426458545U, 1603307207U,\n      1133453895U, 3099196360U, 2208657629U, 2747653927U, 931059398U, 761573964U,\n      3157853227U, 785880413U, 730313442U, 124945756U, 2937117055U, 3295982469U,\n      1724353043U, 3021675344U, 3884886417U, 4010150098U, 4056961966U,\n      699635835U, 2681338818U, 1339167484U, 720757518U, 2800161476U, 2376097373U,\n      1532957371U, 3902664099U, 1238982754U, 3725394514U, 3449176889U,\n      3570962471U, 4287636090U, 4087307012U, 3603343627U, 202242161U,\n      2995682783U, 1620962684U, 3704723357U, 371613603U, 2814834333U,\n      2111005706U, 624778151U, 2094172212U, 4284947003U, 1211977835U, 991917094U,\n      1570449747U, 2962370480U, 1259410321U, 170182696U, 146300961U, 2836829791U,\n      619452428U, 2723670296U, 1881399711U, 1161269684U, 1675188680U,\n      4132175277U, 780088327U, 3409462821U, 1036518241U, 1834958505U,\n      3048448173U, 161811569U, 618488316U, 44795092U, 3918322701U, 1924681712U,\n      3239478144U, 383254043U, 4042306580U, 2146983041U, 3992780527U,\n      3518029708U, 3545545436U, 3901231469U, 1896136409U, 2028528556U,\n      2339662006U, 501326714U, 2060962201U, 2502746480U, 561575027U, 581893337U,\n      3393774360U, 1778912547U, 3626131687U, 2175155826U, 319853231U, 986875531U,\n      819755096U, 2915734330U, 2688355739U, 3482074849U, 2736559U, 2296975761U,\n      1029741190U, 2876812646U, 690154749U, 579200347U, 4027461746U, 1285330465U,\n      2701024045U, 4117700889U, 759495121U, 3332270341U, 2313004527U,\n      2277067795U, 4131855432U, 2722057515U, 1264804546U, 3848622725U,\n      2211267957U, 4100593547U, 959123777U, 2130745407U, 3194437393U, 486673947U,\n      1377371204U, 17472727U, 352317554U, 3955548058U, 159652094U, 1232063192U,\n      3835177280U, 49423123U, 3083993636U, 733092U, 2120519771U, 2573409834U,\n      1112952433U, 3239502554U, 761045320U, 1087580692U, 2540165110U, 641058802U,\n      1792435497U, 2261799288U, 1579184083U, 627146892U, 2165744623U,\n      2200142389U, 2167590760U, 2381418376U, 1793358889U, 3081659520U,\n      1663384067U, 2009658756U, 2689600308U, 739136266U, 2304581039U,\n      3529067263U, 591360555U, 525209271U, 3131882996U, 294230224U, 2076220115U,\n      3113580446U, 1245621585U, 1386885462U, 3203270426U, 123512128U, 12350217U,\n      354956375U, 4282398238U, 3356876605U, 3888857667U, 157639694U, 2616064085U,\n      1563068963U, 2762125883U, 4045394511U, 4180452559U, 3294769488U,\n      1684529556U, 1002945951U, 3181438866U, 22506664U, 691783457U, 2685221343U,\n      171579916U, 3878728600U, 2475806724U, 2030324028U, 3331164912U,\n      1708711359U, 1970023127U, 2859691344U, 2588476477U, 2748146879U,\n      136111222U, 2967685492U, 909517429U, 2835297809U, 3206906216U, 3186870716U,\n      341264097U, 2542035121U, 3353277068U, 548223577U, 3170936588U, 1678403446U,\n      297435620U, 2337555430U, 466603495U, 1132321815U, 1208589219U, 696392160U,\n      894244439U, 2562678859U, 470224582U, 3306867480U, 201364898U, 2075966438U,\n      1767227936U, 2929737987U, 3674877796U, 2654196643U, 3692734598U,\n      3528895099U, 2796780123U, 3048728353U, 842329300U, 191554730U, 2922459673U,\n      3489020079U, 3979110629U, 1022523848U, 2202932467U, 3583655201U,\n      3565113719U, 587085778U, 4176046313U, 3013713762U, 950944241U, 396426791U,\n      3784844662U, 3477431613U, 3594592395U, 2782043838U, 3392093507U,\n      3106564952U, 2829419931U, 1358665591U, 2206918825U, 3170783123U, 31522386U,\n      2988194168U, 1782249537U, 1105080928U, 843500134U, 1225290080U,\n      1521001832U, 3605886097U, 2802786495U, 2728923319U, 3996284304U,\n      903417639U, 1171249804U, 1020374987U, 2824535874U, 423621996U, 1988534473U,\n      2493544470U, 1008604435U, 1756003503U, 1488867287U, 1386808992U,\n      732088248U, 1780630732U, 2482101014U, 976561178U, 1543448953U, 2602866064U,\n      2021139923U, 1952599828U, 2360242564U, 2117959962U, 2753061860U,\n      2388623612U, 4138193781U, 2962920654U, 2284970429U, 766920861U,\n      3457264692U, 2879611383U, 815055854U, 2332929068U, 1254853997U,\n      3740375268U, 3799380844U, 4091048725U, 2006331129U, 1982546212U,\n      686850534U, 1907447564U, 2682801776U, 2780821066U, 998290361U, 1342433871U,\n      4195430425U, 607905174U, 3902331779U, 2454067926U, 1708133115U,\n      1170874362U, 2008609376U, 3260320415U, 2211196135U, 433538229U,\n      2728786374U, 2189520818U, 262554063U, 1182318347U, 3710237267U,\n      1221022450U, 715966018U, 2417068910U, 2591870721U, 2870691989U,\n      3418190842U, 4238214053U, 1540704231U, 1575580968U, 2095917976U,\n      4078310857U, 2313532447U, 2110690783U, 4056346629U, 4061784526U,\n      1123218514U, 551538993U, 597148360U, 4120175196U, 3581618160U, 3181170517U,\n      422862282U, 3227524138U, 1713114790U, 662317149U, 1230418732U, 928171837U,\n      1324564878U, 1928816105U, 1786535431U, 2878099422U, 3290185549U,\n      539474248U, 1657512683U, 552370646U, 1671741683U, 3655312128U, 1552739510U,\n      2605208763U, 1441755014U, 181878989U, 3124053868U, 1447103986U,\n      3183906156U, 1728556020U, 3502241336U, 3055466967U, 1013272474U,\n      818402132U, 1715099063U, 2900113506U, 397254517U, 4194863039U, 1009068739U,\n      232864647U, 2540223708U, 2608288560U, 2415367765U, 478404847U, 3455100648U,\n      3182600021U, 2115988978U, 434269567U, 4117179324U, 3461774077U, 887256537U,\n      3545801025U, 286388911U, 3451742129U, 1981164769U, 786667016U, 3310123729U,\n      3097811076U, 2224235657U, 2959658883U, 3370969234U, 2514770915U,\n      3345656436U, 2677010851U, 2206236470U, 271648054U, 2342188545U,\n      4292848611U, 3646533909U, 3754009956U, 3803931226U, 4160647125U,\n      1477814055U, 4043852216U, 1876372354U, 3133294443U, 3871104810U,\n      3177020907U, 2074304428U, 3479393793U, 759562891U, 164128153U, 1839069216U,\n      2114162633U, 3989947309U, 3611054956U, 1333547922U, 835429831U, 494987340U,\n      171987910U, 1252001001U, 370809172U, 3508925425U, 2535703112U, 1276855041U,\n      1922855120U, 835673414U, 3030664304U, 613287117U, 171219893U, 3423096126U,\n      3376881639U, 2287770315U, 1658692645U, 1262815245U, 3957234326U,\n      1168096164U, 2968737525U, 2655813712U, 2132313144U, 3976047964U,\n      326516571U, 353088456U, 3679188938U, 3205649712U, 2654036126U, 1249024881U,\n      880166166U, 691800469U, 2229503665U, 1673458056U, 4032208375U, 1851778863U,\n      2563757330U, 376742205U, 1794655231U, 340247333U, 1505873033U, 396524441U,\n      879666767U, 3335579166U, 3260764261U, 3335999539U, 506221798U, 4214658741U,\n      975887814U, 2080536343U, 3360539560U, 571586418U, 138896374U, 4234352651U,\n      2737620262U, 3928362291U, 1516365296U, 38056726U, 3599462320U, 3585007266U,\n      3850961033U, 471667319U, 1536883193U, 2310166751U, 1861637689U,\n      2530999841U, 4139843801U, 2710569485U, 827578615U, 2012334720U,\n      2907369459U, 3029312804U, 2820112398U, 1965028045U, 35518606U, 2478379033U,\n      643747771U, 1924139484U, 4123405127U, 3811735531U, 3429660832U,\n      3285177704U, 1948416081U, 1311525291U, 1183517742U, 1739192232U,\n      3979815115U, 2567840007U, 4116821529U, 213304419U, 4125718577U,\n      1473064925U, 2442436592U, 1893310111U, 4195361916U, 3747569474U,\n      828465101U, 2991227658U, 750582866U, 1205170309U, 1409813056U, 678418130U,\n      1171531016U, 3821236156U, 354504587U, 4202874632U, 3882511497U,\n      1893248677U, 1903078632U, 26340130U, 2069166240U, 3657122492U, 3725758099U,\n      831344905U, 811453383U, 3447711422U, 2434543565U, 4166886888U, 3358210805U,\n      4142984013U, 2988152326U, 3527824853U, 982082992U, 2809155763U, 190157081U,\n      3340214818U, 2365432395U, 2548636180U, 2894533366U, 3474657421U,\n      2372634704U, 2845748389U, 43024175U, 2774226648U, 1987702864U, 3186502468U,\n      453610222U, 4204736567U, 1392892630U, 2471323686U, 2470534280U,\n      3541393095U, 4269885866U, 3909911300U, 759132955U, 1482612480U, 667715263U,\n      1795580598U, 2337923983U, 3390586366U, 581426223U, 1515718634U, 476374295U,\n      705213300U, 363062054U, 2084697697U, 2407503428U, 2292957699U, 2426213835U,\n      2199989172U, 1987356470U, 4026755612U, 2147252133U, 270400031U,\n      1367820199U, 2369854699U, 2844269403U, 79981964U, 624U };\n\n    /* InitializeConditions for Memory: '<Root>/Memory8' */\n    ATTN_DW.Memory8_PreviousInput = ATTN_cal->Memory8_InitialCondition;\n\n    /* InitializeConditions for Memory: '<Root>/Memory2' */\n    ATTN_DW.Memory2_PreviousInput = ATTN_cal->Memory2_InitialCondition;\n\n    /* InitializeConditions for Memory: '<Root>/Memory1' */\n    ATTN_DW.Memory1_PreviousInput = ATTN_cal->Memory1_InitialCondition;\n\n    /* InitializeConditions for Memory: '<Root>/Memory' */\n    ATTN_DW.Memory_PreviousInput = ATTN_cal->Memory_InitialCondition;\n\n    /* InitializeConditions for DiscreteFilter: '<Root>/Discrete Filter' */\n    ATTN_DW.DiscreteFilter_states = ATTN_cal->DiscreteFilter_InitialStates;\n\n    /* InitializeConditions for Memory: '<Root>/Memory11' */\n    ATTN_DW.Memory11_PreviousInput = ATTN_cal->Memory11_InitialCondition;\n\n    /* InitializeConditions for Memory: '<Root>/Memory7' */\n    ATTN_DW.Memory7_PreviousInput = ATTN_cal->Memory7_InitialCondition;\n\n    /* InitializeConditions for Memory: '<Root>/Memory3' */\n    ATTN_DW.Memory3_PreviousInput = ATTN_cal->Memory3_InitialCondition;\n\n    /* InitializeConditions for Memory: '<Root>/Memory4' */\n    ATTN_DW.Memory4_PreviousInput = ATTN_cal->Memory4_InitialCondition;\n\n    /* InitializeConditions for Memory: '<Root>/Memory9' */\n    ATTN_DW.Memory9_PreviousInput = ATTN_cal->Memory9_InitialCondition;\n\n    /* InitializeConditions for Memory: '<Root>/Memory5' */\n    ATTN_DW.Memory5_PreviousInput = ATTN_cal->Memory5_InitialCondition;\n\n    /* InitializeConditions for Memory: '<Root>/Memory6' */\n    ATTN_DW.Memory6_PreviousInput = ATTN_cal->Memory6_InitialCondition;\n\n    /* InitializeConditions for Memory: '<Root>/Memory10' */\n    ATTN_DW.Memory10_PreviousInput = ATTN_cal->Memory10_InitialCondition;\n\n    /* InitializeConditions for DiscretePulseGenerator: '<Root>/Whisker Trig' */\n    ATTN_DW.clockTickCounter = 0;\n\n    /* InitializeConditions for DiscretePulseGenerator: '<Root>/Npxls Trig' */\n    ATTN_DW.clockTickCounter_n = 0;\n\n    /* InitializeConditions for DiscretePulseGenerator: '<Root>/Pupil Trig' */\n    ATTN_DW.clockTickCounter_c = 0;\n\n    /* SystemInitialize for MATLAB Function: '<Root>/MATLAB Function1' */\n    ATTN_DW.sfEvent_b = ATTN_CALL_EVENT_n;\n    ATTN_DW.is_active_c6_ATTN = 0U;\n\n    /* SystemInitialize for MATLAB Function: '<Root>/MATLAB Function' */\n    std::memcpy(&ATTN_DW.state_k[0], &tmp[0], 625U * sizeof(uint32_T));\n    ATTN_DW.sfEvent_e = ATTN_CALL_EVENT_n;\n    ATTN_DW.is_active_c1_ATTN = 0U;\n    ATTN_DW.method = 7U;\n    ATTN_DW.method_not_empty = true;\n    ATTN_DW.state = 1144108930U;\n    ATTN_DW.state_not_empty = true;\n    ATTN_DW.state_p[0] = 362436069U;\n    ATTN_DW.state_p[1] = 521288629U;\n    ATTN_DW.state_not_empty_k = true;\n    ATTN_DW.state_not_empty_d = true;\n\n    /* SystemInitialize for MATLAB Function: '<S4>/MATLAB Function1' */\n    ATTN_MATLABFunction2_Init(&ATTN_DW.sf_MATLABFunction1_d);\n\n    /* SystemInitialize for MATLAB Function: '<S3>/MATLAB Function2' */\n    ATTN_MATLABFunction2_Init(&ATTN_DW.sf_MATLABFunction2);\n\n    /* SystemInitialize for MATLAB Function: '<S5>/MATLAB Function1' */\n    ATTN_DW.sfEvent_a = ATTN_CALL_EVENT_n;\n    ATTN_DW.t0_not_empty_p = false;\n    ATTN_DW.is_active_c5_ATTN = 0U;\n\n    /* SystemInitialize for MATLAB Function: '<S6>/MATLAB Function1' */\n    ATTN_DW.sfEvent = ATTN_CALL_EVENT_n;\n    ATTN_DW.t0_not_empty = false;\n    ATTN_DW.is_active_c2_ATTN = 0U;\n  }\n}\n\n/* Model terminate function */\nvoid ATTN_terminate(void)\n{\n  /* Terminate for S-Function (sg_IO191_setup_s): '<Root>/Setup ' */\n  /* Level2 S-Function Block: '<Root>/Setup ' (sg_IO191_setup_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[0];\n    sfcnTerminate(rts);\n  }\n\n  /* Terminate for S-Function (sg_IO191_ad_s): '<Root>/Analog input ' */\n  /* Level2 S-Function Block: '<Root>/Analog input ' (sg_IO191_ad_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[1];\n    sfcnTerminate(rts);\n  }\n\n  /* Terminate for S-Function (sg_IO191_da_s): '<Root>/Analog output ' */\n  /* Level2 S-Function Block: '<Root>/Analog output ' (sg_IO191_da_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[2];\n    sfcnTerminate(rts);\n  }\n\n  /* Terminate for S-Function (sg_IO191_do_s): '<Root>/Digital output ' */\n  /* Level2 S-Function Block: '<Root>/Digital output ' (sg_IO191_do_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[3];\n    sfcnTerminate(rts);\n  }\n\n  /* Terminate for S-Function (sg_IO191_di_s): '<Root>/Digital input ' */\n  /* Level2 S-Function Block: '<Root>/Digital input ' (sg_IO191_di_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[4];\n    sfcnTerminate(rts);\n  }\n}\n"},{"name":"ATTN.h","type":"header","group":"model","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * ATTN.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.461\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Nov 30 11:48:11 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_ATTN_h_\n#define RTW_HEADER_ATTN_h_\n#include <logsrv.h>\n#include \"rtwtypes.h\"\n#include \"simstruc.h\"\n#include \"fixedpoint.h\"\n#include \"verify/verifyIntrf.h\"\n#include \"ATTN_types.h\"\n#include <stddef.h>\n#include <cstring>\n#include \"ATTN_cal.h\"\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n/* Macros for accessing real-time model data structure */\n#ifndef rtmGetContTimeOutputInconsistentWithStateAtMajorStepFlag\n#define rtmGetContTimeOutputInconsistentWithStateAtMajorStepFlag(rtm) ((rtm)->CTOutputIncnstWithState)\n#endif\n\n#ifndef rtmSetContTimeOutputInconsistentWithStateAtMajorStepFlag\n#define rtmSetContTimeOutputInconsistentWithStateAtMajorStepFlag(rtm, val) ((rtm)->CTOutputIncnstWithState = (val))\n#endif\n\n#ifndef rtmGetDerivCacheNeedsReset\n#define rtmGetDerivCacheNeedsReset(rtm) ((rtm)->derivCacheNeedsReset)\n#endif\n\n#ifndef rtmSetDerivCacheNeedsReset\n#define rtmSetDerivCacheNeedsReset(rtm, val) ((rtm)->derivCacheNeedsReset = (val))\n#endif\n\n#ifndef rtmGetFinalTime\n#define rtmGetFinalTime(rtm)           ((rtm)->Timing.tFinal)\n#endif\n\n#ifndef rtmGetSampleHitArray\n#define rtmGetSampleHitArray(rtm)      ((rtm)->Timing.sampleHitArray)\n#endif\n\n#ifndef rtmGetStepSize\n#define rtmGetStepSize(rtm)            ((rtm)->Timing.stepSize)\n#endif\n\n#ifndef rtmGetZCCacheNeedsReset\n#define rtmGetZCCacheNeedsReset(rtm)   ((rtm)->zCCacheNeedsReset)\n#endif\n\n#ifndef rtmSetZCCacheNeedsReset\n#define rtmSetZCCacheNeedsReset(rtm, val) ((rtm)->zCCacheNeedsReset = (val))\n#endif\n\n#ifndef rtmGet_TimeOfLastOutput\n#define rtmGet_TimeOfLastOutput(rtm)   ((rtm)->Timing.timeOfLastOutput)\n#endif\n\n#ifndef rtmGetErrorStatus\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\n#endif\n\n#ifndef rtmSetErrorStatus\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\n#endif\n\n#ifndef rtmGetStopRequested\n#define rtmGetStopRequested(rtm)       ((rtm)->Timing.stopRequestedFlag)\n#endif\n\n#ifndef rtmSetStopRequested\n#define rtmSetStopRequested(rtm, val)  ((rtm)->Timing.stopRequestedFlag = (val))\n#endif\n\n#ifndef rtmGetStopRequestedPtr\n#define rtmGetStopRequestedPtr(rtm)    (&((rtm)->Timing.stopRequestedFlag))\n#endif\n\n#ifndef rtmGetT\n#define rtmGetT(rtm)                   (rtmGetTPtr((rtm))[0])\n#endif\n\n#ifndef rtmGetTFinal\n#define rtmGetTFinal(rtm)              ((rtm)->Timing.tFinal)\n#endif\n\n#ifndef rtmGetTPtr\n#define rtmGetTPtr(rtm)                ((rtm)->Timing.t)\n#endif\n\n#ifndef rtmGetTStart\n#define rtmGetTStart(rtm)              ((rtm)->Timing.tStart)\n#endif\n\n#ifndef rtmGetTimeOfLastOutput\n#define rtmGetTimeOfLastOutput(rtm)    ((rtm)->Timing.timeOfLastOutput)\n#endif\n\n/* Block signals for system '<S3>/MATLAB Function2' */\nstruct B_MATLABFunction2_ATTN_T {\n  real_T y;                            /* '<S3>/MATLAB Function2' */\n};\n\n/* Block states (default storage) for system '<S3>/MATLAB Function2' */\nstruct DW_MATLABFunction2_ATTN_T {\n  real_T t0;                           /* '<S3>/MATLAB Function2' */\n  real_T y0;                           /* '<S3>/MATLAB Function2' */\n  int32_T sfEvent;                     /* '<S3>/MATLAB Function2' */\n  uint8_T is_active_c3_ATTN;           /* '<S3>/MATLAB Function2' */\n  boolean_T doneDoubleBufferReInit;    /* '<S3>/MATLAB Function2' */\n  boolean_T t0_not_empty;              /* '<S3>/MATLAB Function2' */\n  boolean_T y0_not_empty;              /* '<S3>/MATLAB Function2' */\n};\n\n/* Block signals (default storage) */\nstruct B_ATTN_T {\n  real_T Memory8;                      /* '<Root>/Memory8' */\n  real_T Memory2;                      /* '<Root>/Memory2' */\n  real_T Memory1;                      /* '<Root>/Memory1' */\n  real_T Memory;                       /* '<Root>/Memory' */\n  real_T Analoginput_o1;               /* '<Root>/Analog input ' */\n  real_T lickometer_piezo;             /* '<Root>/Analog input ' */\n  real_T DiscreteFilter;               /* '<Root>/Discrete Filter' */\n  real_T Memory11;                     /* '<Root>/Memory11' */\n  real_T Memory7;                      /* '<Root>/Memory7' */\n  real_T clock_time;                   /* '<Root>/Clock' */\n  real_T Memory3;                      /* '<Root>/Memory3' */\n  real_T Memory4;                      /* '<Root>/Memory4' */\n  real_T Memory9;                      /* '<Root>/Memory9' */\n  real_T Memory5;                      /* '<Root>/Memory5' */\n  real_T Memory6;                      /* '<Root>/Memory6' */\n  real_T Memory10;                     /* '<Root>/Memory10' */\n  real_T training_stage;               /* '<Root>/trainingStage' */\n  real_T Clock1;                       /* '<S4>/Clock1' */\n  real_T Clock2;                       /* '<S3>/Clock2' */\n  real_T whiskCam_trig;                /* '<Root>/Whisker Trig' */\n  real_T npxls_trig;                   /* '<Root>/Npxls Trig' */\n  real_T pupilCam_trig;                /* '<Root>/Pupil Trig' */\n  real_T Clock1_b;                     /* '<S5>/Clock1' */\n  real_T Clock1_l;                     /* '<S6>/Clock1' */\n  real_T PulseGen1Hz;                  /* '<Root>/Digital input ' */\n  real_T HiddenRateTransitionForToWks_In;\n  /* '<Root>/HiddenRateTransitionForToWks_InsertedFor_TAQSigLogging_InsertedFor_Digital input _at_outport_0_at_inport_0' */\n  real_T tonePulse;                    /* '<S6>/MATLAB Function1' */\n  real_T y;                            /* '<S5>/MATLAB Function1' */\n  real_T Lick;                         /* '<Root>/MATLAB Function1' */\n  real_T y1;                           /* '<Root>/MATLAB Function1' */\n  real_T y2;                           /* '<Root>/MATLAB Function1' */\n  real_T state_out;                    /* '<Root>/MATLAB Function' */\n  real_T localTime_out;                /* '<Root>/MATLAB Function' */\n  real_T trialNum_out;                 /* '<Root>/MATLAB Function' */\n  real_T npxlsAcq_out;                 /* '<Root>/MATLAB Function' */\n  real_T counter_out;                  /* '<Root>/MATLAB Function' */\n  real_T numLicks_out;                 /* '<Root>/MATLAB Function' */\n  real_T reward_trigger_out;           /* '<Root>/MATLAB Function' */\n  real_T right_trigger_out;            /* '<Root>/MATLAB Function' */\n  real_T left_trigger_out;             /* '<Root>/MATLAB Function' */\n  real_T delay_out;                    /* '<Root>/MATLAB Function' */\n  real_T was_target_out;               /* '<Root>/MATLAB Function' */\n  real_T reward_duration_out;          /* '<Root>/MATLAB Function' */\n  real_T stim_duration_out;            /* '<Root>/MATLAB Function' */\n  real_T onsetTone_trig;               /* '<Root>/MATLAB Function' */\n  boolean_T RelationalOperator;        /* '<Root>/Relational Operator' */\n  B_MATLABFunction2_ATTN_T sf_MATLABFunction1_d;/* '<S4>/MATLAB Function1' */\n  B_MATLABFunction2_ATTN_T sf_MATLABFunction2;/* '<S3>/MATLAB Function2' */\n};\n\n/* Block states (default storage) for system '<Root>' */\nstruct DW_ATTN_T {\n  real_T DiscreteFilter_states;        /* '<Root>/Discrete Filter' */\n  real_T Memory8_PreviousInput;        /* '<Root>/Memory8' */\n  real_T Memory2_PreviousInput;        /* '<Root>/Memory2' */\n  real_T Memory1_PreviousInput;        /* '<Root>/Memory1' */\n  real_T Memory_PreviousInput;         /* '<Root>/Memory' */\n  real_T DiscreteFilter_tmp;           /* '<Root>/Discrete Filter' */\n  real_T Memory11_PreviousInput;       /* '<Root>/Memory11' */\n  real_T Memory7_PreviousInput;        /* '<Root>/Memory7' */\n  real_T Memory3_PreviousInput;        /* '<Root>/Memory3' */\n  real_T Memory4_PreviousInput;        /* '<Root>/Memory4' */\n  real_T Memory9_PreviousInput;        /* '<Root>/Memory9' */\n  real_T Memory5_PreviousInput;        /* '<Root>/Memory5' */\n  real_T Memory6_PreviousInput;        /* '<Root>/Memory6' */\n  real_T Memory10_PreviousInput;       /* '<Root>/Memory10' */\n  real_T t0;                           /* '<S6>/MATLAB Function1' */\n  real_T t0_p;                         /* '<S5>/MATLAB Function1' */\n  real_T Setup_RWORK[2];               /* '<Root>/Setup ' */\n  void *Setup_PWORK;                   /* '<Root>/Setup ' */\n  void *Analoginput_PWORK;             /* '<Root>/Analog input ' */\n  void *Analogoutput_PWORK;            /* '<Root>/Analog output ' */\n  void *Digitaloutput_PWORK;           /* '<Root>/Digital output ' */\n  void *Digitalinput_PWORK;            /* '<Root>/Digital input ' */\n  struct {\n    void *LoggedData[5];\n  } Scope_PWORK;                       /* '<Root>/Scope' */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_Digit;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_Rewar;   /* synthesized block */\n\n  struct {\n    void *LoggedData;\n  } reward_scope_PWORK;                /* '<Root>/reward_scope' */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_Pupil;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_Npxls;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_Whisk;   /* synthesized block */\n\n  struct {\n    void *LoggedData;\n  } left_scope_PWORK;                  /* '<Root>/left_scope' */\n\n  struct {\n    void *LoggedData;\n  } right_scope_PWORK;                 /* '<Root>/right_scope' */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MATLA;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_n;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_k;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_h;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_f;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_p;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_o;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_c;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_m;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MA_cm;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_g;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_b;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_train;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_Clock;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_a;   /* synthesized block */\n\n  struct {\n    void *LoggedData;\n  } Scope1_PWORK;                      /* '<Root>/Scope1' */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_Analo;   /* synthesized block */\n\n  int32_T clockTickCounter;            /* '<Root>/Whisker Trig' */\n  int32_T clockTickCounter_n;          /* '<Root>/Npxls Trig' */\n  int32_T clockTickCounter_c;          /* '<Root>/Pupil Trig' */\n  int32_T sfEvent;                     /* '<S6>/MATLAB Function1' */\n  int32_T sfEvent_a;                   /* '<S5>/MATLAB Function1' */\n  int32_T sfEvent_b;                   /* '<Root>/MATLAB Function1' */\n  int32_T sfEvent_e;                   /* '<Root>/MATLAB Function' */\n  uint32_T method;                     /* '<Root>/MATLAB Function' */\n  uint32_T state;                      /* '<Root>/MATLAB Function' */\n  uint32_T state_p[2];                 /* '<Root>/MATLAB Function' */\n  uint32_T state_k[625];               /* '<Root>/MATLAB Function' */\n  int_T Analoginput_IWORK[2];          /* '<Root>/Analog input ' */\n  uint8_T is_active_c2_ATTN;           /* '<S6>/MATLAB Function1' */\n  uint8_T is_active_c5_ATTN;           /* '<S5>/MATLAB Function1' */\n  uint8_T is_active_c6_ATTN;           /* '<Root>/MATLAB Function1' */\n  uint8_T is_active_c1_ATTN;           /* '<Root>/MATLAB Function' */\n  boolean_T doneDoubleBufferReInit;    /* '<S6>/MATLAB Function1' */\n  boolean_T t0_not_empty;              /* '<S6>/MATLAB Function1' */\n  boolean_T doneDoubleBufferReInit_i;  /* '<S5>/MATLAB Function1' */\n  boolean_T t0_not_empty_p;            /* '<S5>/MATLAB Function1' */\n  boolean_T doneDoubleBufferReInit_j;  /* '<Root>/MATLAB Function1' */\n  boolean_T doneDoubleBufferReInit_e;  /* '<Root>/MATLAB Function' */\n  boolean_T method_not_empty;          /* '<Root>/MATLAB Function' */\n  boolean_T state_not_empty;           /* '<Root>/MATLAB Function' */\n  boolean_T state_not_empty_k;         /* '<Root>/MATLAB Function' */\n  boolean_T state_not_empty_d;         /* '<Root>/MATLAB Function' */\n  DW_MATLABFunction2_ATTN_T sf_MATLABFunction1_d;/* '<S4>/MATLAB Function1' */\n  DW_MATLABFunction2_ATTN_T sf_MATLABFunction2;/* '<S3>/MATLAB Function2' */\n};\n\n/* Real-time Model Data Structure */\nstruct tag_RTM_ATTN_T {\n  struct SimStruct_tag * *childSfunctions;\n  const char_T *errorStatus;\n  SS_SimMode simMode;\n  RTWSolverInfo solverInfo;\n  RTWSolverInfo *solverInfoPtr;\n  void *sfcnInfo;\n\n  /*\n   * NonInlinedSFcns:\n   * The following substructure contains information regarding\n   * non-inlined s-functions used in the model.\n   */\n  struct {\n    RTWSfcnInfo sfcnInfo;\n    time_T *taskTimePtrs[2];\n    SimStruct childSFunctions[5];\n    SimStruct *childSFunctionPtrs[5];\n    struct _ssBlkInfo2 blkInfo2[5];\n    struct _ssSFcnModelMethods2 methods2[5];\n    struct _ssSFcnModelMethods3 methods3[5];\n    struct _ssSFcnModelMethods4 methods4[5];\n    struct _ssStatesInfo2 statesInfo2[5];\n    ssPeriodicStatesInfo periodicStatesInfo[5];\n    struct _ssPortInfo2 inputOutputPortInfo2[5];\n    struct {\n      time_T sfcnPeriod[1];\n      time_T sfcnOffset[1];\n      int_T sfcnTsMap[1];\n      uint_T attribs[9];\n      mxArray *params[9];\n      struct _ssDWorkRecord dWork[2];\n      struct _ssDWorkAuxRecord dWorkAux[2];\n    } Sfcn0;\n\n    struct {\n      time_T sfcnPeriod[1];\n      time_T sfcnOffset[1];\n      int_T sfcnTsMap[1];\n      struct _ssPortOutputs outputPortInfo[2];\n      struct _ssOutPortUnit outputPortUnits[2];\n      struct _ssOutPortCoSimAttribute outputPortCoSimAttribute[2];\n      uint_T attribs[9];\n      mxArray *params[9];\n      struct _ssDWorkRecord dWork[2];\n      struct _ssDWorkAuxRecord dWorkAux[2];\n    } Sfcn1;\n\n    struct {\n      time_T sfcnPeriod[1];\n      time_T sfcnOffset[1];\n      int_T sfcnTsMap[1];\n      struct _ssPortInputs inputPortInfo[2];\n      struct _ssInPortUnit inputPortUnits[2];\n      struct _ssInPortCoSimAttribute inputPortCoSimAttribute[2];\n      uint_T attribs[7];\n      mxArray *params[7];\n      struct _ssDWorkRecord dWork[1];\n      struct _ssDWorkAuxRecord dWorkAux[1];\n    } Sfcn2;\n\n    struct {\n      time_T sfcnPeriod[1];\n      time_T sfcnOffset[1];\n      int_T sfcnTsMap[1];\n      struct _ssPortInputs inputPortInfo[15];\n      struct _ssInPortUnit inputPortUnits[15];\n      struct _ssInPortCoSimAttribute inputPortCoSimAttribute[15];\n      uint_T attribs[6];\n      mxArray *params[6];\n      struct _ssDWorkRecord dWork[1];\n      struct _ssDWorkAuxRecord dWorkAux[1];\n    } Sfcn3;\n\n    struct {\n      time_T sfcnPeriod[1];\n      time_T sfcnOffset[1];\n      int_T sfcnTsMap[1];\n      struct _ssPortOutputs outputPortInfo[1];\n      struct _ssOutPortUnit outputPortUnits[1];\n      struct _ssOutPortCoSimAttribute outputPortCoSimAttribute[1];\n      uint_T attribs[4];\n      mxArray *params[4];\n      struct _ssDWorkRecord dWork[1];\n      struct _ssDWorkAuxRecord dWorkAux[1];\n    } Sfcn4;\n  } NonInlinedSFcns;\n\n  boolean_T zCCacheNeedsReset;\n  boolean_T derivCacheNeedsReset;\n  boolean_T CTOutputIncnstWithState;\n\n  /*\n   * Sizes:\n   * The following substructure contains sizes information\n   * for many of the model attributes such as inputs, outputs,\n   * dwork, sample times, etc.\n   */\n  struct {\n    uint32_T options;\n    int_T numContStates;\n    int_T numU;\n    int_T numY;\n    int_T numSampTimes;\n    int_T numBlocks;\n    int_T numBlockIO;\n    int_T numBlockPrms;\n    int_T numDwork;\n    int_T numSFcnPrms;\n    int_T numSFcns;\n    int_T numIports;\n    int_T numOports;\n    int_T numNonSampZCs;\n    int_T sysDirFeedThru;\n    int_T rtwGenSfcn;\n  } Sizes;\n\n  /*\n   * Timing:\n   * The following substructure contains information regarding\n   * the timing information for the model.\n   */\n  struct {\n    time_T stepSize;\n    uint32_T clockTick0;\n    uint32_T clockTickH0;\n    time_T stepSize0;\n    uint32_T clockTick1;\n    uint32_T clockTickH1;\n    time_T stepSize1;\n    time_T tStart;\n    time_T tFinal;\n    time_T timeOfLastOutput;\n    SimTimeStep simTimeStep;\n    boolean_T stopRequestedFlag;\n    time_T *sampleTimes;\n    time_T *offsetTimes;\n    int_T *sampleTimeTaskIDPtr;\n    int_T *sampleHits;\n    int_T *perTaskSampleHits;\n    time_T *t;\n    time_T sampleTimesArray[2];\n    time_T offsetTimesArray[2];\n    int_T sampleTimeTaskIDArray[2];\n    int_T sampleHitArray[2];\n    int_T perTaskSampleHitsArray[4];\n    time_T tArray[2];\n  } Timing;\n};\n\n/* Block signals (default storage) */\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern struct B_ATTN_T ATTN_B;\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n/* Block states (default storage) */\nextern struct DW_ATTN_T ATTN_DW;\n\n/* External data declarations for dependent source files */\nextern const real_T ATTN_RGND;         /* real_T ground */\n\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  /* Model entry point functions */\n  extern void ATTN_initialize(void);\n  extern void ATTN_step(void);\n  extern void ATTN_terminate(void);\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n/* Real-time Model object */\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern RT_MODEL_ATTN_T *const ATTN_M;\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n/*-\n * The generated code includes comments that allow you to trace directly\n * back to the appropriate location in the model.  The basic format\n * is <system>/block_name, where system is the system number (uniquely\n * assigned by Simulink) and block_name is the name of the block.\n *\n * Use the MATLAB hilite_system command to trace the generated code back\n * to the model.  For example,\n *\n * hilite_system('<S3>')    - opens system 3\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\n *\n * Here is the system hierarchy for this model\n *\n * '<Root>' : 'ATTN'\n * '<S1>'   : 'ATTN/MATLAB Function'\n * '<S2>'   : 'ATTN/MATLAB Function1'\n * '<S3>'   : 'ATTN/PiezoDriver_1'\n * '<S4>'   : 'ATTN/PiezoDriver_2'\n * '<S5>'   : 'ATTN/RewardDriver'\n * '<S6>'   : 'ATTN/onsetToneDriver'\n * '<S7>'   : 'ATTN/PiezoDriver_1/MATLAB Function2'\n * '<S8>'   : 'ATTN/PiezoDriver_2/MATLAB Function1'\n * '<S9>'   : 'ATTN/RewardDriver/MATLAB Function1'\n * '<S10>'  : 'ATTN/onsetToneDriver/MATLAB Function1'\n */\n#endif                                 /* RTW_HEADER_ATTN_h_ */\n"},{"name":"ATTN_private.h","type":"header","group":"model","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * ATTN_private.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.461\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Nov 30 11:48:11 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_ATTN_private_h_\n#define RTW_HEADER_ATTN_private_h_\n#include \"rtwtypes.h\"\n#include \"multiword_types.h\"\n#include \"ATTN.h\"\n#include \"ATTN_types.h\"\n\n/* Private macros used by the generated code to access rtModel */\n#ifndef rtmIsMajorTimeStep\n#define rtmIsMajorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MAJOR_TIME_STEP)\n#endif\n\n#ifndef rtmIsMinorTimeStep\n#define rtmIsMinorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MINOR_TIME_STEP)\n#endif\n\n#ifndef rtmSetTFinal\n#define rtmSetTFinal(rtm, val)         ((rtm)->Timing.tFinal = (val))\n#endif\n\n#ifndef rtmSetTPtr\n#define rtmSetTPtr(rtm, val)           ((rtm)->Timing.t = (val))\n#endif\n\nextern void* slrtRegisterSignalToLoggingService(uintptr_t sigAddr);\nextern \"C\" void sg_IO191_setup_s(SimStruct *rts);\nextern \"C\" void sg_IO191_ad_s(SimStruct *rts);\nextern \"C\" void sg_IO191_da_s(SimStruct *rts);\nextern \"C\" void sg_IO191_do_s(SimStruct *rts);\nextern \"C\" void sg_IO191_di_s(SimStruct *rts);\nextern void ATTN_MATLABFunction2_Init(DW_MATLABFunction2_ATTN_T *localDW);\nextern void ATTN_MATLABFunction2(real_T rtu_trigger, real_T rtu_duration, real_T\n  rtu_amp, real_T rtu_t, B_MATLABFunction2_ATTN_T *localB,\n  DW_MATLABFunction2_ATTN_T *localDW);\n\n#endif                                 /* RTW_HEADER_ATTN_private_h_ */\n"},{"name":"ATTN_types.h","type":"header","group":"model","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * ATTN_types.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.461\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Nov 30 11:48:11 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_ATTN_types_h_\n#define RTW_HEADER_ATTN_types_h_\n\n/* Forward declaration for rtModel */\ntypedef struct tag_RTM_ATTN_T RT_MODEL_ATTN_T;\n\n#endif                                 /* RTW_HEADER_ATTN_types_h_ */\n"},{"name":"ATTN_cal.cpp","type":"source","group":"data","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Data files","code":"#include \"ATTN_cal.h\"\n#include \"ATTN.h\"\n\n/* Storage class 'PageSwitching' */\nATTN_cal_type ATTN_cal_impl = {\n  /* Variable: SampleTime\n   * Referenced by: '<Root>/SampleTime'\n   */\n  0.001,\n\n  /* Variable: T_npxls\n   * Referenced by: '<Root>/Npxls Trig'\n   */\n  4.0,\n\n  /* Variable: T_pupil\n   * Referenced by: '<Root>/Pupil Trig'\n   */\n  100.0,\n\n  /* Variable: T_whisk\n   * Referenced by: '<Root>/Whisker Trig'\n   */\n  20.0,\n\n  /* Variable: maxFrame\n   * Referenced by: '<Root>/Constant'\n   */\n  600000.0,\n\n  /* Variable: rewardDuration\n   * Referenced by: '<Root>/rewardDuration'\n   */\n  0.05,\n\n  /* Variable: targetSide\n   * Referenced by: '<Root>/targetSide'\n   */\n  0.0,\n\n  /* Variable: trainingStage\n   * Referenced by: '<Root>/trainingStage'\n   */\n  222.0,\n\n  /* Variable: triangleAmplitude\n   * Referenced by: '<Root>/triangleAmplitude'\n   */\n  10.0,\n\n  /* Variable: triangleDuration\n   * Referenced by: '<Root>/triangleDuration'\n   */\n  0.1,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Memory8'\n   */\n  0.0,\n\n  /* Expression: 1\n   * Referenced by: '<Root>/Memory2'\n   */\n  1.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Memory1'\n   */\n  0.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Memory'\n   */\n  0.0,\n\n  /* Computed Parameter: Setup_P1_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parPciSlot\n   * Referenced by: '<Root>/Setup '\n   */\n  -1.0,\n\n  /* Computed Parameter: Setup_P2_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parModuleId\n   * Referenced by: '<Root>/Setup '\n   */\n  1.0,\n\n  /* Computed Parameter: Setup_P3_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parTriggerSignal\n   * Referenced by: '<Root>/Setup '\n   */\n  1.0,\n\n  /* Computed Parameter: Setup_P4_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parAdcChannels\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 2.0 },\n\n  /* Computed Parameter: Setup_P5_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parAdcMode\n   * Referenced by: '<Root>/Setup '\n   */\n  2.0,\n\n  /* Computed Parameter: Setup_P6_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parAdcRanges\n   * Referenced by: '<Root>/Setup '\n   */\n  { 3.0, 3.0 },\n\n  /* Computed Parameter: Setup_P7_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parDacChannels\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 3.0 },\n\n  /* Computed Parameter: Setup_P8_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parDacRanges\n   * Referenced by: '<Root>/Setup '\n   */\n  { 4.0, 4.0 },\n\n  /* Computed Parameter: Setup_P9_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 8.0 },\n\n  /* Expression: parDioFirstControl\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 8.0, 9.0 },\n\n  /* Computed Parameter: Analoginput_P1_Size\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parModuleId\n   * Referenced by: '<Root>/Analog input '\n   */\n  1.0,\n\n  /* Computed Parameter: Analoginput_P2_Size\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parSampleTime\n   * Referenced by: '<Root>/Analog input '\n   */\n  -1.0,\n\n  /* Computed Parameter: Analoginput_P3_Size\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parPciSlot\n   * Referenced by: '<Root>/Analog input '\n   */\n  -1.0,\n\n  /* Computed Parameter: Analoginput_P4_Size\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parAdcChannels\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 2.0 },\n\n  /* Computed Parameter: Analoginput_P5_Size\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parAdcMode\n   * Referenced by: '<Root>/Analog input '\n   */\n  2.0,\n\n  /* Computed Parameter: Analoginput_P6_Size\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parAdcRate\n   * Referenced by: '<Root>/Analog input '\n   */\n  100000.0,\n\n  /* Computed Parameter: Analoginput_P7_Size\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parAdcRanges\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 3.0, 3.0 },\n\n  /* Computed Parameter: Analoginput_P8_Size\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parAdcInitValues\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 0.0, 0.0 },\n\n  /* Computed Parameter: Analoginput_P9_Size\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parAdcResets\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: [1]\n   * Referenced by: '<Root>/Discrete Filter'\n   */\n  1.0,\n\n  /* Expression: [1 0.004]\n   * Referenced by: '<Root>/Discrete Filter'\n   */\n  { 1.0, 0.004 },\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Discrete Filter'\n   */\n  0.0,\n\n  /* Expression: 0.25\n   * Referenced by: '<Root>/Thrd'\n   */\n  0.25,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Memory11'\n   */\n  0.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Memory7'\n   */\n  0.0,\n\n  /* Expression: 1\n   * Referenced by: '<Root>/Memory3'\n   */\n  1.0,\n\n  /* Expression: 1\n   * Referenced by: '<Root>/Memory4'\n   */\n  1.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Memory9'\n   */\n  0.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Memory5'\n   */\n  0.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Memory6'\n   */\n  0.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Memory10'\n   */\n  0.0,\n\n  /* Computed Parameter: Analogoutput_P1_Size\n   * Referenced by: '<Root>/Analog output '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parModuleId\n   * Referenced by: '<Root>/Analog output '\n   */\n  1.0,\n\n  /* Computed Parameter: Analogoutput_P2_Size\n   * Referenced by: '<Root>/Analog output '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parSampleTime\n   * Referenced by: '<Root>/Analog output '\n   */\n  -1.0,\n\n  /* Computed Parameter: Analogoutput_P3_Size\n   * Referenced by: '<Root>/Analog output '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parPciSlot\n   * Referenced by: '<Root>/Analog output '\n   */\n  -1.0,\n\n  /* Computed Parameter: Analogoutput_P4_Size\n   * Referenced by: '<Root>/Analog output '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parDacChannels\n   * Referenced by: '<Root>/Analog output '\n   */\n  { 1.0, 3.0 },\n\n  /* Computed Parameter: Analogoutput_P5_Size\n   * Referenced by: '<Root>/Analog output '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parDacRanges\n   * Referenced by: '<Root>/Analog output '\n   */\n  { 4.0, 4.0 },\n\n  /* Computed Parameter: Analogoutput_P6_Size\n   * Referenced by: '<Root>/Analog output '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parDacInitValues\n   * Referenced by: '<Root>/Analog output '\n   */\n  { 0.0, 0.0 },\n\n  /* Computed Parameter: Analogoutput_P7_Size\n   * Referenced by: '<Root>/Analog output '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parDacResets\n   * Referenced by: '<Root>/Analog output '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: 1\n   * Referenced by: '<Root>/Whisker Trig'\n   */\n  1.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Whisker Trig'\n   */\n  0.0,\n\n  /* Expression: 2.5\n   * Referenced by: '<Root>/Npxls Trig'\n   */\n  2.5,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Npxls Trig'\n   */\n  0.0,\n\n  /* Expression: 1\n   * Referenced by: '<Root>/Pupil Trig'\n   */\n  1.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Pupil Trig'\n   */\n  0.0,\n\n  /* Expression: 1\n   * Referenced by: '<S5>/Constant4'\n   */\n  1.0,\n\n  /* Computed Parameter: Digitaloutput_P1_Size\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parModuleId\n   * Referenced by: '<Root>/Digital output '\n   */\n  1.0,\n\n  /* Computed Parameter: Digitaloutput_P2_Size\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parSampleTime\n   * Referenced by: '<Root>/Digital output '\n   */\n  0.001,\n\n  /* Computed Parameter: Digitaloutput_P3_Size\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parPciSlot\n   * Referenced by: '<Root>/Digital output '\n   */\n  -1.0,\n\n  /* Computed Parameter: Digitaloutput_P4_Size\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 15.0 },\n\n  /* Expression: parDoChannels\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 15.0,\n    16.0 },\n\n  /* Computed Parameter: Digitaloutput_P5_Size\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 15.0 },\n\n  /* Expression: parDoInitValues\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },\n\n  /* Computed Parameter: Digitaloutput_P6_Size\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 15.0 },\n\n  /* Expression: parDoResets\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },\n\n  /* Computed Parameter: Digitalinput_P1_Size\n   * Referenced by: '<Root>/Digital input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parModuleId\n   * Referenced by: '<Root>/Digital input '\n   */\n  1.0,\n\n  /* Computed Parameter: Digitalinput_P2_Size\n   * Referenced by: '<Root>/Digital input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parSampleTime\n   * Referenced by: '<Root>/Digital input '\n   */\n  0.001,\n\n  /* Computed Parameter: Digitalinput_P3_Size\n   * Referenced by: '<Root>/Digital input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parPciSlot\n   * Referenced by: '<Root>/Digital input '\n   */\n  -1.0,\n\n  /* Computed Parameter: Digitalinput_P4_Size\n   * Referenced by: '<Root>/Digital input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parDiChannels\n   * Referenced by: '<Root>/Digital input '\n   */\n  14.0\n};\n\nATTN_cal_type *ATTN_cal = &ATTN_cal_impl;\n"},{"name":"ATTN_cal.h","type":"header","group":"data","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Data files","code":"#ifndef RTW_HEADER_ATTN_cal_h_\n#define RTW_HEADER_ATTN_cal_h_\n#include \"rtwtypes.h\"\n\n/* Storage class 'PageSwitching', for system '<Root>' */\nstruct ATTN_cal_type {\n  real_T SampleTime;                   /* Variable: SampleTime\n                                        * Referenced by: '<Root>/SampleTime'\n                                        */\n  real_T T_npxls;                      /* Variable: T_npxls\n                                        * Referenced by: '<Root>/Npxls Trig'\n                                        */\n  real_T T_pupil;                      /* Variable: T_pupil\n                                        * Referenced by: '<Root>/Pupil Trig'\n                                        */\n  real_T T_whisk;                      /* Variable: T_whisk\n                                        * Referenced by: '<Root>/Whisker Trig'\n                                        */\n  real_T maxFrame;                     /* Variable: maxFrame\n                                        * Referenced by: '<Root>/Constant'\n                                        */\n  real_T rewardDuration;               /* Variable: rewardDuration\n                                        * Referenced by: '<Root>/rewardDuration'\n                                        */\n  real_T targetSide;                   /* Variable: targetSide\n                                        * Referenced by: '<Root>/targetSide'\n                                        */\n  real_T trainingStage;                /* Variable: trainingStage\n                                        * Referenced by: '<Root>/trainingStage'\n                                        */\n  real_T triangleAmplitude;            /* Variable: triangleAmplitude\n                                        * Referenced by: '<Root>/triangleAmplitude'\n                                        */\n  real_T triangleDuration;             /* Variable: triangleDuration\n                                        * Referenced by: '<Root>/triangleDuration'\n                                        */\n  real_T Memory8_InitialCondition;     /* Expression: 0\n                                        * Referenced by: '<Root>/Memory8'\n                                        */\n  real_T Memory2_InitialCondition;     /* Expression: 1\n                                        * Referenced by: '<Root>/Memory2'\n                                        */\n  real_T Memory1_InitialCondition;     /* Expression: 0\n                                        * Referenced by: '<Root>/Memory1'\n                                        */\n  real_T Memory_InitialCondition;      /* Expression: 0\n                                        * Referenced by: '<Root>/Memory'\n                                        */\n  real_T Setup_P1_Size[2];             /* Computed Parameter: Setup_P1_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P1;                     /* Expression: parPciSlot\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P2_Size[2];             /* Computed Parameter: Setup_P2_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P2;                     /* Expression: parModuleId\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P3_Size[2];             /* Computed Parameter: Setup_P3_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P3;                     /* Expression: parTriggerSignal\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P4_Size[2];             /* Computed Parameter: Setup_P4_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P4[2];                  /* Expression: parAdcChannels\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P5_Size[2];             /* Computed Parameter: Setup_P5_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P5;                     /* Expression: parAdcMode\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P6_Size[2];             /* Computed Parameter: Setup_P6_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P6[2];                  /* Expression: parAdcRanges\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P7_Size[2];             /* Computed Parameter: Setup_P7_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P7[2];                  /* Expression: parDacChannels\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P8_Size[2];             /* Computed Parameter: Setup_P8_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P8[2];                  /* Expression: parDacRanges\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P9_Size[2];             /* Computed Parameter: Setup_P9_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P9[8];                  /* Expression: parDioFirstControl\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Analoginput_P1_Size[2];      /* Computed Parameter: Analoginput_P1_Size\n                                       * Referenced by: '<Root>/Analog input '\n                                       */\n  real_T Analoginput_P1;               /* Expression: parModuleId\n                                        * Referenced by: '<Root>/Analog input '\n                                        */\n  real_T Analoginput_P2_Size[2];      /* Computed Parameter: Analoginput_P2_Size\n                                       * Referenced by: '<Root>/Analog input '\n                                       */\n  real_T Analoginput_P2;               /* Expression: parSampleTime\n                                        * Referenced by: '<Root>/Analog input '\n                                        */\n  real_T Analoginput_P3_Size[2];      /* Computed Parameter: Analoginput_P3_Size\n                                       * Referenced by: '<Root>/Analog input '\n                                       */\n  real_T Analoginput_P3;               /* Expression: parPciSlot\n                                        * Referenced by: '<Root>/Analog input '\n                                        */\n  real_T Analoginput_P4_Size[2];      /* Computed Parameter: Analoginput_P4_Size\n                                       * Referenced by: '<Root>/Analog input '\n                                       */\n  real_T Analoginput_P4[2];            /* Expression: parAdcChannels\n                                        * Referenced by: '<Root>/Analog input '\n                                        */\n  real_T Analoginput_P5_Size[2];      /* Computed Parameter: Analoginput_P5_Size\n                                       * Referenced by: '<Root>/Analog input '\n                                       */\n  real_T Analoginput_P5;               /* Expression: parAdcMode\n                                        * Referenced by: '<Root>/Analog input '\n                                        */\n  real_T Analoginput_P6_Size[2];      /* Computed Parameter: Analoginput_P6_Size\n                                       * Referenced by: '<Root>/Analog input '\n                                       */\n  real_T Analoginput_P6;               /* Expression: parAdcRate\n                                        * Referenced by: '<Root>/Analog input '\n                                        */\n  real_T Analoginput_P7_Size[2];      /* Computed Parameter: Analoginput_P7_Size\n                                       * Referenced by: '<Root>/Analog input '\n                                       */\n  real_T Analoginput_P7[2];            /* Expression: parAdcRanges\n                                        * Referenced by: '<Root>/Analog input '\n                                        */\n  real_T Analoginput_P8_Size[2];      /* Computed Parameter: Analoginput_P8_Size\n                                       * Referenced by: '<Root>/Analog input '\n                                       */\n  real_T Analoginput_P8[2];            /* Expression: parAdcInitValues\n                                        * Referenced by: '<Root>/Analog input '\n                                        */\n  real_T Analoginput_P9_Size[2];      /* Computed Parameter: Analoginput_P9_Size\n                                       * Referenced by: '<Root>/Analog input '\n                                       */\n  real_T Analoginput_P9[2];            /* Expression: parAdcResets\n                                        * Referenced by: '<Root>/Analog input '\n                                        */\n  real_T DiscreteFilter_NumCoef;       /* Expression: [1]\n                                        * Referenced by: '<Root>/Discrete Filter'\n                                        */\n  real_T DiscreteFilter_DenCoef[2];    /* Expression: [1 0.004]\n                                        * Referenced by: '<Root>/Discrete Filter'\n                                        */\n  real_T DiscreteFilter_InitialStates; /* Expression: 0\n                                        * Referenced by: '<Root>/Discrete Filter'\n                                        */\n  real_T Thrd_Value;                   /* Expression: 0.25\n                                        * Referenced by: '<Root>/Thrd'\n                                        */\n  real_T Memory11_InitialCondition;    /* Expression: 0\n                                        * Referenced by: '<Root>/Memory11'\n                                        */\n  real_T Memory7_InitialCondition;     /* Expression: 0\n                                        * Referenced by: '<Root>/Memory7'\n                                        */\n  real_T Memory3_InitialCondition;     /* Expression: 1\n                                        * Referenced by: '<Root>/Memory3'\n                                        */\n  real_T Memory4_InitialCondition;     /* Expression: 1\n                                        * Referenced by: '<Root>/Memory4'\n                                        */\n  real_T Memory9_InitialCondition;     /* Expression: 0\n                                        * Referenced by: '<Root>/Memory9'\n                                        */\n  real_T Memory5_InitialCondition;     /* Expression: 0\n                                        * Referenced by: '<Root>/Memory5'\n                                        */\n  real_T Memory6_InitialCondition;     /* Expression: 0\n                                        * Referenced by: '<Root>/Memory6'\n                                        */\n  real_T Memory10_InitialCondition;    /* Expression: 0\n                                        * Referenced by: '<Root>/Memory10'\n                                        */\n  real_T Analogoutput_P1_Size[2];    /* Computed Parameter: Analogoutput_P1_Size\n                                      * Referenced by: '<Root>/Analog output '\n                                      */\n  real_T Analogoutput_P1;              /* Expression: parModuleId\n                                        * Referenced by: '<Root>/Analog output '\n                                        */\n  real_T Analogoutput_P2_Size[2];    /* Computed Parameter: Analogoutput_P2_Size\n                                      * Referenced by: '<Root>/Analog output '\n                                      */\n  real_T Analogoutput_P2;              /* Expression: parSampleTime\n                                        * Referenced by: '<Root>/Analog output '\n                                        */\n  real_T Analogoutput_P3_Size[2];    /* Computed Parameter: Analogoutput_P3_Size\n                                      * Referenced by: '<Root>/Analog output '\n                                      */\n  real_T Analogoutput_P3;              /* Expression: parPciSlot\n                                        * Referenced by: '<Root>/Analog output '\n                                        */\n  real_T Analogoutput_P4_Size[2];    /* Computed Parameter: Analogoutput_P4_Size\n                                      * Referenced by: '<Root>/Analog output '\n                                      */\n  real_T Analogoutput_P4[2];           /* Expression: parDacChannels\n                                        * Referenced by: '<Root>/Analog output '\n                                        */\n  real_T Analogoutput_P5_Size[2];    /* Computed Parameter: Analogoutput_P5_Size\n                                      * Referenced by: '<Root>/Analog output '\n                                      */\n  real_T Analogoutput_P5[2];           /* Expression: parDacRanges\n                                        * Referenced by: '<Root>/Analog output '\n                                        */\n  real_T Analogoutput_P6_Size[2];    /* Computed Parameter: Analogoutput_P6_Size\n                                      * Referenced by: '<Root>/Analog output '\n                                      */\n  real_T Analogoutput_P6[2];           /* Expression: parDacInitValues\n                                        * Referenced by: '<Root>/Analog output '\n                                        */\n  real_T Analogoutput_P7_Size[2];    /* Computed Parameter: Analogoutput_P7_Size\n                                      * Referenced by: '<Root>/Analog output '\n                                      */\n  real_T Analogoutput_P7[2];           /* Expression: parDacResets\n                                        * Referenced by: '<Root>/Analog output '\n                                        */\n  real_T WhiskerTrig_Amp;              /* Expression: 1\n                                        * Referenced by: '<Root>/Whisker Trig'\n                                        */\n  real_T WhiskerTrig_PhaseDelay;       /* Expression: 0\n                                        * Referenced by: '<Root>/Whisker Trig'\n                                        */\n  real_T NpxlsTrig_Amp;                /* Expression: 2.5\n                                        * Referenced by: '<Root>/Npxls Trig'\n                                        */\n  real_T NpxlsTrig_PhaseDelay;         /* Expression: 0\n                                        * Referenced by: '<Root>/Npxls Trig'\n                                        */\n  real_T PupilTrig_Amp;                /* Expression: 1\n                                        * Referenced by: '<Root>/Pupil Trig'\n                                        */\n  real_T PupilTrig_PhaseDelay;         /* Expression: 0\n                                        * Referenced by: '<Root>/Pupil Trig'\n                                        */\n  real_T Constant4_Value;              /* Expression: 1\n                                        * Referenced by: '<S5>/Constant4'\n                                        */\n  real_T Digitaloutput_P1_Size[2];  /* Computed Parameter: Digitaloutput_P1_Size\n                                     * Referenced by: '<Root>/Digital output '\n                                     */\n  real_T Digitaloutput_P1;             /* Expression: parModuleId\n                                        * Referenced by: '<Root>/Digital output '\n                                        */\n  real_T Digitaloutput_P2_Size[2];  /* Computed Parameter: Digitaloutput_P2_Size\n                                     * Referenced by: '<Root>/Digital output '\n                                     */\n  real_T Digitaloutput_P2;             /* Expression: parSampleTime\n                                        * Referenced by: '<Root>/Digital output '\n                                        */\n  real_T Digitaloutput_P3_Size[2];  /* Computed Parameter: Digitaloutput_P3_Size\n                                     * Referenced by: '<Root>/Digital output '\n                                     */\n  real_T Digitaloutput_P3;             /* Expression: parPciSlot\n                                        * Referenced by: '<Root>/Digital output '\n                                        */\n  real_T Digitaloutput_P4_Size[2];  /* Computed Parameter: Digitaloutput_P4_Size\n                                     * Referenced by: '<Root>/Digital output '\n                                     */\n  real_T Digitaloutput_P4[15];         /* Expression: parDoChannels\n                                        * Referenced by: '<Root>/Digital output '\n                                        */\n  real_T Digitaloutput_P5_Size[2];  /* Computed Parameter: Digitaloutput_P5_Size\n                                     * Referenced by: '<Root>/Digital output '\n                                     */\n  real_T Digitaloutput_P5[15];         /* Expression: parDoInitValues\n                                        * Referenced by: '<Root>/Digital output '\n                                        */\n  real_T Digitaloutput_P6_Size[2];  /* Computed Parameter: Digitaloutput_P6_Size\n                                     * Referenced by: '<Root>/Digital output '\n                                     */\n  real_T Digitaloutput_P6[15];         /* Expression: parDoResets\n                                        * Referenced by: '<Root>/Digital output '\n                                        */\n  real_T Digitalinput_P1_Size[2];    /* Computed Parameter: Digitalinput_P1_Size\n                                      * Referenced by: '<Root>/Digital input '\n                                      */\n  real_T Digitalinput_P1;              /* Expression: parModuleId\n                                        * Referenced by: '<Root>/Digital input '\n                                        */\n  real_T Digitalinput_P2_Size[2];    /* Computed Parameter: Digitalinput_P2_Size\n                                      * Referenced by: '<Root>/Digital input '\n                                      */\n  real_T Digitalinput_P2;              /* Expression: parSampleTime\n                                        * Referenced by: '<Root>/Digital input '\n                                        */\n  real_T Digitalinput_P3_Size[2];    /* Computed Parameter: Digitalinput_P3_Size\n                                      * Referenced by: '<Root>/Digital input '\n                                      */\n  real_T Digitalinput_P3;              /* Expression: parPciSlot\n                                        * Referenced by: '<Root>/Digital input '\n                                        */\n  real_T Digitalinput_P4_Size[2];    /* Computed Parameter: Digitalinput_P4_Size\n                                      * Referenced by: '<Root>/Digital input '\n                                      */\n  real_T Digitalinput_P4;              /* Expression: parDiChannels\n                                        * Referenced by: '<Root>/Digital input '\n                                        */\n};\n\n/* Storage class 'PageSwitching' */\nextern ATTN_cal_type ATTN_cal_impl;\nextern ATTN_cal_type *ATTN_cal;\n\n#endif                                 /* RTW_HEADER_ATTN_cal_h_ */\n"},{"name":"multiword_types.h","type":"header","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * multiword_types.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.461\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Nov 30 11:48:11 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef MULTIWORD_TYPES_H\n#define MULTIWORD_TYPES_H\n#include \"rtwtypes.h\"\n\n/*\n * Definitions supporting external data access\n */\ntypedef int64_T chunk_T;\ntypedef uint64_T uchunk_T;\n\n/*\n * MultiWord supporting definitions\n */\ntypedef long long longlong_T;\n\n/*\n * MultiWord types\n */\ntypedef struct {\n  uint64_T chunks[2];\n} int128m_T;\n\ntypedef struct {\n  int128m_T re;\n  int128m_T im;\n} cint128m_T;\n\ntypedef struct {\n  uint64_T chunks[2];\n} uint128m_T;\n\ntypedef struct {\n  uint128m_T re;\n  uint128m_T im;\n} cuint128m_T;\n\ntypedef struct {\n  uint64_T chunks[3];\n} int192m_T;\n\ntypedef struct {\n  int192m_T re;\n  int192m_T im;\n} cint192m_T;\n\ntypedef struct {\n  uint64_T chunks[3];\n} uint192m_T;\n\ntypedef struct {\n  uint192m_T re;\n  uint192m_T im;\n} cuint192m_T;\n\ntypedef struct {\n  uint64_T chunks[4];\n} int256m_T;\n\ntypedef struct {\n  int256m_T re;\n  int256m_T im;\n} cint256m_T;\n\ntypedef struct {\n  uint64_T chunks[4];\n} uint256m_T;\n\ntypedef struct {\n  uint256m_T re;\n  uint256m_T im;\n} cuint256m_T;\n\ntypedef struct {\n  uint64_T chunks[5];\n} int320m_T;\n\ntypedef struct {\n  int320m_T re;\n  int320m_T im;\n} cint320m_T;\n\ntypedef struct {\n  uint64_T chunks[5];\n} uint320m_T;\n\ntypedef struct {\n  uint320m_T re;\n  uint320m_T im;\n} cuint320m_T;\n\ntypedef struct {\n  uint64_T chunks[6];\n} int384m_T;\n\ntypedef struct {\n  int384m_T re;\n  int384m_T im;\n} cint384m_T;\n\ntypedef struct {\n  uint64_T chunks[6];\n} uint384m_T;\n\ntypedef struct {\n  uint384m_T re;\n  uint384m_T im;\n} cuint384m_T;\n\ntypedef struct {\n  uint64_T chunks[7];\n} int448m_T;\n\ntypedef struct {\n  int448m_T re;\n  int448m_T im;\n} cint448m_T;\n\ntypedef struct {\n  uint64_T chunks[7];\n} uint448m_T;\n\ntypedef struct {\n  uint448m_T re;\n  uint448m_T im;\n} cuint448m_T;\n\ntypedef struct {\n  uint64_T chunks[8];\n} int512m_T;\n\ntypedef struct {\n  int512m_T re;\n  int512m_T im;\n} cint512m_T;\n\ntypedef struct {\n  uint64_T chunks[8];\n} uint512m_T;\n\ntypedef struct {\n  uint512m_T re;\n  uint512m_T im;\n} cuint512m_T;\n\ntypedef struct {\n  uint64_T chunks[9];\n} int576m_T;\n\ntypedef struct {\n  int576m_T re;\n  int576m_T im;\n} cint576m_T;\n\ntypedef struct {\n  uint64_T chunks[9];\n} uint576m_T;\n\ntypedef struct {\n  uint576m_T re;\n  uint576m_T im;\n} cuint576m_T;\n\ntypedef struct {\n  uint64_T chunks[10];\n} int640m_T;\n\ntypedef struct {\n  int640m_T re;\n  int640m_T im;\n} cint640m_T;\n\ntypedef struct {\n  uint64_T chunks[10];\n} uint640m_T;\n\ntypedef struct {\n  uint640m_T re;\n  uint640m_T im;\n} cuint640m_T;\n\ntypedef struct {\n  uint64_T chunks[11];\n} int704m_T;\n\ntypedef struct {\n  int704m_T re;\n  int704m_T im;\n} cint704m_T;\n\ntypedef struct {\n  uint64_T chunks[11];\n} uint704m_T;\n\ntypedef struct {\n  uint704m_T re;\n  uint704m_T im;\n} cuint704m_T;\n\ntypedef struct {\n  uint64_T chunks[12];\n} int768m_T;\n\ntypedef struct {\n  int768m_T re;\n  int768m_T im;\n} cint768m_T;\n\ntypedef struct {\n  uint64_T chunks[12];\n} uint768m_T;\n\ntypedef struct {\n  uint768m_T re;\n  uint768m_T im;\n} cuint768m_T;\n\ntypedef struct {\n  uint64_T chunks[13];\n} int832m_T;\n\ntypedef struct {\n  int832m_T re;\n  int832m_T im;\n} cint832m_T;\n\ntypedef struct {\n  uint64_T chunks[13];\n} uint832m_T;\n\ntypedef struct {\n  uint832m_T re;\n  uint832m_T im;\n} cuint832m_T;\n\ntypedef struct {\n  uint64_T chunks[14];\n} int896m_T;\n\ntypedef struct {\n  int896m_T re;\n  int896m_T im;\n} cint896m_T;\n\ntypedef struct {\n  uint64_T chunks[14];\n} uint896m_T;\n\ntypedef struct {\n  uint896m_T re;\n  uint896m_T im;\n} cuint896m_T;\n\ntypedef struct {\n  uint64_T chunks[15];\n} int960m_T;\n\ntypedef struct {\n  int960m_T re;\n  int960m_T im;\n} cint960m_T;\n\ntypedef struct {\n  uint64_T chunks[15];\n} uint960m_T;\n\ntypedef struct {\n  uint960m_T re;\n  uint960m_T im;\n} cuint960m_T;\n\ntypedef struct {\n  uint64_T chunks[16];\n} int1024m_T;\n\ntypedef struct {\n  int1024m_T re;\n  int1024m_T im;\n} cint1024m_T;\n\ntypedef struct {\n  uint64_T chunks[16];\n} uint1024m_T;\n\ntypedef struct {\n  uint1024m_T re;\n  uint1024m_T im;\n} cuint1024m_T;\n\ntypedef struct {\n  uint64_T chunks[17];\n} int1088m_T;\n\ntypedef struct {\n  int1088m_T re;\n  int1088m_T im;\n} cint1088m_T;\n\ntypedef struct {\n  uint64_T chunks[17];\n} uint1088m_T;\n\ntypedef struct {\n  uint1088m_T re;\n  uint1088m_T im;\n} cuint1088m_T;\n\ntypedef struct {\n  uint64_T chunks[18];\n} int1152m_T;\n\ntypedef struct {\n  int1152m_T re;\n  int1152m_T im;\n} cint1152m_T;\n\ntypedef struct {\n  uint64_T chunks[18];\n} uint1152m_T;\n\ntypedef struct {\n  uint1152m_T re;\n  uint1152m_T im;\n} cuint1152m_T;\n\ntypedef struct {\n  uint64_T chunks[19];\n} int1216m_T;\n\ntypedef struct {\n  int1216m_T re;\n  int1216m_T im;\n} cint1216m_T;\n\ntypedef struct {\n  uint64_T chunks[19];\n} uint1216m_T;\n\ntypedef struct {\n  uint1216m_T re;\n  uint1216m_T im;\n} cuint1216m_T;\n\ntypedef struct {\n  uint64_T chunks[20];\n} int1280m_T;\n\ntypedef struct {\n  int1280m_T re;\n  int1280m_T im;\n} cint1280m_T;\n\ntypedef struct {\n  uint64_T chunks[20];\n} uint1280m_T;\n\ntypedef struct {\n  uint1280m_T re;\n  uint1280m_T im;\n} cuint1280m_T;\n\ntypedef struct {\n  uint64_T chunks[21];\n} int1344m_T;\n\ntypedef struct {\n  int1344m_T re;\n  int1344m_T im;\n} cint1344m_T;\n\ntypedef struct {\n  uint64_T chunks[21];\n} uint1344m_T;\n\ntypedef struct {\n  uint1344m_T re;\n  uint1344m_T im;\n} cuint1344m_T;\n\ntypedef struct {\n  uint64_T chunks[22];\n} int1408m_T;\n\ntypedef struct {\n  int1408m_T re;\n  int1408m_T im;\n} cint1408m_T;\n\ntypedef struct {\n  uint64_T chunks[22];\n} uint1408m_T;\n\ntypedef struct {\n  uint1408m_T re;\n  uint1408m_T im;\n} cuint1408m_T;\n\ntypedef struct {\n  uint64_T chunks[23];\n} int1472m_T;\n\ntypedef struct {\n  int1472m_T re;\n  int1472m_T im;\n} cint1472m_T;\n\ntypedef struct {\n  uint64_T chunks[23];\n} uint1472m_T;\n\ntypedef struct {\n  uint1472m_T re;\n  uint1472m_T im;\n} cuint1472m_T;\n\ntypedef struct {\n  uint64_T chunks[24];\n} int1536m_T;\n\ntypedef struct {\n  int1536m_T re;\n  int1536m_T im;\n} cint1536m_T;\n\ntypedef struct {\n  uint64_T chunks[24];\n} uint1536m_T;\n\ntypedef struct {\n  uint1536m_T re;\n  uint1536m_T im;\n} cuint1536m_T;\n\ntypedef struct {\n  uint64_T chunks[25];\n} int1600m_T;\n\ntypedef struct {\n  int1600m_T re;\n  int1600m_T im;\n} cint1600m_T;\n\ntypedef struct {\n  uint64_T chunks[25];\n} uint1600m_T;\n\ntypedef struct {\n  uint1600m_T re;\n  uint1600m_T im;\n} cuint1600m_T;\n\ntypedef struct {\n  uint64_T chunks[26];\n} int1664m_T;\n\ntypedef struct {\n  int1664m_T re;\n  int1664m_T im;\n} cint1664m_T;\n\ntypedef struct {\n  uint64_T chunks[26];\n} uint1664m_T;\n\ntypedef struct {\n  uint1664m_T re;\n  uint1664m_T im;\n} cuint1664m_T;\n\ntypedef struct {\n  uint64_T chunks[27];\n} int1728m_T;\n\ntypedef struct {\n  int1728m_T re;\n  int1728m_T im;\n} cint1728m_T;\n\ntypedef struct {\n  uint64_T chunks[27];\n} uint1728m_T;\n\ntypedef struct {\n  uint1728m_T re;\n  uint1728m_T im;\n} cuint1728m_T;\n\ntypedef struct {\n  uint64_T chunks[28];\n} int1792m_T;\n\ntypedef struct {\n  int1792m_T re;\n  int1792m_T im;\n} cint1792m_T;\n\ntypedef struct {\n  uint64_T chunks[28];\n} uint1792m_T;\n\ntypedef struct {\n  uint1792m_T re;\n  uint1792m_T im;\n} cuint1792m_T;\n\ntypedef struct {\n  uint64_T chunks[29];\n} int1856m_T;\n\ntypedef struct {\n  int1856m_T re;\n  int1856m_T im;\n} cint1856m_T;\n\ntypedef struct {\n  uint64_T chunks[29];\n} uint1856m_T;\n\ntypedef struct {\n  uint1856m_T re;\n  uint1856m_T im;\n} cuint1856m_T;\n\ntypedef struct {\n  uint64_T chunks[30];\n} int1920m_T;\n\ntypedef struct {\n  int1920m_T re;\n  int1920m_T im;\n} cint1920m_T;\n\ntypedef struct {\n  uint64_T chunks[30];\n} uint1920m_T;\n\ntypedef struct {\n  uint1920m_T re;\n  uint1920m_T im;\n} cuint1920m_T;\n\ntypedef struct {\n  uint64_T chunks[31];\n} int1984m_T;\n\ntypedef struct {\n  int1984m_T re;\n  int1984m_T im;\n} cint1984m_T;\n\ntypedef struct {\n  uint64_T chunks[31];\n} uint1984m_T;\n\ntypedef struct {\n  uint1984m_T re;\n  uint1984m_T im;\n} cuint1984m_T;\n\ntypedef struct {\n  uint64_T chunks[32];\n} int2048m_T;\n\ntypedef struct {\n  int2048m_T re;\n  int2048m_T im;\n} cint2048m_T;\n\ntypedef struct {\n  uint64_T chunks[32];\n} uint2048m_T;\n\ntypedef struct {\n  uint2048m_T re;\n  uint2048m_T im;\n} cuint2048m_T;\n\n#endif                                 /* MULTIWORD_TYPES_H */\n"},{"name":"rtGetInf.cpp","type":"source","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetInf.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.461\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Nov 30 11:48:11 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"rtwtypes.h\"\n\nextern \"C\"\n{\n\n#include \"rtGetInf.h\"\n\n}\n\n#include <stddef.h>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#define NumBitsPerChar                 8U\n\nextern \"C\"\n{\n  /*\n   * Initialize rtInf needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real_T rtGetInf(void)\n  {\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n    real_T inf = 0.0;\n    if (bitsPerReal == 32U) {\n      inf = rtGetInfF();\n    } else {\n      uint16_T one = 1U;\n      enum {\n        LittleEndian,\n        BigEndian\n      } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\n      switch (machByteOrder) {\n       case LittleEndian:\n        {\n          union {\n            LittleEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0x7FF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          inf = tmpVal.fltVal;\n          break;\n        }\n\n       case BigEndian:\n        {\n          union {\n            BigEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0x7FF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          inf = tmpVal.fltVal;\n          break;\n        }\n      }\n    }\n\n    return inf;\n  }\n\n  /*\n   * Initialize rtInfF needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real32_T rtGetInfF(void)\n  {\n    IEEESingle infF;\n    infF.wordL.wordLuint = 0x7F800000U;\n    return infF.wordL.wordLreal;\n  }\n\n  /*\n   * Initialize rtMinusInf needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real_T rtGetMinusInf(void)\n  {\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n    real_T minf = 0.0;\n    if (bitsPerReal == 32U) {\n      minf = rtGetMinusInfF();\n    } else {\n      uint16_T one = 1U;\n      enum {\n        LittleEndian,\n        BigEndian\n      } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\n      switch (machByteOrder) {\n       case LittleEndian:\n        {\n          union {\n            LittleEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0xFFF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          minf = tmpVal.fltVal;\n          break;\n        }\n\n       case BigEndian:\n        {\n          union {\n            BigEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0xFFF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          minf = tmpVal.fltVal;\n          break;\n        }\n      }\n    }\n\n    return minf;\n  }\n\n  /*\n   * Initialize rtMinusInfF needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real32_T rtGetMinusInfF(void)\n  {\n    IEEESingle minfF;\n    minfF.wordL.wordLuint = 0xFF800000U;\n    return minfF.wordL.wordLreal;\n  }\n}\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetInf.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.461\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Nov 30 11:48:11 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rtGetInf_h_\n#define RTW_HEADER_rtGetInf_h_\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#include \"rtwtypes.h\"\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern real_T rtGetInf(void);\n  extern real32_T rtGetInfF(void);\n  extern real_T rtGetMinusInf(void);\n  extern real32_T rtGetMinusInfF(void);\n\n#ifdef __cplusplus\n\n}                                      /* extern \"C\" */\n\n#endif\n#endif                                 /* RTW_HEADER_rtGetInf_h_ */\n"},{"name":"rtGetNaN.cpp","type":"source","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetNaN.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.461\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Nov 30 11:48:11 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"rtwtypes.h\"\n\nextern \"C\"\n{\n\n#include \"rtGetNaN.h\"\n\n}\n\n#include <stddef.h>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#define NumBitsPerChar                 8U\n\nextern \"C\"\n{\n  /*\n   * Initialize rtNaN needed by the generated code.\n   * NaN is initialized as non-signaling. Assumes IEEE.\n   */\n  real_T rtGetNaN(void)\n  {\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n    real_T nan = 0.0;\n    if (bitsPerReal == 32U) {\n      nan = rtGetNaNF();\n    } else {\n      uint16_T one = 1U;\n      enum {\n        LittleEndian,\n        BigEndian\n      } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\n      switch (machByteOrder) {\n       case LittleEndian:\n        {\n          union {\n            LittleEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0xFFF80000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          nan = tmpVal.fltVal;\n          break;\n        }\n\n       case BigEndian:\n        {\n          union {\n            BigEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0x7FFFFFFFU;\n          tmpVal.bitVal.words.wordL = 0xFFFFFFFFU;\n          nan = tmpVal.fltVal;\n          break;\n        }\n      }\n    }\n\n    return nan;\n  }\n\n  /*\n   * Initialize rtNaNF needed by the generated code.\n   * NaN is initialized as non-signaling. Assumes IEEE.\n   */\n  real32_T rtGetNaNF(void)\n  {\n    IEEESingle nanF = { { 0.0F } };\n\n    uint16_T one = 1U;\n    enum {\n      LittleEndian,\n      BigEndian\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\n    switch (machByteOrder) {\n     case LittleEndian:\n      {\n        nanF.wordL.wordLuint = 0xFFC00000U;\n        break;\n      }\n\n     case BigEndian:\n      {\n        nanF.wordL.wordLuint = 0x7FFFFFFFU;\n        break;\n      }\n    }\n\n    return nanF.wordL.wordLreal;\n  }\n}\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetNaN.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.461\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Nov 30 11:48:11 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rtGetNaN_h_\n#define RTW_HEADER_rtGetNaN_h_\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#include \"rtwtypes.h\"\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern real_T rtGetNaN(void);\n  extern real32_T rtGetNaNF(void);\n\n#ifdef __cplusplus\n\n}                                      /* extern \"C\" */\n\n#endif\n#endif                                 /* RTW_HEADER_rtGetNaN_h_ */\n"},{"name":"rt_nonfinite.cpp","type":"source","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rt_nonfinite.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.461\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Nov 30 11:48:11 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\nextern \"C\"\n{\n\n#include \"rtGetNaN.h\"\n\n}\n\nextern \"C\"\n{\n\n#include \"rtGetInf.h\"\n\n}\n\n#include <stddef.h>\n#include \"rtwtypes.h\"\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#define NumBitsPerChar                 8U\n\nextern \"C\"\n{\n  real_T rtInf;\n  real_T rtMinusInf;\n  real_T rtNaN;\n  real32_T rtInfF;\n  real32_T rtMinusInfF;\n  real32_T rtNaNF;\n}\n\nextern \"C\"\n{\n  /*\n   * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\n   * generated code. NaN is initialized as non-signaling. Assumes IEEE.\n   */\n  void rt_InitInfAndNaN(size_t realSize)\n  {\n    (void) (realSize);\n    rtNaN = rtGetNaN();\n    rtNaNF = rtGetNaNF();\n    rtInf = rtGetInf();\n    rtInfF = rtGetInfF();\n    rtMinusInf = rtGetMinusInf();\n    rtMinusInfF = rtGetMinusInfF();\n  }\n\n  /* Test if value is infinite */\n  boolean_T rtIsInf(real_T value)\n  {\n    return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\n  }\n\n  /* Test if single-precision value is infinite */\n  boolean_T rtIsInfF(real32_T value)\n  {\n    return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\n  }\n\n  /* Test if value is not a number */\n  boolean_T rtIsNaN(real_T value)\n  {\n    boolean_T result = (boolean_T) 0;\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n    if (bitsPerReal == 32U) {\n      result = rtIsNaNF((real32_T)value);\n    } else {\n      union {\n        LittleEndianIEEEDouble bitVal;\n        real_T fltVal;\n      } tmpVal;\n\n      tmpVal.fltVal = value;\n      result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) ==\n                           0x7FF00000 &&\n                           ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\n                            (tmpVal.bitVal.words.wordL != 0) ));\n    }\n\n    return result;\n  }\n\n  /* Test if single-precision value is not a number */\n  boolean_T rtIsNaNF(real32_T value)\n  {\n    IEEESingle tmp;\n    tmp.wordL.wordLreal = value;\n    return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\n                       (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\n  }\n}\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rt_nonfinite.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.461\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Nov 30 11:48:11 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rt_nonfinite_h_\n#define RTW_HEADER_rt_nonfinite_h_\n#include <stddef.h>\n#include \"rtwtypes.h\"\n#define NOT_USING_NONFINITE_LITERALS   1\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern real_T rtInf;\n  extern real_T rtMinusInf;\n  extern real_T rtNaN;\n  extern real32_T rtInfF;\n  extern real32_T rtMinusInfF;\n  extern real32_T rtNaNF;\n  extern void rt_InitInfAndNaN(size_t realSize);\n  extern boolean_T rtIsInf(real_T value);\n  extern boolean_T rtIsInfF(real32_T value);\n  extern boolean_T rtIsNaN(real_T value);\n  extern boolean_T rtIsNaNF(real32_T value);\n  struct BigEndianIEEEDouble {\n    struct {\n      uint32_T wordH;\n      uint32_T wordL;\n    } words;\n  };\n\n  struct LittleEndianIEEEDouble {\n    struct {\n      uint32_T wordL;\n      uint32_T wordH;\n    } words;\n  };\n\n  struct IEEESingle {\n    union {\n      real32_T wordLreal;\n      uint32_T wordLuint;\n    } wordL;\n  };\n\n#ifdef __cplusplus\n\n}                                      /* extern \"C\" */\n\n#endif\n#endif                                 /* RTW_HEADER_rt_nonfinite_h_ */\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtwtypes.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.461\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Nov 30 11:48:11 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTWTYPES_H\n#define RTWTYPES_H\n#include \"tmwtypes.h\"\n#ifndef POINTER_T\n#define POINTER_T\n\ntypedef void * pointer_T;\n\n#endif\n\n/* Logical type definitions */\n#if (!defined(__cplusplus))\n#ifndef false\n#define false                          (0U)\n#endif\n\n#ifndef true\n#define true                           (1U)\n#endif\n#endif\n\n#ifndef INT64_T\n#define INT64_T\n\ntypedef long int64_T;\n\n#define MAX_int64_T                    ((int64_T)(9223372036854775807L))\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807L-1L))\n#endif\n\n#ifndef UINT64_T\n#define UINT64_T\n\ntypedef unsigned long uint64_T;\n\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFUL))\n#endif\n\n/*===========================================================================*\n * Additional complex number type definitions                                           *\n *===========================================================================*/\n#ifndef CINT64_T\n#define CINT64_T\n\ntypedef struct {\n  int64_T re;\n  int64_T im;\n} cint64_T;\n\n#endif\n\n#ifndef CUINT64_T\n#define CUINT64_T\n\ntypedef struct {\n  uint64_T re;\n  uint64_T im;\n} cuint64_T;\n\n#endif\n#endif                                 /* RTWTYPES_H */\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Interface files","code":"/*\n *  rtmodel.h:\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.461\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Nov 30 11:48:11 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rtmodel_h_\n#define RTW_HEADER_rtmodel_h_\n#include \"ATTN.h\"\n#define GRTINTERFACE                   0\n#endif                                 /* RTW_HEADER_rtmodel_h_ */\n"},{"name":"sg_IO191_ad_s.c","type":"source","group":"interface","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw/../../../.speedgoat/speedgoatlib/R2023a/9.6.1.1_4/sg_blocks/analog","tag":"","groupDisplay":"Interface files","code":"// Copyright 2006-2023 Speedgoat GmbH\r\n\r\n#define S_FUNCTION_LEVEL    (0xd87+330-0xecf)\r\n#undef S_FUNCTION_NAME\r\n#define S_FUNCTION_NAME     sg_IO191_ad_s\r\n#include \"sg_IO191.h\"\r\n#ifndef MATLAB_MEX_FILE\r\n#include \"sg_printf.h\"\r\n#include \"sg_common.h\"\r\nvoid readPciBar(sg_PCIDevice*z7c46aa329e,int16_t bus,int16_t slot,int16_t z1e0fd5210f);\r\n#else\r\n#include \"mex.h\"\r\n#endif\r\n#include \"sg_callback.h\"\r\n#define ze13f49a01f           ssGetSFcnParam(S, (0x1421+4652-0x264d))\r\n#define z3832b85a32           ssGetSFcnParam(S, (0x82d+2280-0x1114))\r\n#define z702a26a5e9                ssGetSFcnParam(S, (0x141f+3266-0x20df))\r\n#define z3644586f49         ssGetSFcnParam(S, (0x6bc+3711-0x1538))\r\n#define z8d5c288b32         ssGetSFcnParam(S, (0x1a40+450-0x1bfe))\r\n#define zb66856d060         ssGetSFcnParam(S, (0x20ad+932-0x244c))\r\n#define z9876548c58         ssGetSFcnParam(S, (0x303+2144-0xb5d))\r\n#define zb093e77094      ssGetSFcnParam(S, (0x1650+3950-0x25b7))\r\n#define z2948f18e24        ssGetSFcnParam(S, (0x1310+1501-0x18e5))\r\n#define zdf24515981                           ((0x92c+2706-0x13b5))\r\n#define z7e2eeaa57c          ((0x1dfc+2294-0x26f2))\r\n#define zc0ced48ecf              ((0x770+2705-0x1200))\r\n#define z2e6483d505              ((0x110a+5601-0x26e9))\r\n#define zc5ce4cb81a              ((0x40d+302-0x53b))\r\n#define z0194338df7         ((0x21a0+274-0x22b2))\r\n#define z2b17e2ee3b              ((0x44b+4814-0x1718))\r\nstatic double zfc19727a48(uint32_t zf4d6a48e37);static char msg[z71934bf57c];static void mdlInitializeSizes(SimStruct*S){uint16_t i;ssSetNumSFcnParams(S,zdf24515981);if(ssGetNumSFcnParams(S)!=ssGetSFcnParamsCount(S)){sprintf(msg,\"\\x57\\x72\\x6f\\x6e\\x67\\x20\\x6e\\x75\\x6d\\x62\\x65\\x72\\x20\\x6f\\x66\\x20\\x69\\x6e\\x70\\x75\\x74\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x70\\x61\\x73\\x73\\x65\\x64\\x2e\" \"\\n\" \"\\x25\\x64\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x61\\x72\\x65\\x20\\x65\\x78\\x70\\x65\\x63\\x74\\x65\\x64\" \"\\n\",zdf24515981);ssSetErrorStatus(S,msg);return;}ssSetNumContStates(S,(0x49a+6035-0x1c2d));ssSetNumDiscStates(S,(0xbbd+3468-0x1949));if(!ssSetNumInputPorts(S,(0xebf+491-0x10aa)))return;if(!ssSetNumOutputPorts(S,(int)mxGetN(z3644586f49)))return;for(i=(0x26b+6461-0x1ba8);i<(int)mxGetN(z3644586f49);i++){ssSetOutputPortWidth(S,i,(0xdf5+2237-0x16b1));}ssSetNumSampleTimes(S,(0x5af+2164-0xe22));ssSetNumRWork(S,zc5ce4cb81a);ssSetNumIWork(S,z2e6483d505);ssSetNumPWork(S,z2b17e2ee3b);ssSetNumModes(S,(0x130+4427-0x127b));ssSetNumNonsampledZCs(S,(0x486+1293-0x993));for(i=(0x135a+368-0x14ca);i<zdf24515981;i++){ssSetSFcnParamTunable(S,i,(0x5eb+5912-0x1d03));}ssSetOptions(S,SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME|SS_OPTION_EXCEPTION_FREE_CODE|SS_OPTION_RUNTIME_EXCEPTION_FREE_CODE);}static void mdlInitializeSampleTimes(SimStruct*S){if(mxGetPr(z3832b85a32)[(0xbc9+611-0xe2c)]==-1.0){ssSetSampleTime(S,(0xf9d+3333-0x1ca2),INHERITED_SAMPLE_TIME);ssSetOffsetTime(S,(0xa0f+3396-0x1753),FIXED_IN_MINOR_STEP_OFFSET);}else{ssSetSampleTime(S,(0x2e3+889-0x65c),mxGetPr(z3832b85a32)[(0xb5d+6245-0x23c2)]);ssSetOffsetTime(S,(0xa80+96-0xae0),0.0);}ssSetModelReferenceSampleTimeDefaultInheritance(S);}\r\n#ifndef MATLAB_MEX_FILE\r\nstatic void sg_ModelLoad(SimStruct*S){}static void sg_ModelStart(SimStruct*S){sg_PCIDevice zeccbadd9b3;uint32_t bus,slot,za0d38ae598,ze5e89e1937,i;uint16_t z4e3026977c,zf91d71c6d9;volatile uint32_t*z27fd94ac66;if(mxGetN(z702a26a5e9)==(0x11b2+4500-0x2345)){bus=(0x8f8+5136-0x1d08);slot=(uint32_t)mxGetPr(z702a26a5e9)[(0xbc2+6909-0x26bf)];}else{bus=(uint32_t)mxGetPr(z702a26a5e9)[(0x730+109-0x79d)];slot=(uint32_t)mxGetPr(z702a26a5e9)[(0x17e1+1839-0x1f0f)];}za0d38ae598=((uint32_t)mxGetPr(ze13f49a01f)[(0x1cb2+361-0x1e1b)]);if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,za1afbacc4a,z78f5b4c5a6,z2bc00458b9,za0d38ae598,bus,slot)!=(0x3a8+8380-0x2464)){if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,zb765876dc5,z44a525e63d,za64fcbac7d,za0d38ae598,bus,slot)!=(0x83f+3255-0x14f6)){ssSetErrorStatus(S,pSgErrorStr);return;}}\r\n#ifdef _MSC_BUILD\r\nreadPciBar(&zeccbadd9b3,zeccbadd9b3.bus,zeccbadd9b3.slot,(0x6c4+3428-0x1428));\r\n#endif\r\nz27fd94ac66=(volatile uint32_t*)sg_mapMemory(&zeccbadd9b3,(0x168a+226-0x176a));zf91d71c6d9=(uint16_t)mxGetN(z3644586f49);ssSetPWorkValue(S,z0194338df7,(uint32_t*)z27fd94ac66);ssSetIWorkValue(S,z7e2eeaa57c,zf91d71c6d9);if(z27fd94ac66[REVISION]<zb5135f698e){sprintf(msg,\"\\x25\\x73\\x20\\x4d\\x6f\\x64\\x75\\x6c\\x65\\x20\\x49\\x44\\x20\\x25\\x64\\x20\\x46\\x69\\x72\\x6d\\x77\\x61\\x72\\x65\\x20\\x30\\x78\\x25\\x58\\x20\\x69\\x73\\x20\\x6f\\x75\\x74\\x64\\x61\\x74\\x65\\x64\\x2c\\x20\\x70\\x6c\\x65\\x61\\x73\\x65\\x20\\x63\\x6f\\x6e\\x74\\x61\\x63\\x74\\x20\\x53\\x70\\x65\\x65\\x64\\x67\\x6f\\x61\\x74\\x20\\x73\\x75\\x70\\x70\\x6f\\x72\\x74\\x2e\" \"\\n\",DEVNAME,za0d38ae598,z27fd94ac66[REVISION]);ssSetErrorStatus(S,msg);return;}z27fd94ac66[BRP]=((0x1ffa+403-0x218c)<<zbef81c3fd0);z27fd94ac66[z469883b65e]=(0x1175+2396-0x1ad1);z27fd94ac66[zfcd2c661f6]=(uint32_t)(z27fd94ac66[z24765e17f8]/z1a910f8330);SG_PRINTF_DEBUG(\"\\x41\\x44\\x43\\x5f\\x53\\x43\\x41\\x4e\\x5f\\x52\\x41\\x54\\x45\\x20\\x25\\x58\" \"\\n\",z27fd94ac66[zfcd2c661f6]);ze5e89e1937=(0x10f5+710-0x13bb);for(i=(0x7b8+7005-0x2315);i<zf91d71c6d9;i++){z4e3026977c=(uint16_t)mxGetPr(z3644586f49)[i]-(0x1eb+1714-0x89c);switch((uint16_t)mxGetPr(z9876548c58)[i]){case(0x7c7+6388-0x20ba):ze5e89e1937|=(z4eb3456176<<(z4e3026977c*(0x696+4149-0x16c7)));break;case(0x13bc+3824-0x22aa):ze5e89e1937|=(z7239c371e4<<(z4e3026977c*(0x95c+3508-0x170c)));break;case(0x7e9+429-0x993):ze5e89e1937|=(z65195ba21a<<(z4e3026977c*(0x10d6+3390-0x1e10)));break;case(0xb1b+1951-0x12b6):ze5e89e1937|=(z769e3cf99a<<(z4e3026977c*(0x10a3+377-0x1218)));break;case(0xd84+3455-0x1afe):ze5e89e1937|=(zad88ee04d7<<(z4e3026977c*(0x53d+7502-0x2287)));break;case(0x17d2+2662-0x2232):ze5e89e1937|=(z04726aa6f4<<(z4e3026977c*(0xb6f+4410-0x1ca5)));break;case(0x602+7248-0x224b):ze5e89e1937|=(zca8a2e109e<<(z4e3026977c*(0x9d4+6839-0x2487)));break;default:sprintf(msg,\"\\x41\\x6e\\x61\\x6c\\x6f\\x67\\x20\\x49\\x6e\\x70\\x75\\x74\\x73\\x20\\x75\\x6e\\x6b\\x6e\\x6f\\x77\\x6e\\x20\\x76\\x6f\\x6c\\x74\\x61\\x67\\x65\");ssSetErrorStatus(S,msg);break;}}z27fd94ac66[z3f2dd8a551]=ze5e89e1937;SG_PRINTF_DEBUG(\"\\x47\\x61\\x69\\x6e\\x20\\x72\\x65\\x67\\x69\\x73\\x74\\x65\\x72\\x3a\\x20\\x25\\x58\\x20\" \"\\n\",ze5e89e1937);ssSetIWorkValue(S,zc0ced48ecf,(0xfab+4387-0x20cd));}static void sg_ModelStep(SimStruct*S){uint16_t zf91d71c6d9=ssGetIWorkValue(S,z7e2eeaa57c);uint16_t z4d3816b14e=(uint16_t)mxGetPr(z3644586f49)[zf91d71c6d9-(0xd9+7701-0x1eed)]-(0x2211+510-0x240e);volatile uint32_t*z27fd94ac66=ssGetPWorkValue(S,z0194338df7);uint32_t ze77fa94a00=(uint32_t)mxGetPr(z8d5c288b32)[(0x8bb+460-0xa87)]-(0x1035+2325-0x1949);uint32_t i,z812c65ff2f,z297b36fb23,z41c8844f54;double*y;if((uint16_t)ssGetIWorkValue(S,zc0ced48ecf)==(0x2208+15-0x2216)){z27fd94ac66[z75b6a00559]=393322|((z4d3816b14e&(0x1666+1643-0x1cca))<<z690b1cd3dc)|(ze77fa94a00<<z0a8926012b)|((0xd23+2873-0x185b)<<z55588371ab);for(i=(0x19ec+199-0x1ab3);(z27fd94ac66[z75b6a00559]>>(0x29a+8557-0x23f7))>(0x46c+1030-0x86e);i++){if(i>1193000.0*1.0){sprintf(msg,\"\\x25\\x73\\x20\\x66\\x61\\x69\\x6c\\x65\\x64\\x20\\x74\\x6f\\x20\\x63\\x6f\\x6e\\x66\\x69\\x67\\x20\\x41\\x6e\\x61\\x6c\\x6f\\x67\\x20\\x69\\x6e\\x70\\x75\\x74\\x20\\x72\\x65\\x67\\x20\\x30\\x78\\x25\\x78\",DEVNAME,z27fd94ac66[z75b6a00559]>>(0x49a+8581-0x260f));ssSetErrorStatus(S,msg);return;}}ssSetIWorkValue(S,zc0ced48ecf,(0xf36+511-0x1135));}z41c8844f54=z27fd94ac66[zee1550bec3];for(i=(0x1c4+4708-0x1428);z41c8844f54<zf91d71c6d9;i++){if(i>1193000.0*2.0){sprintf(msg,\"\\x25\\x73\\x20\\x66\\x61\\x69\\x6c\\x65\\x64\\x20\\x74\\x6f\\x20\\x73\\x74\\x61\\x72\\x74\\x20\\x41\\x6e\\x61\\x6c\\x6f\\x67\\x20\\x69\\x6e\\x70\\x75\\x74\",DEVNAME);ssSetErrorStatus(S,msg);return;}z41c8844f54=z27fd94ac66[zee1550bec3];}for(i=(0x1db1+843-0x20fc);i<=z41c8844f54;i++){z297b36fb23=z27fd94ac66[zceb273b472];if(!(z297b36fb23&((0xbdf+1279-0x10dd)<<(0x256+8210-0x2249)))){for(z812c65ff2f=(0x18ba+2896-0x240a);z812c65ff2f<zf91d71c6d9;z812c65ff2f++){if(((uint16_t)mxGetPr(z3644586f49)[z812c65ff2f]-(0x854+693-0xb08))==(uint16_t)((z297b36fb23>>z09b806e22a)&(0x658+4661-0x1886))){y=ssGetOutputPortSignal(S,z812c65ff2f);y[(0x15ac+4118-0x25c2)]=zfc19727a48(z297b36fb23);break;}}}}z27fd94ac66[z75b6a00559]=393322|((z4d3816b14e&(0x3ea+1890-0xb45))<<z690b1cd3dc)|(ze77fa94a00<<z0a8926012b)|((0x303+95-0x361)<<\r\nz55588371ab);}static void sg_ModelStop(SimStruct*S){volatile uint32_t*z27fd94ac66=ssGetPWorkValue(S,z0194338df7);z27fd94ac66[BRP]=((0xb2b+1334-0x1060)<<zbef81c3fd0);}\r\n#endif  \r\nstatic double zfc19727a48(uint32_t zf4d6a48e37){double ze485f859ed;uint16_t z1044b54040=(zf4d6a48e37>>z2d5a35d68d)&(0x460+7091-0x200c);const double z3dec4d2bb3[(0xbf5+6672-0x25fd)]={24.576/32768,10.24/32768,5.12/32768,2.56/32768,1.28/32768,0.64/32768,65535,20.48/32768};if(((zf4d6a48e37>>z2858a50a43)&(0x1c5a+2555-0x2654))>(0x161d+1278-0x1b1b)){ze485f859ed=((((double)(zf4d6a48e37&65535))-z7935114df5)*z3dec4d2bb3[z1044b54040]);}else{ze485f859ed=(((double)(zf4d6a48e37&65535))*z3dec4d2bb3[z1044b54040]);}return ze485f859ed;}\r\n#include \"sg_sfcn_glue.h\"   \r\n\r\n"},{"name":"sg_IO191_da_s.c","type":"source","group":"interface","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw/../../../.speedgoat/speedgoatlib/R2023a/9.6.1.1_4/sg_blocks/analog","tag":"","groupDisplay":"Interface files","code":"// Copyright 2006-2023 Speedgoat GmbH\r\n\r\n#define S_FUNCTION_LEVEL    (0x115c+4425-0x22a3)\r\n#undef S_FUNCTION_NAME\r\n#define S_FUNCTION_NAME     sg_IO191_da_s\r\n#include \"sg_IO191.h\"\r\n#ifndef MATLAB_MEX_FILE\r\n#include \"sg_printf.h\"\r\n#include \"sg_common.h\"\r\nvoid readPciBar(sg_PCIDevice*z7c46aa329e,int16_t bus,int16_t slot,int16_t z1e0fd5210f);\r\n#else\r\n#include \"mex.h\"\r\n#endif\r\n#include \"sg_callback.h\"\r\n#define ze13f49a01f           ssGetSFcnParam(S, (0x1087+3465-0x1e10))\r\n#define z3832b85a32           ssGetSFcnParam(S, (0x1144+2969-0x1cdc))\r\n#define z702a26a5e9                ssGetSFcnParam(S, (0x660+1141-0xad3))\r\n#define zfa79626a1f        ssGetSFcnParam(S, (0x10ac+2040-0x18a1))\r\n#define z832477988f        ssGetSFcnParam(S, (0x1c80+1808-0x238c))\r\n#define ze4bd57db54     ssGetSFcnParam(S, (0x161b+2429-0x1f93))\r\n#define zc6e5e42eac       ssGetSFcnParam(S, (0xd37+1615-0x1380))\r\n#define zdf24515981                           ((0x1da7+1552-0x23b0))\r\n#define z2e6483d505              ((0x1151+3974-0x20d7))\r\n#define zc5ce4cb81a              ((0xbe1+209-0xcb2))\r\n#define z0194338df7         ((0x2103+180-0x21b7))\r\n#define z2b17e2ee3b              ((0x22+1846-0x757))\r\nstatic int32_t z58d7aabac0(uint32_t zc8abac822d,double z7e546ae0bf);static char msg[z71934bf57c];static void mdlInitializeSizes(SimStruct*S){uint16_t i;ssSetNumSFcnParams(S,zdf24515981);if(ssGetNumSFcnParams(S)!=ssGetSFcnParamsCount(S)){sprintf(msg,\"\\x57\\x72\\x6f\\x6e\\x67\\x20\\x6e\\x75\\x6d\\x62\\x65\\x72\\x20\\x6f\\x66\\x20\\x69\\x6e\\x70\\x75\\x74\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x70\\x61\\x73\\x73\\x65\\x64\\x2e\" \"\\n\" \"\\x25\\x64\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x61\\x72\\x65\\x20\\x65\\x78\\x70\\x65\\x63\\x74\\x65\\x64\" \"\\n\",zdf24515981);ssSetErrorStatus(S,msg);return;}ssSetNumContStates(S,(0x1b18+885-0x1e8d));ssSetNumDiscStates(S,(0x4d+3063-0xc44));if(!ssSetNumOutputPorts(S,(0x1f6+1692-0x892)))return;if(!ssSetNumInputPorts(S,(int)mxGetN(zfa79626a1f)))return;for(i=(0xa3f+2563-0x1442);i<(int)mxGetN(zfa79626a1f);i++){ssSetInputPortWidth(S,i,(0x1d1c+2074-0x2535));ssSetInputPortDirectFeedThrough(S,i,(0x496+6731-0x1ee0));ssSetInputPortRequiredContiguous(S,i,(0x205+938-0x5ae));}ssSetNumSampleTimes(S,(0x7c8+3155-0x141a));ssSetNumRWork(S,zc5ce4cb81a);ssSetNumIWork(S,z2e6483d505);ssSetNumPWork(S,z2b17e2ee3b);ssSetNumModes(S,(0xf24+2439-0x18ab));ssSetNumNonsampledZCs(S,(0x8e6+1662-0xf64));for(i=(0xdf9+3148-0x1a45);i<zdf24515981;i++){ssSetSFcnParamTunable(S,i,(0xfd7+1134-0x1445));}ssSetOptions(S,SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME|SS_OPTION_EXCEPTION_FREE_CODE|SS_OPTION_RUNTIME_EXCEPTION_FREE_CODE);}static void mdlInitializeSampleTimes(SimStruct*S){if(mxGetPr(z3832b85a32)[(0x13f3+1824-0x1b13)]==-1.0){ssSetSampleTime(S,(0x5bf+1780-0xcb3),INHERITED_SAMPLE_TIME);ssSetOffsetTime(S,(0x94c+4883-0x1c5f),FIXED_IN_MINOR_STEP_OFFSET);}else{ssSetSampleTime(S,(0xb6d+6577-0x251e),mxGetPr(z3832b85a32)[(0xccc+4368-0x1ddc)]);ssSetOffsetTime(S,(0x1f04+788-0x2218),0.0);}ssSetModelReferenceSampleTimeDefaultInheritance(S);}\r\n#ifndef MATLAB_MEX_FILE\r\nstatic void sg_ModelLoad(SimStruct*S){}static void sg_ModelStart(SimStruct*S){sg_PCIDevice zeccbadd9b3;uint32_t bus,slot,za0d38ae598;volatile uint32_t*z27fd94ac66;uint16_t z879ede9171=(uint16_t)mxGetN(zfa79626a1f);uint32_t z812c65ff2f,zc8abac822d,zc430a259a4;uint16_t i,z4e3026977c;int32_t z7711a772ed;double z7e546ae0bf;if(mxGetN(z702a26a5e9)==(0x11ca+257-0x12ca)){bus=(0xef0+5035-0x229b);slot=(uint32_t)mxGetPr(z702a26a5e9)[(0x8e9+5014-0x1c7f)];}else{bus=(uint32_t)mxGetPr(z702a26a5e9)[(0xffa+5633-0x25fb)];slot=(uint32_t)mxGetPr(z702a26a5e9)[(0x76+3457-0xdf6)];}za0d38ae598=((uint32_t)mxGetPr(ze13f49a01f)[(0x74f+3385-0x1488)]);if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,za1afbacc4a,z78f5b4c5a6,z2bc00458b9,za0d38ae598,bus,slot)!=(0x14cd+3154-0x211f)){if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,zb765876dc5,z44a525e63d,za64fcbac7d,za0d38ae598,bus,slot)!=(0x1d1+4045-0x119e)){ssSetErrorStatus(S,pSgErrorStr);return;}}\r\n#ifdef _MSC_BUILD\r\nreadPciBar(&zeccbadd9b3,zeccbadd9b3.bus,zeccbadd9b3.slot,(0x2c3+7285-0x1f38));\r\n#endif\r\nz27fd94ac66=(volatile uint32_t*)sg_mapMemory(&zeccbadd9b3,(0x12c2+3206-0x1f46));ssSetPWorkValue(S,z0194338df7,(uint32_t*)z27fd94ac66);for(i=(0x450+2145-0xcb1);i<z879ede9171;i++){zc430a259a4=(0xaea+2788-0x15ce);z4e3026977c=(uint16_t)mxGetPr(zfa79626a1f)[i]-(0x260+1861-0x9a4);zc8abac822d=(uint32_t)mxGetPr(z832477988f)[i]-(0xedc+3261-0x1b98);z7e546ae0bf=(double)mxGetPr(ze4bd57db54)[z4e3026977c];z7711a772ed=z58d7aabac0(zc8abac822d,z7e546ae0bf);zc430a259a4=(z7711a772ed&65535)|((z4e3026977c&(0x865+2053-0x105b))<<z18b319d394)|(zbec0ec695f<<z668ef58fc5);if(z27fd94ac66[REVISION]>=z5f130b7753){for(z812c65ff2f=(0x52+4871-0x1359);z27fd94ac66[zeeea544396]&((0x166d+167-0x1713)<<z579611d67f);z812c65ff2f++){if(z812c65ff2f>1193000.0*1.0){sprintf(msg,\"\\x25\\x73\\x20\\x41\\x6e\\x61\\x6c\\x6f\\x67\\x20\\x4f\\x75\\x74\\x70\\x75\\x74\\x20\\x53\\x50\\x49\\x20\\x69\\x73\\x20\\x62\\x75\\x73\\x79\",DEVNAME);ssSetErrorStatus(S,msg);return;}}z27fd94ac66[zeeea544396]=zc430a259a4;}else{z27fd94ac66[zeeea544396]=zc430a259a4;sg_wait_ns(z905251a4e4);}zc430a259a4=(zc8abac822d&65535)|((z4e3026977c&(0x155c+3961-0x24c6))<<z18b319d394)|(z4d4e3e315a<<z668ef58fc5);if(z27fd94ac66[REVISION]>=z5f130b7753){for(z812c65ff2f=(0x127c+2160-0x1aec);z27fd94ac66[zeeea544396]&((0x22e0+1009-0x26d0)<<z579611d67f);z812c65ff2f++){if(z812c65ff2f>1193000.0*1.0){sprintf(msg,\"\\x25\\x73\\x20\\x41\\x6e\\x61\\x6c\\x6f\\x67\\x20\\x4f\\x75\\x74\\x70\\x75\\x74\\x20\\x53\\x50\\x49\\x20\\x69\\x73\\x20\\x62\\x75\\x73\\x79\",DEVNAME);ssSetErrorStatus(S,msg);return;}}z27fd94ac66[zeeea544396]=zc430a259a4;}else{z27fd94ac66[zeeea544396]=zc430a259a4;sg_wait_ns(z905251a4e4);}}}static void sg_ModelStep(SimStruct*S){volatile uint32_t*z27fd94ac66=ssGetPWorkValue(S,z0194338df7);uint16_t zf91d71c6d9=(uint16_t)mxGetN(zfa79626a1f);uint32_t zc430a259a4,z26dbd73a5e,zc8abac822d;int32_t out;uint16_t i,z812c65ff2f,z4e3026977c,zd953a322a2,z2ce6e80f45;double*zc7fdaf6331;if(z27fd94ac66[REVISION]>=z5f130b7753){for(i=(0x1f7c+1906-0x26ee);i<zf91d71c6d9;i++){zc430a259a4=(0x9c6+1647-0x1035);z4e3026977c=(uint16_t)mxGetPr(zfa79626a1f)[i]-(0x6ea+700-0x9a5);zc7fdaf6331=(double*)ssGetInputPortRealSignal(S,i);zc8abac822d=(uint32_t)mxGetPr(z832477988f)[i]-(0x10b2+3359-0x1dd0);out=z58d7aabac0(zc8abac822d,zc7fdaf6331[(0xad3+5209-0x1f2c)]);zc430a259a4=(out&65535)|((z4e3026977c&(0xb3c+2889-0x1676))<<z18b319d394)|(zbec0ec695f<<z668ef58fc5);for(z26dbd73a5e=(0x2c3+5143-0x16da);z27fd94ac66[zeeea544396]&((0x1a70+2074-0x2289)<<z579611d67f);z26dbd73a5e++){if(z26dbd73a5e>1193000.0*1.0){sprintf(msg,\"\\x25\\x73\\x20\\x41\\x6e\\x61\\x6c\\x6f\\x67\\x20\\x4f\\x75\\x74\\x70\\x75\\x74\\x20\\x53\\x50\\x49\\x20\\x69\\x73\\x20\\x62\\x75\\x73\\x79\",DEVNAME);ssSetErrorStatus(S,msg);return;}}z27fd94ac66[zeeea544396]=zc430a259a4;}}else{if(zf91d71c6d9>(0x3c2+8185-0x23b9)){zd953a322a2=(0x59d+7459-0x22be);z2ce6e80f45=zf91d71c6d9;}else{zd953a322a2=zf91d71c6d9;z2ce6e80f45=(0x132+8860-0x23ce);}for(i=(0x2e5+2709-0xd7a);i<zd953a322a2;i++){zc430a259a4=(0x644+3281-0x1315);z4e3026977c=(uint16_t)mxGetPr(zfa79626a1f)[i]-(0x1334+4140-0x235f);zc7fdaf6331=(double*)ssGetInputPortRealSignal(S,i);zc8abac822d=(uint32_t)mxGetPr(z832477988f)[i]-(0x8ef+5876-0x1fe2);out=z58d7aabac0(zc8abac822d,zc7fdaf6331[(0x1e5b+1507-0x243e)]);zc430a259a4=(out&65535)|((z4e3026977c&(0x931+1765-0x1007))<<z18b319d394)|(zbec0ec695f<<z668ef58fc5);z27fd94ac66[zeeea544396]=zc430a259a4;sg_wait_ns(z7edc1a4c28);}sg_wait_ns(z7edc1a4c28);for(z812c65ff2f=i;z812c65ff2f<z2ce6e80f45;z812c65ff2f++){zc430a259a4=(0x2e8+7263-0x1f47);z4e3026977c=(uint16_t)mxGetPr(zfa79626a1f)[z812c65ff2f]-(0x109d+4671-0x22db);zc7fdaf6331=(double*)ssGetInputPortRealSignal(S,z812c65ff2f);zc8abac822d=(uint32_t)mxGetPr(z832477988f)[z812c65ff2f]-(0x6ec+3830-0x15e1);out=z58d7aabac0(zc8abac822d,zc7fdaf6331[(0x11+9277-0x244e)]);zc430a259a4=(out&65535)|((z4e3026977c&(0x5d3+5261-0x1a51))<<z18b319d394)|(zbec0ec695f<<z668ef58fc5);z27fd94ac66[zeeea544396]=zc430a259a4;sg_wait_ns(z905251a4e4);}}}static void sg_ModelStop(SimStruct*S){volatile uint32_t*z27fd94ac66=ssGetPWorkValue(S,z0194338df7);uint16_t z879ede9171=(uint16_t)mxGetN(zfa79626a1f);int32_t z7711a772ed;uint32_t z812c65ff2f,zc8abac822d,zc430a259a4;uint16_t i,\r\nz4e3026977c;double z7e546ae0bf;for(i=(0x22c+4901-0x1551);i<z879ede9171;i++){if((int)mxGetPr(zc6e5e42eac)[i]){zc430a259a4=(0x334+5769-0x19bd);z4e3026977c=(uint16_t)mxGetPr(zfa79626a1f)[i]-(0x14cc+4305-0x259c);zc8abac822d=(uint32_t)mxGetPr(z832477988f)[i]-(0xb94+6731-0x25de);z7e546ae0bf=(double)mxGetPr(ze4bd57db54)[z4e3026977c];z7711a772ed=z58d7aabac0(zc8abac822d,z7e546ae0bf);zc430a259a4=(z7711a772ed&65535)|((z4e3026977c&(0x1632+3041-0x2204))<<z18b319d394)|(zbec0ec695f<<z668ef58fc5);if(z27fd94ac66[REVISION]>=z5f130b7753){for(z812c65ff2f=(0xdc6+3965-0x1d43);z27fd94ac66[zeeea544396]&((0xf3f+5553-0x24ef)<<z579611d67f);z812c65ff2f++){if(z812c65ff2f>1193000.0*1.0){sprintf(msg,\"\\x25\\x73\\x20\\x41\\x6e\\x61\\x6c\\x6f\\x67\\x20\\x4f\\x75\\x74\\x70\\x75\\x74\\x20\\x53\\x50\\x49\\x20\\x69\\x73\\x20\\x62\\x75\\x73\\x79\",DEVNAME);ssSetErrorStatus(S,msg);return;}}z27fd94ac66[zeeea544396]=zc430a259a4;}else{z27fd94ac66[zeeea544396]=zc430a259a4;sg_wait_ns(z905251a4e4);}zc430a259a4=(zc8abac822d&65535)|((z4e3026977c&(0x302+3062-0xee9))<<z18b319d394)|(z4d4e3e315a<<z668ef58fc5);if(z27fd94ac66[REVISION]>=z5f130b7753){for(z812c65ff2f=(0x364+352-0x4c4);z27fd94ac66[zeeea544396]&((0xd3c+126-0xdb9)<<z579611d67f);z812c65ff2f++){if(z812c65ff2f>1193000.0*1.0){sprintf(msg,\"\\x25\\x73\\x20\\x41\\x6e\\x61\\x6c\\x6f\\x67\\x20\\x4f\\x75\\x74\\x70\\x75\\x74\\x20\\x53\\x50\\x49\\x20\\x69\\x73\\x20\\x62\\x75\\x73\\x79\",DEVNAME);ssSetErrorStatus(S,msg);return;}}z27fd94ac66[zeeea544396]=zc430a259a4;}else{z27fd94ac66[zeeea544396]=zc430a259a4;sg_wait_ns(z905251a4e4);}}}}\r\n#endif  \r\nstatic int32_t z58d7aabac0(uint32_t zc8abac822d,double z7e546ae0bf){double z2f029a8902=(0x4a4+220-0x580),ze9f1c9266b=(0x2aa+6656-0x1caa);int32_t out;switch(zc8abac822d){case(0x174b+2220-0x1ff7):z2f029a8902=13107.2;ze9f1c9266b=(0x3bc+8576-0x253c);break;case(0x15c0+1905-0x1d30):z2f029a8902=6553.6;ze9f1c9266b=(0x15dd+3376-0x230d);break;case(0x1653+3958-0x25c7):z2f029a8902=6553.6;ze9f1c9266b=32768;break;case(0xd84+4180-0x1dd5):z2f029a8902=3276.8;ze9f1c9266b=32768;break;case(0x7c3+3343-0x14ce):z2f029a8902=13107.2;ze9f1c9266b=32768;break;default:SG_PRINTF_INFO(\"\\x45\\x72\\x72\\x6f\\x72\\x3a\\x20\\x41\\x6e\\x61\\x6c\\x6f\\x67\\x20\\x4f\\x75\\x74\\x70\\x75\\x74\\x73\\x20\\x75\\x6e\\x6b\\x6e\\x6f\\x77\\x6e\\x20\\x76\\x6f\\x6c\\x74\\x61\\x67\\x65\");break;}out=(int32_t)((z7e546ae0bf*z2f029a8902)+ze9f1c9266b);if(out>z7935114df5){out=z7935114df5;}else if(out<(0x4f4+35-0x517)){out=(0x122b+4047-0x21fa);}return out;}\r\n#include \"sg_sfcn_glue.h\"   \r\n\r\n"},{"name":"sg_IO191_di_s.c","type":"source","group":"interface","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw/../../../.speedgoat/speedgoatlib/R2023a/9.6.1.1_4/sg_blocks/analog","tag":"","groupDisplay":"Interface files","code":"// Copyright 2006-2023 Speedgoat GmbH\r\n\r\n#define S_FUNCTION_LEVEL    (0x490+2482-0xe40)\r\n#undef S_FUNCTION_NAME\r\n#define S_FUNCTION_NAME     sg_IO191_di_s\r\n#include \"sg_IO191.h\"\r\n#ifndef MATLAB_MEX_FILE\r\n#include \"sg_printf.h\"\r\n#include \"sg_common.h\"\r\nvoid readPciBar(sg_PCIDevice*z7c46aa329e,int16_t bus,int16_t slot,int16_t z1e0fd5210f);\r\n#else\r\n#include \"mex.h\"\r\n#endif\r\n#include \"sg_callback.h\"\r\n#define ze13f49a01f           ssGetSFcnParam(S, (0x1759+2617-0x2192))\r\n#define z3832b85a32           ssGetSFcnParam(S, (0x5f8+3193-0x1270))\r\n#define z702a26a5e9                ssGetSFcnParam(S, (0x2c5+4208-0x1333))\r\n#define zb18e38a301           ssGetSFcnParam(S, (0xa61+4466-0x1bd0))\r\n#define zdf24515981                           ((0x16f8+3286-0x23ca))\r\n#define z2e6483d505              ((0x26a+8085-0x21ff))\r\n#define zc5ce4cb81a              ((0x11f5+4924-0x2531))\r\n#define z0194338df7         ((0x3c2+703-0x681))\r\n#define z2b17e2ee3b              ((0x147c+2948-0x1fff))\r\nstatic char msg[z71934bf57c];static void mdlInitializeSizes(SimStruct*S){uint16_t i;ssSetNumSFcnParams(S,zdf24515981);if(ssGetNumSFcnParams(S)!=ssGetSFcnParamsCount(S)){sprintf(msg,\"\\x57\\x72\\x6f\\x6e\\x67\\x20\\x6e\\x75\\x6d\\x62\\x65\\x72\\x20\\x6f\\x66\\x20\\x69\\x6e\\x70\\x75\\x74\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x70\\x61\\x73\\x73\\x65\\x64\\x2e\" \"\\n\" \"\\x25\\x64\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x61\\x72\\x65\\x20\\x65\\x78\\x70\\x65\\x63\\x74\\x65\\x64\" \"\\n\",zdf24515981);ssSetErrorStatus(S,msg);return;}ssSetNumContStates(S,(0xc7b+5592-0x2253));ssSetNumDiscStates(S,(0x1185+3229-0x1e22));if(!ssSetNumInputPorts(S,(0xb62+481-0xd43)))return;if(!ssSetNumOutputPorts(S,(int)mxGetN(zb18e38a301)))return;for(i=(0x1d13+145-0x1da4);i<(int)mxGetN(zb18e38a301);i++){ssSetOutputPortWidth(S,i,(0x486+5466-0x19df));ssSetOutputPortDataType(S,(0x56c+6929-0x207d),SS_DOUBLE);}ssSetNumSampleTimes(S,(0x1a08+2901-0x255c));ssSetNumRWork(S,zc5ce4cb81a);ssSetNumIWork(S,z2e6483d505);ssSetNumPWork(S,z2b17e2ee3b);ssSetNumModes(S,(0x1aad+2738-0x255f));ssSetNumNonsampledZCs(S,(0x1482+3272-0x214a));for(i=(0xd05+5164-0x2131);i<zdf24515981;i++){ssSetSFcnParamTunable(S,i,(0x12db+3246-0x1f89));}ssSetOptions(S,SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME|SS_OPTION_EXCEPTION_FREE_CODE|SS_OPTION_RUNTIME_EXCEPTION_FREE_CODE);}static void mdlInitializeSampleTimes(SimStruct*S){if(mxGetPr(z3832b85a32)[(0x2cd+619-0x538)]==-1.0){ssSetSampleTime(S,(0x136d+3208-0x1ff5),INHERITED_SAMPLE_TIME);ssSetOffsetTime(S,(0x19a0+2894-0x24ee),FIXED_IN_MINOR_STEP_OFFSET);}else{ssSetSampleTime(S,(0x574+6180-0x1d98),mxGetPr(z3832b85a32)[(0x662+3656-0x14aa)]);ssSetOffsetTime(S,(0xbd9+2070-0x13ef),0.0);}ssSetModelReferenceSampleTimeDefaultInheritance(S);}\r\n#ifndef MATLAB_MEX_FILE\r\nstatic void sg_ModelLoad(SimStruct*S){}static void sg_ModelStart(SimStruct*S){sg_PCIDevice zeccbadd9b3;uint32_t bus,slot,za0d38ae598;volatile uint32_t*z27fd94ac66;if(mxGetN(z702a26a5e9)==(0xb62+5554-0x2113)){bus=(0x10ed+5301-0x25a2);slot=(uint32_t)mxGetPr(z702a26a5e9)[(0x874+6135-0x206b)];}else{bus=(uint32_t)mxGetPr(z702a26a5e9)[(0xadd+5988-0x2241)];slot=(uint32_t)mxGetPr(z702a26a5e9)[(0x8cd+1253-0xdb1)];}za0d38ae598=((uint32_t)mxGetPr(ze13f49a01f)[(0x1749+1291-0x1c54)]);if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,za1afbacc4a,z78f5b4c5a6,z2bc00458b9,za0d38ae598,bus,slot)!=(0xf55+4351-0x2054)){if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,zb765876dc5,z44a525e63d,za64fcbac7d,za0d38ae598,bus,slot)!=(0x594+130-0x616)){ssSetErrorStatus(S,pSgErrorStr);return;}}\r\n#ifdef _MSC_BUILD\r\nreadPciBar(&zeccbadd9b3,zeccbadd9b3.bus,zeccbadd9b3.slot,(0x1252+4672-0x2492));\r\n#endif\r\nz27fd94ac66=(volatile uint32_t*)sg_mapMemory(&zeccbadd9b3,(0x189+4706-0x13e9));ssSetPWorkValue(S,z0194338df7,(uint32_t*)z27fd94ac66);}static void sg_ModelStep(SimStruct*S){volatile uint32_t*za42cf7dd4a=ssGetPWorkValue(S,z0194338df7);uint32_t i,input,z4e3026977c;double*y;input=za42cf7dd4a[z52eac5d033];for(i=(0x180b+74-0x1855);i<(uint32_t)mxGetN(zb18e38a301);i++){z4e3026977c=(uint32_t)mxGetPr(zb18e38a301)[i]-(0x2c4+612-0x527);y=ssGetOutputPortSignal(S,i);if(input&((0x2149+672-0x23e8)<<z4e3026977c)){y[(0x1c4c+1042-0x205e)]=(0x60f+1538-0xc10);}else{y[(0xcf3+2372-0x1637)]=(0xc11+4873-0x1f1a);}}}static void sg_ModelStop(SimStruct*S){}\r\n#endif  \r\n#include \"sg_sfcn_glue.h\"   \r\n\r\n"},{"name":"sg_IO191_do_s.c","type":"source","group":"interface","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw/../../../.speedgoat/speedgoatlib/R2023a/9.6.1.1_4/sg_blocks/analog","tag":"","groupDisplay":"Interface files","code":"// Copyright 2006-2023 Speedgoat GmbH\r\n\r\n#define S_FUNCTION_LEVEL    (0x5bf+2361-0xef6)\r\n#undef S_FUNCTION_NAME\r\n#define S_FUNCTION_NAME     sg_IO191_do_s\r\n#include \"sg_IO191.h\"\r\n#ifndef MATLAB_MEX_FILE\r\n#include \"sg_printf.h\"\r\n#include \"sg_common.h\"\r\nvoid readPciBar(sg_PCIDevice*z7c46aa329e,int16_t bus,int16_t slot,int16_t z1e0fd5210f);\r\n#else\r\n#include \"mex.h\"\r\n#endif\r\n#include \"sg_callback.h\"\r\n#define ze13f49a01f           ssGetSFcnParam(S, (0x13e0+4526-0x258e))\r\n#define z3832b85a32           ssGetSFcnParam(S, (0x182+5115-0x157c))\r\n#define z702a26a5e9                ssGetSFcnParam(S, (0xc01+464-0xdcf))\r\n#define z5bc3ce0d50           ssGetSFcnParam(S, (0x776+1601-0xdb4))\r\n#define z2d8f240c11           ssGetSFcnParam(S, (0x1772+625-0x19df))\r\n#define z1f9bebb47b             ssGetSFcnParam(S, (0x1683+2315-0x1f89))\r\n#define zdf24515981                           ((0xf52+4685-0x2199))\r\n#define z2e6483d505              ((0x9a8+3518-0x1766))\r\n#define zc5ce4cb81a              ((0x1263+4888-0x257b))\r\n#define z0194338df7         ((0x1786+2885-0x22cb))\r\n#define z2b17e2ee3b              ((0x17e9+3860-0x26fc))\r\n#define THRESHOLD               0.5\r\nstatic char msg[z71934bf57c];static void mdlInitializeSizes(SimStruct*S){uint16_t i;ssSetNumSFcnParams(S,zdf24515981);if(ssGetNumSFcnParams(S)!=ssGetSFcnParamsCount(S)){sprintf(msg,\"\\x57\\x72\\x6f\\x6e\\x67\\x20\\x6e\\x75\\x6d\\x62\\x65\\x72\\x20\\x6f\\x66\\x20\\x69\\x6e\\x70\\x75\\x74\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x70\\x61\\x73\\x73\\x65\\x64\\x2e\" \"\\n\" \"\\x25\\x64\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x61\\x72\\x65\\x20\\x65\\x78\\x70\\x65\\x63\\x74\\x65\\x64\" \"\\n\",zdf24515981);ssSetErrorStatus(S,msg);return;}ssSetNumContStates(S,(0x140a+1006-0x17f8));ssSetNumDiscStates(S,(0x1616+685-0x18c3));if(!ssSetNumOutputPorts(S,(0x13da+1201-0x188b)))return;if(!ssSetNumInputPorts(S,(int)mxGetN(z5bc3ce0d50)))return;for(i=(0x46b+7087-0x201a);i<(int)mxGetN(z5bc3ce0d50);i++){ssSetInputPortWidth(S,i,(0xe05+6052-0x25a8));ssSetInputPortDirectFeedThrough(S,i,(0xed2+5455-0x2420));ssSetInputPortRequiredContiguous(S,i,(0x12af+3337-0x1fb7));}ssSetNumSampleTimes(S,(0x1528+613-0x178c));ssSetNumRWork(S,zc5ce4cb81a);ssSetNumIWork(S,z2e6483d505);ssSetNumPWork(S,z2b17e2ee3b);ssSetNumModes(S,(0x4cd+6065-0x1c7e));ssSetNumNonsampledZCs(S,(0x117a+4372-0x228e));for(i=(0xf68+410-0x1102);i<zdf24515981;i++){ssSetSFcnParamTunable(S,i,(0x3d8+8140-0x23a4));}ssSetOptions(S,SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME|SS_OPTION_EXCEPTION_FREE_CODE|SS_OPTION_RUNTIME_EXCEPTION_FREE_CODE);}static void mdlInitializeSampleTimes(SimStruct*S){if(mxGetPr(z3832b85a32)[(0x9fa+5271-0x1e91)]==-1.0){ssSetSampleTime(S,(0x11bd+334-0x130b),INHERITED_SAMPLE_TIME);ssSetOffsetTime(S,(0x1899+3649-0x26da),FIXED_IN_MINOR_STEP_OFFSET);}else{ssSetSampleTime(S,(0x136d+1483-0x1938),mxGetPr(z3832b85a32)[(0xbe9+1888-0x1349)]);ssSetOffsetTime(S,(0x46+6698-0x1a70),0.0);}ssSetModelReferenceSampleTimeDefaultInheritance(S);}\r\n#ifndef MATLAB_MEX_FILE\r\nstatic void sg_ModelLoad(SimStruct*S){}static void sg_ModelStart(SimStruct*S){sg_PCIDevice zeccbadd9b3;uint32_t zf91d71c6d9=(uint32_t)mxGetN(z5bc3ce0d50);volatile uint32_t*z27fd94ac66;uint32_t bus,slot,za0d38ae598,zcb341ffb0e,i;if(mxGetN(z702a26a5e9)==(0x9d9+408-0xb70)){bus=(0x149+2546-0xb3b);slot=(uint32_t)mxGetPr(z702a26a5e9)[(0x140a+3821-0x22f7)];}else{bus=(uint32_t)mxGetPr(z702a26a5e9)[(0x7c+6885-0x1b61)];slot=(uint32_t)mxGetPr(z702a26a5e9)[(0x3d3+2043-0xbcd)];}za0d38ae598=((uint32_t)mxGetPr(ze13f49a01f)[(0x1799+3688-0x2601)]);if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,za1afbacc4a,z78f5b4c5a6,z2bc00458b9,za0d38ae598,bus,slot)!=(0x662+3015-0x1229)){if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,zb765876dc5,z44a525e63d,za64fcbac7d,za0d38ae598,bus,slot)!=(0x69c+69-0x6e1)){ssSetErrorStatus(S,pSgErrorStr);return;}}\r\n#ifdef _MSC_BUILD\r\nreadPciBar(&zeccbadd9b3,zeccbadd9b3.bus,zeccbadd9b3.slot,(0xe31+1798-0x1537));\r\n#endif\r\nz27fd94ac66=(volatile uint32_t*)sg_mapMemory(&zeccbadd9b3,(0xd58+5538-0x22f8));ssSetPWorkValue(S,z0194338df7,(uint32_t*)z27fd94ac66);zcb341ffb0e=z27fd94ac66[z52eac5d033];for(i=(0xb41+4562-0x1d13);i<zf91d71c6d9;i++){if((int)mxGetPr(z2d8f240c11)[i]>THRESHOLD){zcb341ffb0e|=((0xda2+5684-0x23d5)<<((uint32_t)mxGetPr(z5bc3ce0d50)[i]-(0x157d+4050-0x254e)));}else{zcb341ffb0e&=~((0x2d6+837-0x61a)<<((uint32_t)mxGetPr(z5bc3ce0d50)[i]-(0x153f+221-0x161b)));}}z27fd94ac66[z52eac5d033]=zcb341ffb0e;}static void sg_ModelStep(SimStruct*S){volatile uint32_t*z27fd94ac66=ssGetPWorkValue(S,z0194338df7);uint16_t z344fcf0ef3;uint32_t i,zcb341ffb0e;double output;double*zc7fdaf6331;z344fcf0ef3=(uint16_t)mxGetN(z5bc3ce0d50);zcb341ffb0e=(0x4fa+3413-0x124f);for(i=(0x36+8129-0x1ff7);i<z344fcf0ef3;i++){zc7fdaf6331=(double*)ssGetInputPortRealSignal(S,i);output=zc7fdaf6331[(0x19e1+2812-0x24dd)];if(output>THRESHOLD){zcb341ffb0e|=((0x671+3271-0x1337)<<((uint16_t)mxGetPr(z5bc3ce0d50)[i]-(0xab+1594-0x6e4)));}}z27fd94ac66[z52eac5d033]=zcb341ffb0e;}static void sg_ModelStop(SimStruct*S){volatile uint32_t*z27fd94ac66=ssGetPWorkValue(S,z0194338df7);uint32_t zf91d71c6d9=(uint32_t)mxGetN(z5bc3ce0d50);uint32_t i,zcb341ffb0e;zcb341ffb0e=z27fd94ac66[z52eac5d033];for(i=(0x651+2318-0xf5f);i<zf91d71c6d9;i++){if((int)mxGetPr(z1f9bebb47b)[i]==(0x127d+4999-0x2603)){if((int)mxGetPr(z2d8f240c11)[i]>THRESHOLD){zcb341ffb0e|=((0x11fa+1665-0x187a)<<((uint32_t)mxGetPr(z5bc3ce0d50)[i]-(0x996+7480-0x26cd)));}else{zcb341ffb0e&=~((0x1a70+576-0x1caf)<<((uint32_t)mxGetPr(z5bc3ce0d50)[i]-(0x85f+5265-0x1cef)));}}}z27fd94ac66[z52eac5d033]=zcb341ffb0e;}\r\n#endif  \r\n#include \"sg_sfcn_glue.h\"   \r\n\r\n"},{"name":"sg_IO191_setup_s.c","type":"source","group":"interface","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw/../../../.speedgoat/speedgoatlib/R2023a/9.6.1.1_4/sg_blocks/analog","tag":"","groupDisplay":"Interface files","code":"// Copyright 2006-2023 Speedgoat GmbH\r\n\r\n#define S_FUNCTION_LEVEL    (0x10cb+2737-0x1b7a)\r\n#undef S_FUNCTION_NAME\r\n#define S_FUNCTION_NAME     sg_IO191_setup_s\r\n#include \"sg_IO191.h\"\r\n#ifndef MATLAB_MEX_FILE\r\n#include \"sg_printf.h\"\r\n#include \"sg_common.h\"\r\nvoid readPciBar(sg_PCIDevice*z7c46aa329e,int16_t bus,int16_t slot,int16_t z1e0fd5210f);\r\n#else\r\n#include \"mex.h\"\r\n#endif\r\n#include \"sg_callback.h\"\r\n#define z702a26a5e9                ssGetSFcnParam(S, (0x154+6099-0x1927))\r\n#define ze13f49a01f           ssGetSFcnParam(S, (0xaa2+2017-0x1282))\r\n#define z1e0b67709d       ssGetSFcnParam(S, (0x7b7+749-0xaa2))\r\n#define z3644586f49         ssGetSFcnParam(S, (0x1a0c+2186-0x2293))\r\n#define z8d5c288b32         ssGetSFcnParam(S, (0x42b+217-0x500))\r\n#define z9876548c58         ssGetSFcnParam(S, (0xff7+3171-0x1c55))\r\n#define zfa79626a1f        ssGetSFcnParam(S, (0xb19+229-0xbf8))\r\n#define z832477988f        ssGetSFcnParam(S, (0xcbc+1663-0x1334))\r\n#define z4526a8632b         ssGetSFcnParam(S, (0xc27+2227-0x14d2))\r\n#define zdf24515981                           ((0xe83+6110-0x2658))\r\n#define z2e6483d505              ((0x1e94+1092-0x22d8))\r\n#define z8caad2a8e6              ((0x551+1754-0xc2b))\r\n#define z5bfe7a2613            ((0x1341+4557-0x250d))\r\n#define zc5ce4cb81a              ((0x1152+4077-0x213d))\r\n#define z0194338df7         ((0x841+6504-0x21a9))\r\n#define z2b17e2ee3b              ((0x1e5+7568-0x1f74))\r\nstatic char msg[z71934bf57c];static void mdlInitializeSizes(SimStruct*S){uint16_t i;ssSetNumSFcnParams(S,zdf24515981);if(ssGetNumSFcnParams(S)!=ssGetSFcnParamsCount(S)){sprintf(msg,\"\\x57\\x72\\x6f\\x6e\\x67\\x20\\x6e\\x75\\x6d\\x62\\x65\\x72\\x20\\x6f\\x66\\x20\\x69\\x6e\\x70\\x75\\x74\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x70\\x61\\x73\\x73\\x65\\x64\\x2e\" \"\\n\" \"\\x25\\x64\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x61\\x72\\x65\\x20\\x65\\x78\\x70\\x65\\x63\\x74\\x65\\x64\" \"\\n\",zdf24515981);ssSetErrorStatus(S,msg);return;}ssSetNumContStates(S,(0x2e0+9175-0x26b7));ssSetNumDiscStates(S,(0xa2b+4369-0x1b3c));if(!ssSetNumInputPorts(S,(0x2070+1166-0x24fe)))return;if(!ssSetNumOutputPorts(S,(0x46+573-0x283)))return;ssSetNumSampleTimes(S,(0x16a5+3548-0x2480));ssSetNumRWork(S,zc5ce4cb81a);ssSetNumIWork(S,z2e6483d505);ssSetNumPWork(S,z2b17e2ee3b);ssSetNumModes(S,(0xecd+231-0xfb4));ssSetNumNonsampledZCs(S,(0x147f+2175-0x1cfe));for(i=(0x8c2+6705-0x22f3);i<zdf24515981;i++){ssSetSFcnParamTunable(S,i,(0x72d+7595-0x24d8));}ssSetOptions(S,SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME|SS_OPTION_EXCEPTION_FREE_CODE|SS_OPTION_RUNTIME_EXCEPTION_FREE_CODE|SS_OPTION_PLACE_ASAP);}static void mdlInitializeSampleTimes(SimStruct*S){ssSetSampleTime(S,(0x21b6+431-0x2365),INHERITED_SAMPLE_TIME);ssSetOffsetTime(S,(0xc59+5933-0x2386),FIXED_IN_MINOR_STEP_OFFSET);ssSetModelReferenceSampleTimeDefaultInheritance(S);}\r\n#ifndef MATLAB_MEX_FILE\r\nstatic void sg_ModelLoad(SimStruct*S){}static void sg_ModelStart(SimStruct*S){sg_PCIDevice zeccbadd9b3;uint32_t bus,slot,za0d38ae598,i;uint16_t z4e3026977c,z0e26ef1137;volatile uint32_t*z27fd94ac66;if(mxGetN(z702a26a5e9)==(0x2413+265-0x251b)){bus=(0x1286+3641-0x20bf);slot=(uint32_t)mxGetPr(z702a26a5e9)[(0xb13+5593-0x20ec)];}else{bus=(uint32_t)mxGetPr(z702a26a5e9)[(0x1ea3+159-0x1f42)];slot=(uint32_t)mxGetPr(z702a26a5e9)[(0x9dd+2573-0x13e9)];}za0d38ae598=((uint32_t)mxGetPr(ze13f49a01f)[(0xba+8255-0x20f9)]);if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,za1afbacc4a,z78f5b4c5a6,z2bc00458b9,za0d38ae598,bus,slot)!=(0x1bed+1278-0x20eb)){if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,zb765876dc5,z44a525e63d,za64fcbac7d,za0d38ae598,bus,slot)!=(0x160+861-0x4bd)){ssSetErrorStatus(S,pSgErrorStr);return;}}\r\n#ifdef _MSC_BUILD\r\nreadPciBar(&zeccbadd9b3,zeccbadd9b3.bus,zeccbadd9b3.slot,(0x3bb+8030-0x2319));\r\n#endif\r\nz27fd94ac66=(volatile uint32_t*)sg_mapMemory(&zeccbadd9b3,(0x1017+4953-0x236e));ssSetPWorkValue(S,z0194338df7,(uint32_t*)z27fd94ac66);SG_PRINTF_DEBUG(\"\\x25\\x73\\x3a\\x20\\x46\\x50\\x47\\x41\\x20\\x72\\x65\\x76\\x20\\x30\\x78\\x25\\x58\" \"\\n\",DEVNAME,z27fd94ac66[REVISION]);z0e26ef1137=(0x3d2+7874-0x2294);for(i=(0xf05+2232-0x17bd);i<(uint32_t)mxGetN(z4526a8632b);i++){z4e3026977c=(uint32_t)mxGetPr(z4526a8632b)[i];if(z4e3026977c==(0xdb5+5768-0x243c)){z0e26ef1137=(0x21f3+336-0x2342);}else{z0e26ef1137|=((0xf52+2401-0x18b2)<<(z4e3026977c+(0x145c+4654-0x2684)));}}z27fd94ac66[zef0a03cb9f]=z0e26ef1137;}static void sg_ModelStep(SimStruct*S){}static void sg_ModelStop(SimStruct*S){}\r\n#endif  \r\n#include \"sg_sfcn_glue.h\"   \r\n\r\n"},{"name":"main.cpp","type":"source","group":"legacy","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Other files","code":"/* Main generated for Simulink Real-Time model ATTN */\n#include <ModelInfo.hpp>\n#include <utilities.hpp>\n#include \"ATTN.h\"\n#include \"rte_ATTN_parameters.h\"\n\n/* Task descriptors */\nslrealtime::TaskInfo task_1( 0u, std::bind(ATTN_step), slrealtime::TaskInfo::PERIODIC, 0.001, 0, 40);\n\n/* Executable base address for XCP */\n#ifdef __linux__\nextern char __executable_start;\nstatic uintptr_t const base_address = reinterpret_cast<uintptr_t>(&__executable_start);\n#else\n/* Set 0 as placeholder, to be parsed later from /proc filesystem */\nstatic uintptr_t const base_address = 0;\n#endif\n\n/* Model descriptor */\nslrealtime::ModelInfo ATTN_Info =\n{\n    \"ATTN\",\n    ATTN_initialize,\n    ATTN_terminate,\n    []()->char const*& { return ATTN_M->errorStatus; },\n    []()->unsigned char& { return ATTN_M->Timing.stopRequestedFlag; },\n    { task_1 },\n    slrealtime::getSegmentVector()\n};\n\nint main(int argc, char *argv[]) {\n    slrealtime::BaseAddress::set(base_address);\n    return slrealtime::runModel(argc, argv, ATTN_Info);\n}\n"},{"name":"rt_matrx.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2023a/rtw/c/src","tag":"","groupDisplay":"Other files","code":"/* File    : rt_matrx.c\n * Abstract:\n *      Implements stand alone matrix access and creation routines.\n *\tThere are two types of MATLAB objects which can be \"passed\" to\n *\tthe generated code, a 2D real matrix and a string. Strings are\n *\tpassed as 2D real matrices. The first two elements of an S-function\n *\tparameters are the row and column (m and n) dimensions respectively.\n *\tThese are followed by the matrix data.\n */\n\n\n\n/*\n * Copyright 1994-2022 The MathWorks, Inc.\n */\n\n/*==========*\n * Includes *\n *==========*/\n\n#if defined(MDL_REF_SIM_TGT)\n#undef MATLAB_MEX_FILE\n#endif\n\n#if defined(MATLAB_MEX_FILE)\n# error \"rt_matrix cannot be used within a mex file. It is for codegen only.\"\n#endif\n\n#include <string.h>    /* for strlen */\n#include \"rt_matrx.h\"\n\n#include <stddef.h> /* needed for size_t and NULL */\n#include <float.h>  /* needed for definition of eps */\n\n/*==========*\n * Typedefs *\n *==========*/\n\n#ifndef rt_typedefs_h\n#define rt_typedefs_h\n\n#if !defined(TYPEDEF_MX_ARRAY)\n# define TYPEDEF_MX_ARRAY\n  typedef real_T mxArray;\n#endif\n\ntypedef real_T mxChar;\n\n#if !defined(TMW_NAME_LENGTH_MAX)\n#define TMW_NAME_LENGTH_MAX 64\n#endif\n#define mxMAXNAM  TMW_NAME_LENGTH_MAX\t/* maximum name length */\n\ntypedef enum {\n    mxREAL,\n    mxCOMPLEX\n} mxComplexity;\n\n#endif /* rt_typedefs_h */\n\n/*==================*\n * Extern variables *\n *==================*/\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nextern real_T rtInf;\nextern real_T rtMinusInf;\nextern real_T rtNaN;\n\n#ifdef __cplusplus\n}\n#endif\n\n/*=======================================*\n * Defines for mx Routines and constants *\n *=======================================*/\n\n\n#define mxCalloc(n,size) \\\n        calloc(n,size)\n\n#define mxCreateCharArray(ndim, dims) \\\n        mxCreateNumericArray(ndim, dims, mxCHAR_CLASS);\n\n#define mxDestroyArray(pa) \\\n        if (pa) free(pa)\n\n/* NOTE: You cannot mxFree(mxGetPr(pa)) !!! */\n#define mxFree(ptr) \\\n        if(ptr)free(ptr)\n\n#define mxGetClassID(pa) \\\n        mxDOUBLE_CLASS\n\n/* NOTE: mxGetClassName(pa) returns \"double\" even on a character array */\n#define mxGetClassName(pa) \\\n        \"double\"\n\n#define mxGetData(pa) \\\n        ((void *)(&((pa)[2])))\n\n#define mxGetElementSize(pa) \\\n        (sizeof(real_T))\n\n#define mxGetInf() \\\n        rtInf\n\n#define mxGetM(pa) \\\n        ((size_t) ((pa)[0]))\n#define mxGetN(pa) \\\n        ((size_t) ((pa)[1]))\n\n#define mxGetNaN() \\\n        rtNaN\n\n#define mxGetNumberOfDimensions(pa) \\\n        (2)\n#define mxGetNumberOfElements(pa) \\\n        (mxGetM(pa)*mxGetN(pa))\n\n/* NOTE: mxGetPr() of an empty matrix does NOT return NULL */\n#define mxGetPr(pa) \\\n        ( &((pa)[2]) )\n\n/* NOTE: mxGetDoubles() of an empty matrix does NOT return NULL */\n#define mxGetDoubles(pa) \\\n        ( &((pa)[2]) )\n\n#define mxGetScalar(pa) \\\n        ((pa)[2])\n\n#define mxIsComplex(pa) \\\n        false\n\n#define mxIsDouble(pa) \\\n        true\n\n#define mxIsEmpty(pa) \\\n        (mxGetM(pa)==0 || mxGetN(pa)==0)\n\n#define mxIsFinite(r) \\\n        ((r)>rtMinusInf && (r)<rtInf)\n\n#define mxIsInf(r) \\\n        ((r)==rtInf || (r)==rtMinusInf)\n\n#define mxIsInt16(pa) \\\n        false\n\n#define mxIsInt32(pa) \\\n        false\n\n#define mxIsInt8(pa) \\\n        false\n\n#define mxIsLogical(pa) \\\n        false\n\n#define mxIsNumeric(pa) \\\n        true\n\n#define mxIsSingle(pa) \\\n        false\n\n#define mxIsSparse(pa) \\\n        false\n\n#define mxIsStruct(pa) \\\n        false\n\n#define mxIsUint16(pa) \\\n        false\n\n#define mxIsUint32(pa) \\\n        false\n\n#define mxIsUint8(pa) \\\n        false\n\n#define mxMalloc(n) \\\n        malloc(n)\n\n#define mxRealloc(p,n) \\\n        realloc(p,n)\n\n/*==============*\n * Local macros *\n *==============*/\n#define _mxSetM(pa,m) \\\n        (pa)[0] = ((int)(m))\n\n#define _mxSetN(pa,n) \\\n        (pa)[1] = ((int)(n))\n\n\n/*==========================*\n * Visible/extern functions *\n *=========================*/\n\n/* Function: mxCreateCharMatrixFromStrings ====================================\n * Abstract:\n *\tCreate a string array initialized to the strings in str.\n */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nmxArray *rt_mxCreateCharMatrixFromStrings(int_T m, const char_T **str)\n{\n    int_T nchars;\n    int_T i, n;\n    mxArray *pa;\n\n    n = 0;\n    for (i = 0; i < m; ++i) {\n\tnchars = (int_T)strlen(str[i]);\n\tif (nchars > n) {\n\t    n = nchars;\n\t}\n    }\n\n    pa = (mxArray *)malloc((m*n+2)*sizeof(real_T));\n    if(pa!=NULL) {\n\tmxChar *chars;\n\tint_T  j;\n\t_mxSetM(pa, m);\n\t_mxSetN(pa, n);\n\tchars = mxGetPr(pa);\n\tfor (j = 0; j < m; ++j) {\n\t    const char_T *src  = str[j];\n\t    mxChar *dest = chars + j;\n\n\t    nchars = (int_T)strlen(src);\n\t    i = nchars;\n\t    while (i--) {\n\t\t*dest = *src++;\n\t\t dest += m;\n\t    }\n\t    i = n - nchars;\n\t    while (i--) {\n\t\t*dest = 0.0;\n\t\tdest += m;\n\t    }\n\t}\n    }\n    return pa;\n} /* end mxCreateCharMatrixFromStrings */\n\n#ifdef __cplusplus\n}\n#endif\n\n/* Function: mxCreateString ===================================================\n * Abstract:\n *\tCreate a 1-by-n string array initialized to null terminated string\n *\twhere n is the length of the string.\n */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nmxArray *rt_mxCreateString(const char *str)\n{\n    int_T   len = (int_T)strlen(str);\n\n    mxArray *pa = (mxArray *)malloc((len+2)*sizeof(real_T));\n\n    if(pa!=NULL) {\n\treal_T *pr;\n\tconst unsigned char *ustr_ptr = (const unsigned char *) str;\n\n\t_mxSetM(pa, 1);\n\t_mxSetN(pa, len);\n\tpr = mxGetPr(pa);\n\twhile (len--) {\n            *pr++ = (real_T)*ustr_ptr++;\n        }\n    }\n    return(pa);\n\n} /* end mxCreateString */\n\n#ifdef __cplusplus\n}\n#endif\n\n/* Function: mxCreateDoubleMatrix =============================================\n * Abstract:\n *\tCreate a two-dimensional array to hold real_T data,\n *\tinitialize each data element to 0.\n */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nmxArray *rt_mxCreateDoubleMatrix(int m, int n, mxComplexity flag)\n{\n    if (flag == mxREAL) {\n        mxArray *pa = (mxArray *)calloc(m*n+2, sizeof(real_T));\n        if(pa!=NULL) {\n            _mxSetM(pa, m);\n            _mxSetN(pa, n);\n        }\n        return(pa);\n    } else {\n        return(NULL);\n    }\n\n} /* end mxCreateDoubleMatrix */\n\n#ifdef __cplusplus\n}\n#endif\n\n/* Function: mxCreateNumericArray =============================================\n * Abstract:\n *\tCreate a numeric array and initialize all its data elements to 0.\n */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nmxArray *rt_mxCreateNumericArray(int_T ndims, const mwSize *dims, \n                                        mxClassID classid, mxComplexity flag)\n{\n    if (ndims == 2 && classid==mxDOUBLE_CLASS) {\n        return(rt_mxCreateDoubleMatrix((int)(dims[0]), (int)(dims[1]), flag));\n    } else {\n        return(NULL);\n    }\n\n} /* end mxCreateNumericArray */\n\n#ifdef __cplusplus\n}\n#endif\n\n/* Function: mxDuplicateArray =================================================\n * Abstract:\n *\tMake a deep copy of an array, return a pointer to the copy.\n */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nmxArray *rt_mxDuplicateArray(const mxArray *pa)\n{\n\n    size_t   nbytes = (mxGetNumberOfElements(pa)+2)*mxGetElementSize(pa);\n    mxArray *pcopy = (mxArray *)malloc(nbytes);\n\n    if (pcopy!=NULL) {\n\t(void)memcpy(pcopy, pa, nbytes);\n    }\n    return(pcopy);\n\n} /* end mxDuplicateArray */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n/* Function: mxGetDimensions ==================================================\n * Abstract:\n *\tGet pointer to dimension array\n */\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nconst mwSize *rt_mxGetDimensions(const mxArray *pa)\n{\n    static mwSize dims[2];\n    dims[0] = mxGetM(pa);\n    dims[1] = mxGetN(pa);\n    return dims;\n} /* end mxGetDimensions */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n/* Function: mxGetEps =========================================================\n * Abstract:\n *\tReturn eps, the difference between 1.0 and the least value\n *\tgreater than 1.0 that is representable as a real_T.\n */\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nreal_T rt_mxGetEps(void)\n{\n    return (sizeof(double)==sizeof(real_T)) ? DBL_EPSILON : FLT_EPSILON;\n}\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n/* Function: mxGetString ======================================================\n * Abstract:\n *\tConverts a string array to a C-style string.\n */\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nint_T rt_mxGetString(const mxArray *pa, char_T *buf, int_T buflen)\n{\n    int_T        nchars;\n    const real_T *pr;\n    char_T       *pc;\n    int_T        truncate = 0;\n\n    nchars = (int_T)mxGetNumberOfElements(pa);\n    if (nchars >= buflen) {\n\t/* leave room for null byte */\n\tnchars = buflen - 1;\n\ttruncate = 1;\n    }\n    pc = buf;\n    pr = mxGetPr(pa);\n    while (nchars--) {\n\t*pc++ = (char) (*pr++ + .5);\n    }\n    *pc = '\\0';\n    return truncate;\n} /* end mxGetString */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n#define mxCreateCharMatrixFromStrings(m, str) \\\n        rt_mxCreateCharMatrixFromStrings(m, str)\n\n#define mxCreateString(str) \\\n        rt_mxCreateString(str) \n\n#define mxCreateDoubleMatrix(m, n, flag) \\\n        rt_mxCreateDoubleMatrix(m, n, flag)\n\n#define mxCreateNumericArray(ndims, dims, classid, flag) \\\n        rt_mxCreateNumericArray(ndims, dims, classid, flag)\n\n#define mxDuplicateArray(pa) \\\n        rt_mxDuplicateArray(pa)\n\n#define mxGetDimensions(pa) \\\n        rt_mxGetDimensions(pa)\n\n#define mxGetEps() \\\n        rt_mxGetEps()\n\n#define mxGetString(pa, buf, buflen) \\\n        rt_mxGetString(pa, buf, buflen)\n\n/*=========================*\n * Unsupported mx Routines *\n *=========================*/\n\n#define mxCalcSingleSubscript(pa,nsubs,subs) \\\n        mxCalcSingleSubscript_is_not_supported_in_Simulink_Coder\n\n#define mxCreateCellArray(ndim,dims) \\\n        mxCreateCellArray_is_not_supported_in_Simulink_Coder\n\n#define mxCreateCellMatrix(m,n) \\\n        mxCreateCellMatrix_is_not_supported_in_Simulink_Coder\n\n#define mxCreateSparse(pm,pn,pnzmax,pcmplx_flg) \\\n        mxCreateSparse_is_not_supported_in_Simulink_Coder\n\n#define mxCreateStructArray(ndim,dims,nfields,fieldnames) \\\n        mxCreateStructArray_is_not_supported_in_Simulink_Coder\n\n#define mxCreateStructMatrix(m,n,nfields,fieldnames) \\\n        mxCreateStructMatrix_is_not_supported_in_Simulink_Coder\n\n#define mxGetCell(pa,i) \\\n        mxGetCell_is_not_supported_in_Simulink_Coder\n\n#define mxGetField(pa,i,fieldname) \\\n        mxGetField_is_not_supported_in_Simulink_Coder\n\n#define mxGetFieldByNumber(s,i,fieldnum) \\\n        mxGetFieldByNumber_is_not_supported_in_Simulink_Coder\n\n#define mxGetFieldNameByNumber(pa,n) \\\n        mxGetFieldNameByNumber_is_not_supported_in_Simulink_Coder\n\n#define mxGetFieldNumber(pa,fieldname) \\\n        mxGetFieldNumber_is_not_supported_in_Simulink_Coder\n\n#define mxGetImagData(pa) \\\n        mxGetImagData_is_not_supported_in_Simulink_Coder\n\n#define mxGetIr(ppa) \\\n        mxGetIr_is_not_supported_in_Simulink_Coder\n\n#define mxGetJc(ppa) \\\n        mxGetJc_is_not_supported_in_Simulink_Coder\n\n#define mxGetNumberOfFields(pa) \\\n        mxGetNumberOfFields_is_not_supported_in_Simulink_Coder\n\n#define mxGetNzmax(pa) \\\n        mxGetNzmax_is_not_supported_in_Simulink_Coder\n\n#define mxGetPi(pa) \\\n        mxGetPi_is_not_supported_in_Simulink_Coder\n\n#define mxIsFromGlobalWS(pa) \\\n        mxIsFromGlobalWS_is_not_supported_in_Simulink_Coder\n\n#define mxIsNaN(r) \\\n        mxIsNaN_is_not_supported_in_Simulink_Coder\n\n#define mxIsChar(pa) \\\n        mxIsChar_is_not_supported_in_Simulink_Coder\n\n#define mxIsClass(pa,class) \\\n        mxIsClass_is_not_supported_in_Simulink_Coder\n\n#define mxIsCell(pa) \\\n        mxIsCell_is_not_supported_in_Simulink_Coder\n\n#define mxSetCell(pa,i,value) \\\n        mxSetCell_is_not_supported_in_Simulink_Coder\n\n#define mxSetClassName(pa,classname) \\\n        mxSetClassName_is_not_supported_in_Simulink_Coder\n\n#define mxSetData(pa,pr) \\\n        mxSetData_is_not_supported_in_Simulink_Coder\n\n#define mxSetDimensions(pa, size, ndims) \\\n        mxSetDimensions_is_not_supported_in_Simulink_Coder\n\n#define mxSetField(pa,i,fieldname,value) \\\n        mxSetField_is_not_supported_in_Simulink_Coder\n\n#define mxSetFieldByNumber(pa, index, fieldnum, value) \\\n        mxSetFieldByNumber_is_not_supported_in_Simulink_Coder\n\n#define mxSetFromGlobalWS(pa,global) \\\n        mxSetFromGlobalWS_is_not_supported_in_Simulink_Coder\n\n#define mxSetImagData(pa,pv) \\\n        mxSetImagData_is_not_supported_in_Simulink_Coder\n\n#define mxSetIr(ppa,ir) \\\n        mxSetIr_is_not_supported_in_Simulink_Coder\n\n#define mxSetJc(ppa,jc) \\\n        mxSetJc_is_not_supported_in_Simulink_Coder\n\n#define mxSetM(pa, m) \\\n        mxSetM_is_not_supported_in_Simulink_Coder\n\n#define mxSetN(pa, m) \\\n        mxSetN_is_not_supported_in_Simulink_Coder\n\n#define mxSetPr(pa,pr) \\\n        mxSetPr_is_not_supported_in_Simulink_Coder\n\n#define mxSetNzmax(pa,nzmax) \\\n        mxSetNzmax_is_not_supported_in_Simulink_Coder\n\n#define mxSetPi(pa,pv) \\\n        mxSetPi_is_not_supported_in_Simulink_Coder\n\n\n\n/*==========================*\n * Unsupported mex routines *\n *==========================*/\n\n#define mexPrintAssertion(test,fname,linenum,message) \\\n        mexPrintAssertion_is_not_supported_by_Simulink_Coder\n\n#define mexEvalString(str) \\\n        mexEvalString_is_not_supported_by_Simulink_Coder\n\n#define mexErrMsgTxt(str) \\\n        mexErrMsgTxt_is_not_supported_by_Simulink_Coder\n\n#define mexWarnMsgTxt(warning_msg) \\\n        mexWarnMsgTxt_is_not_supported_by_Simulink_Coder\n\n#define mexPrintf \\\n        mexPrintf_is_not_supported_by_Simulink_Coder\n\n#define mexMakeArrayPersistent(pa) \\\n        mexMakeArrayPersistent_is_not_supported_by_Simulink_Coder\n\n#define mexMakeMemoryPersistent(ptr) \\\n        mexMakeMemoryPersistent_is_not_supported_by_Simulink_Coder\n\n#define mexLock() \\\n        mexLock_is_not_supported_by_Simulink_Coder\n\n#define mexUnlock() \\\n        mexUnlock_is_not_supported_by_Simulink_Coder\n\n#define mexFunctionName() \\\n        mexFunctionName_is_not_supported_by_Simulink_Coder\n\n#define mexIsLocked() \\\n        mexIsLocked_is_not_supported_by_Simulink_Coder\n\n#define mexGetFunctionHandle() \\\n        mexGetFunctionHandle_is_not_supported_by_Simulink_Coder\n\n#define mexCallMATLABFunction() \\\n        mexCallMATLABFunction_is_not_supported_by_Simulink_Coder\n\n#define mexRegisterFunction() \\\n        mexRegisterFunction_is_not_supported_by_Simulink_Coder\n\n#define mexSet(handle,property,value) \\\n        mexSet_is_not_supported_by_Simulink_Coder\n\n#define mexGet(handle,property) \\\n        mexGet_is_not_supported_by_Simulink_Coder\n\n#define mexCallMATLAB(nlhs,plhs,nrhs,prhs,fcn) \\\n        mexCallMATLAB_is_not_supported_by_Simulink_Coder\n\n#define mexSetTrapFlag(flag) \\\n        mexSetTrapFlag_is_not_supported_by_Simulink_Coder\n\n#define mexUnlink(a) \\\n        mexUnlink_is_not_supported_by_Simulink_Coderw\n\n#define mexSubsAssign(plhs,sub,nsubs,prhs) \\\n        mexSubsAssign_is_not_supported_by_Simulink_Coder\n\n#define mexSubsReference(prhs,subs,nsubs) \\\n        mexSubsReference_is_not_supported_by_Simulink_Coder\n\n#define mexPrintAssertion(test,fname,linenum,message) \\\n        mexPrintAssertion_is_not_supported_by_Simulink_Coder\n\n#define mexAddFlops(count) \\\n        mexAddFlops_is_not_supported_by_Simulink_Coder\n\n#define mexIsGlobal(pa) \\\n        mexIsGlobal_is_not_supported_by_Simulink_Coder\n\n#define mexAtExit(fcn) \\\n        mexAtExit_is_not_supported_by_Simulink_Coder\n\n/* [EOF] rt_matrx.c */\n"},{"name":"rt_printf.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2023a/rtw/c/src","tag":"","groupDisplay":"Other files","code":"/* Copyright 1994-2015 The MathWorks, Inc.\n *\n * File: rt_printf.c\n *\n * Abstract:\n *      Stub I/O printf facility for systems which don't have stdio.\n *\n */\n\n\n\n/* Function: rtPrintfNoOp ======================================================\n * Abstract:\n *      Maps ssPrintf to rtPrintfNoOp if HAVESTDIO is not defined (see\n *      simstruct.h\n */\nint rtPrintfNoOp(const char *fmt, ...)\n{\n    /* do nothing */\n    return(fmt == (const char *)0); /* use fmt to quiet unused var warning */\n}\n\n\n/* [eof] rt_printf.c */\n"},{"name":"rte_ATTN_parameters.cpp","type":"source","group":"legacy","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Other files","code":"#include \"rte_ATTN_parameters.h\"\n#include \"ATTN.h\"\n#include \"ATTN_cal.h\"\n\nextern ATTN_cal_type ATTN_cal_impl;\nnamespace slrealtime\n{\n  /* Description of SEGMENTS */\n  SegmentVector segmentInfo {\n    { (void*)&ATTN_cal_impl, (void**)&ATTN_cal, sizeof(ATTN_cal_type), 2 }\n  };\n\n  SegmentVector &getSegmentVector(void)\n  {\n    return segmentInfo;\n  }\n}                                      // slrealtime\n"},{"name":"rte_ATTN_parameters.h","type":"header","group":"other","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef _RTE_ATTN_PARAMETERS_H\n#define _RTE_ATTN_PARAMETERS_H\n#include \"rtwtypes.h\"\n#include \"SegmentInfo.hpp\"\n\nnamespace slrealtime\n{\n  SegmentVector &getSegmentVector(void);\n}                                      // slrealtime\n\n#endif\n"},{"name":"slrealtime_datatype_ground.cpp","type":"source","group":"legacy","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Other files","code":"#include \"slrtdatatypes.h\"\n\nconst serialfifoptr serialfifoground = { 0, 0, 0 };\n\nconst bcmsglist1553 bcmsg1553ground = { 0, 0, 0, 0 };\n\nconst bcstatus1553 bcstatground = { 0, 0, 0, 0, 0, 0 };\n\nconst bmmsglist1553 bmmsg1553ground = { 0, 0, 0, 0 };\n"}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true}};
=======
var dataJson = {"arch":{"ispc":false,"isunix":true,"ismac":false},"build":"ATTN","ref":false,"files":[{"name":"ATTN.cpp","type":"source","group":"model","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * ATTN.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.455\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Fri Dec  1 09:35:43 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"ATTN.h\"\n#include \"rtwtypes.h\"\n#include \"ATTN_private.h\"\n#include \"ATTN_cal.h\"\n#include <cstring>\n#include <cmath>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n/* Named constants for MATLAB Function: '<S3>/MATLAB Function2' */\nconst int32_T ATTN_CALL_EVENT = -1;\n\n/* Named constants for MATLAB Function: '<Root>/MATLAB Function' */\nconst int32_T ATTN_CALL_EVENT_n = -1;\nconst real_T ATTN_RGND = 0.0;          /* real_T ground */\n\n/* Block signals (default storage) */\nB_ATTN_T ATTN_B;\n\n/* Block states (default storage) */\nDW_ATTN_T ATTN_DW;\n\n/* Real-time model */\nRT_MODEL_ATTN_T ATTN_M_ = RT_MODEL_ATTN_T();\nRT_MODEL_ATTN_T *const ATTN_M = &ATTN_M_;\n\n/* Forward declaration for local functions */\nstatic real_T ATTN_rand(void);\n\n/*\n * System initialize for atomic system:\n *    '<S3>/MATLAB Function2'\n *    '<S4>/MATLAB Function1'\n */\nvoid ATTN_MATLABFunction2_Init(DW_MATLABFunction2_ATTN_T *localDW)\n{\n  localDW->sfEvent = ATTN_CALL_EVENT;\n  localDW->t0_not_empty = false;\n  localDW->y0_not_empty = false;\n  localDW->is_active_c3_ATTN = 0U;\n}\n\n/*\n * Output and update for atomic system:\n *    '<S3>/MATLAB Function2'\n *    '<S4>/MATLAB Function1'\n */\nvoid ATTN_MATLABFunction2(real_T rtu_trigger, real_T rtu_duration, real_T\n  rtu_amp, real_T rtu_t, B_MATLABFunction2_ATTN_T *localB,\n  DW_MATLABFunction2_ATTN_T *localDW)\n{\n  real_T increment;\n  localDW->sfEvent = ATTN_CALL_EVENT;\n  increment = rtu_amp / (rtu_duration * 1000.0 / 2.0);\n  if (rtu_trigger != 0.0) {\n    localDW->t0 = rtu_t;\n    localDW->t0_not_empty = true;\n    localB->y = 0.0;\n    localDW->y0 = 0.0;\n    localDW->y0_not_empty = true;\n  } else if (localDW->t0_not_empty) {\n    real_T tmp;\n    tmp = rtu_t - localDW->t0;\n    if (tmp <= rtu_duration / 2.0) {\n      localB->y = localDW->y0 + increment;\n      localDW->y0 = localB->y;\n    } else if (tmp <= rtu_duration) {\n      localB->y = localDW->y0 - increment;\n      increment = localB->y;\n      if (increment > 0.0) {\n        localB->y = increment;\n      } else {\n        localB->y = 0.0;\n      }\n\n      localDW->y0 = localB->y;\n    } else {\n      localB->y = 0.0;\n    }\n  } else {\n    localB->y = 0.0;\n  }\n}\n\n/* Function for MATLAB Function: '<Root>/MATLAB Function' */\nstatic real_T ATTN_rand(void)\n{\n  real_T r;\n  uint32_T u[2];\n  if (ATTN_DW.method == 4U) {\n    int32_T k;\n    uint32_T mti;\n    uint32_T y;\n    k = static_cast<int32_T>(ATTN_DW.state / 127773U);\n    mti = (ATTN_DW.state - static_cast<uint32_T>(k) * 127773U) * 16807U;\n    y = 2836U * static_cast<uint32_T>(k);\n    if (mti < y) {\n      mti = ~(y - mti) & 2147483647U;\n    } else {\n      mti -= y;\n    }\n\n    r = static_cast<real_T>(mti) * 4.6566128752457969E-10;\n    ATTN_DW.state = mti;\n  } else if (ATTN_DW.method == 5U) {\n    uint32_T mti;\n    uint32_T y;\n    mti = 69069U * ATTN_DW.state_p[0] + 1234567U;\n    y = ATTN_DW.state_p[1] << 13 ^ ATTN_DW.state_p[1];\n    y ^= y >> 17;\n    y ^= y << 5;\n    ATTN_DW.state_p[0] = mti;\n    ATTN_DW.state_p[1] = y;\n    r = static_cast<real_T>(mti + y) * 2.328306436538696E-10;\n  } else {\n    /* ========================= COPYRIGHT NOTICE ============================ */\n    /*  This is a uniform (0,1) pseudorandom number generator based on:        */\n    /*                                                                         */\n    /*  A C-program for MT19937, with initialization improved 2002/1/26.       */\n    /*  Coded by Takuji Nishimura and Makoto Matsumoto.                        */\n    /*                                                                         */\n    /*  Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,      */\n    /*  All rights reserved.                                                   */\n    /*                                                                         */\n    /*  Redistribution and use in source and binary forms, with or without     */\n    /*  modification, are permitted provided that the following conditions     */\n    /*  are met:                                                               */\n    /*                                                                         */\n    /*    1. Redistributions of source code must retain the above copyright    */\n    /*       notice, this list of conditions and the following disclaimer.     */\n    /*                                                                         */\n    /*    2. Redistributions in binary form must reproduce the above copyright */\n    /*       notice, this list of conditions and the following disclaimer      */\n    /*       in the documentation and/or other materials provided with the     */\n    /*       distribution.                                                     */\n    /*                                                                         */\n    /*    3. The names of its contributors may not be used to endorse or       */\n    /*       promote products derived from this software without specific      */\n    /*       prior written permission.                                         */\n    /*                                                                         */\n    /*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    */\n    /*  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT      */\n    /*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  */\n    /*  A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT  */\n    /*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  */\n    /*  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT       */\n    /*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  */\n    /*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  */\n    /*  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    */\n    /*  (INCLUDING  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE */\n    /*  OF THIS  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */\n    /*                                                                         */\n    /* =============================   END   ================================= */\n    int32_T exitg1;\n    do {\n      int32_T k;\n      uint32_T mti;\n      exitg1 = 0;\n      for (k = 0; k < 2; k++) {\n        uint32_T y;\n        mti = ATTN_DW.state_k[624] + 1U;\n        if (mti >= 625U) {\n          for (int32_T kk = 0; kk < 227; kk++) {\n            mti = (ATTN_DW.state_k[kk + 1] & 2147483647U) | (ATTN_DW.state_k[kk]\n              & 2147483648U);\n            if ((mti & 1U) == 0U) {\n              mti >>= 1U;\n            } else {\n              mti = mti >> 1U ^ 2567483615U;\n            }\n\n            ATTN_DW.state_k[kk] = ATTN_DW.state_k[kk + 397] ^ mti;\n          }\n\n          for (int32_T kk = 0; kk < 396; kk++) {\n            mti = (ATTN_DW.state_k[kk + 227] & 2147483648U) |\n              (ATTN_DW.state_k[kk + 228] & 2147483647U);\n            if ((mti & 1U) == 0U) {\n              mti >>= 1U;\n            } else {\n              mti = mti >> 1U ^ 2567483615U;\n            }\n\n            ATTN_DW.state_k[kk + 227] = ATTN_DW.state_k[kk] ^ mti;\n          }\n\n          mti = (ATTN_DW.state_k[623] & 2147483648U) | (ATTN_DW.state_k[0] &\n            2147483647U);\n          if ((mti & 1U) == 0U) {\n            mti >>= 1U;\n          } else {\n            mti = mti >> 1U ^ 2567483615U;\n          }\n\n          ATTN_DW.state_k[623] = ATTN_DW.state_k[396] ^ mti;\n          mti = 1U;\n        }\n\n        y = ATTN_DW.state_k[static_cast<int32_T>(mti) - 1];\n        ATTN_DW.state_k[624] = mti;\n        y ^= y >> 11U;\n        y ^= y << 7U & 2636928640U;\n        y ^= y << 15U & 4022730752U;\n        u[k] = y >> 18U ^ y;\n      }\n\n      r = (static_cast<real_T>(u[0] >> 5U) * 6.7108864E+7 + static_cast<real_T>\n           (u[1] >> 6U)) * 1.1102230246251565E-16;\n      if (r == 0.0) {\n        boolean_T b_isvalid;\n        if ((ATTN_DW.state_k[624] >= 1U) && (ATTN_DW.state_k[624] < 625U)) {\n          boolean_T exitg2;\n          b_isvalid = false;\n          k = 1;\n          exitg2 = false;\n          while ((!exitg2) && (k < 625)) {\n            if (ATTN_DW.state_k[k - 1] == 0U) {\n              k++;\n            } else {\n              b_isvalid = true;\n              exitg2 = true;\n            }\n          }\n        } else {\n          b_isvalid = false;\n        }\n\n        if (!b_isvalid) {\n          mti = 5489U;\n          ATTN_DW.state_k[0] = 5489U;\n          for (k = 0; k < 623; k++) {\n            mti = ((mti >> 30U ^ mti) * 1812433253U + static_cast<uint32_T>(k))\n              + 1U;\n            ATTN_DW.state_k[k + 1] = mti;\n          }\n\n          ATTN_DW.state_k[624] = 624U;\n        }\n      } else {\n        exitg1 = 1;\n      }\n    } while (exitg1 == 0);\n  }\n\n  return r;\n}\n\n/* Model step function */\nvoid ATTN_step(void)\n{\n  real_T b_y1;\n\n  /* Memory: '<Root>/Memory8' */\n  ATTN_B.Memory8 = ATTN_DW.Memory8_PreviousInput;\n\n  /* Memory: '<Root>/Memory2' */\n  ATTN_B.Memory2 = ATTN_DW.Memory2_PreviousInput;\n\n  /* Memory: '<Root>/Memory1' */\n  ATTN_B.Memory1 = ATTN_DW.Memory1_PreviousInput;\n\n  /* Memory: '<Root>/Memory' */\n  ATTN_B.Memory = ATTN_DW.Memory_PreviousInput;\n\n  /* S-Function (sg_IO191_setup_s): '<Root>/Setup ' */\n\n  /* Level2 S-Function Block: '<Root>/Setup ' (sg_IO191_setup_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[0];\n    sfcnOutputs(rts,0);\n  }\n\n  /* S-Function (sg_IO191_ad_s): '<Root>/Analog input ' */\n\n  /* Level2 S-Function Block: '<Root>/Analog input ' (sg_IO191_ad_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[1];\n    sfcnOutputs(rts,0);\n  }\n\n  /* DiscreteFilter: '<Root>/Discrete Filter' */\n  b_y1 = ATTN_B.lickometer_piezo;\n  b_y1 -= ATTN_cal->DiscreteFilter_DenCoef[1] * ATTN_DW.DiscreteFilter_states;\n  b_y1 /= ATTN_cal->DiscreteFilter_DenCoef[0];\n  ATTN_DW.DiscreteFilter_tmp = b_y1;\n  b_y1 = ATTN_cal->DiscreteFilter_NumCoef * ATTN_DW.DiscreteFilter_tmp;\n\n  /* DiscreteFilter: '<Root>/Discrete Filter' */\n  ATTN_B.DiscreteFilter = b_y1;\n\n  /* Memory: '<Root>/Memory11' */\n  ATTN_B.Memory11 = ATTN_DW.Memory11_PreviousInput;\n\n  /* Memory: '<Root>/Memory7' */\n  ATTN_B.Memory7 = ATTN_DW.Memory7_PreviousInput;\n\n  /* MATLAB Function: '<Root>/MATLAB Function1' incorporates:\n   *  Constant: '<Root>/Thrd'\n   */\n  ATTN_DW.sfEvent_b = ATTN_CALL_EVENT_n;\n  if (std::abs(ATTN_B.DiscreteFilter) > ATTN_cal->Thrd_Value) {\n    b_y1 = ATTN_B.Memory11 + 1.0;\n    ATTN_B.y2 = ATTN_B.Memory7;\n  } else {\n    b_y1 = 0.0;\n    ATTN_B.y2 = 0.0;\n  }\n\n  if ((b_y1 > 20.0) && (ATTN_B.Memory7 == 0.0)) {\n    ATTN_B.Lick = 1.0;\n    ATTN_B.y2 = 1.0;\n  } else {\n    ATTN_B.Lick = 0.0;\n  }\n\n  ATTN_B.y1 = b_y1;\n\n  /* End of MATLAB Function: '<Root>/MATLAB Function1' */\n\n  /* Clock: '<Root>/Clock' */\n  ATTN_B.clock_time = ATTN_M->Timing.t[0];\n\n  /* Memory: '<Root>/Memory3' */\n  ATTN_B.Memory3 = ATTN_DW.Memory3_PreviousInput;\n\n  /* Memory: '<Root>/Memory4' */\n  ATTN_B.Memory4 = ATTN_DW.Memory4_PreviousInput;\n\n  /* Memory: '<Root>/Memory9' */\n  ATTN_B.Memory9 = ATTN_DW.Memory9_PreviousInput;\n\n  /* Memory: '<Root>/Memory5' */\n  ATTN_B.Memory5 = ATTN_DW.Memory5_PreviousInput;\n\n  /* Memory: '<Root>/Memory6' */\n  ATTN_B.Memory6 = ATTN_DW.Memory6_PreviousInput;\n\n  /* Memory: '<Root>/Memory10' */\n  ATTN_B.Memory10 = ATTN_DW.Memory10_PreviousInput;\n\n  /* MATLAB Function: '<Root>/MATLAB Function' incorporates:\n   *  Constant: '<Root>/rewardDuration'\n   *  Constant: '<Root>/targetSide'\n   *  Constant: '<Root>/trainingStage'\n   *  Constant: '<Root>/triangleDuration'\n   */\n  ATTN_DW.sfEvent_e = ATTN_CALL_EVENT_n;\n  ATTN_B.counter_out = ATTN_B.Memory4 + 1.0;\n  switch (static_cast<int32_T>(ATTN_cal->trainingStage)) {\n   case 1:\n    switch (static_cast<int32_T>(ATTN_B.Memory2)) {\n     case 1:\n      ATTN_B.npxlsAcq_out = 1.0;\n      ATTN_B.state_out = 2.0;\n      ATTN_B.localTime_out = 1.0;\n      ATTN_B.trialNum_out = 1.0;\n      ATTN_B.right_trigger_out = 0.0;\n      ATTN_B.left_trigger_out = 0.0;\n      ATTN_B.numLicks_out = 0.0;\n      b_y1 = 4.0;\n      while ((b_y1 >= 9.0) || (b_y1 <= 5.0)) {\n        b_y1 = ATTN_rand();\n        b_y1 = std::log(b_y1);\n        b_y1 *= -7.0;\n      }\n\n      ATTN_B.delay_out = ATTN_B.clock_time + b_y1;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = 0.0;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 2:\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n      } else {\n        ATTN_B.state_out = 3.0;\n      }\n\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.delay_out = ATTN_B.Memory5;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 3:\n      if (ATTN_rand() <= 0.8) {\n        if (ATTN_cal->targetSide != 0.0) {\n          ATTN_B.right_trigger_out = 1.0;\n          ATTN_B.left_trigger_out = 0.0;\n        } else {\n          ATTN_B.left_trigger_out = 1.0;\n          ATTN_B.right_trigger_out = 0.0;\n        }\n\n        ATTN_B.was_target_out = 0.0;\n      } else {\n        if (ATTN_cal->targetSide != 0.0) {\n          ATTN_B.left_trigger_out = 1.0;\n          ATTN_B.right_trigger_out = 0.0;\n        } else {\n          ATTN_B.right_trigger_out = 1.0;\n          ATTN_B.left_trigger_out = 0.0;\n        }\n\n        ATTN_B.was_target_out = 1.0;\n      }\n\n      ATTN_B.state_out = 4.0;\n      ATTN_B.delay_out = ATTN_B.clock_time + 0.2;\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 4:\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n        ATTN_B.delay_out = ATTN_B.Memory5;\n      } else if (ATTN_B.Memory10 != 0.0) {\n        ATTN_B.state_out = 5.0;\n        ATTN_B.delay_out = ATTN_B.clock_time + 1.0;\n      } else {\n        ATTN_B.state_out = 6.0;\n        ATTN_B.delay_out = ATTN_B.clock_time + 1.0;\n      }\n\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.left_trigger_out = 0.0;\n      ATTN_B.right_trigger_out = 0.0;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 5:\n      ATTN_B.reward_trigger_out = 1.0;\n      ATTN_B.state_out = 6.0;\n      ATTN_B.delay_out = ATTN_B.Memory5;\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 6:\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n      } else {\n        ATTN_B.state_out = 1.0;\n      }\n\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.delay_out = ATTN_B.Memory5;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     default:\n      ATTN_B.state_out = ATTN_B.Memory2;\n      ATTN_B.localTime_out = ATTN_B.Memory1;\n      ATTN_B.trialNum_out = ATTN_B.Memory;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.delay_out = ATTN_B.Memory5;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n    }\n    break;\n\n   case 2:\n    switch (static_cast<int32_T>(ATTN_B.Memory2)) {\n     case 1:\n      ATTN_B.npxlsAcq_out = 1.0;\n      ATTN_B.state_out = 2.0;\n      ATTN_B.localTime_out = 1.0;\n      ATTN_B.trialNum_out = 1.0;\n      ATTN_B.right_trigger_out = 0.0;\n      ATTN_B.left_trigger_out = 0.0;\n      ATTN_B.numLicks_out = 0.0;\n      b_y1 = 4.0;\n      while ((b_y1 >= 9.0) || (b_y1 <= 5.0)) {\n        b_y1 = ATTN_rand();\n        b_y1 = std::log(b_y1);\n        b_y1 *= -7.0;\n      }\n\n      ATTN_B.delay_out = ATTN_B.clock_time + b_y1;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 2:\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n      } else {\n        ATTN_B.state_out = 3.0;\n      }\n\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.delay_out = ATTN_B.Memory5;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 3:\n      if (ATTN_rand() <= 0.5) {\n        if (ATTN_cal->targetSide != 0.0) {\n          ATTN_B.right_trigger_out = 1.0;\n          ATTN_B.left_trigger_out = 0.0;\n        } else {\n          ATTN_B.left_trigger_out = 1.0;\n          ATTN_B.right_trigger_out = 0.0;\n        }\n\n        ATTN_B.was_target_out = 0.0;\n      } else {\n        if (ATTN_cal->targetSide != 0.0) {\n          ATTN_B.left_trigger_out = 1.0;\n          ATTN_B.right_trigger_out = 0.0;\n        } else {\n          ATTN_B.right_trigger_out = 1.0;\n          ATTN_B.left_trigger_out = 0.0;\n        }\n\n        ATTN_B.was_target_out = 1.0;\n      }\n\n      ATTN_B.state_out = 4.0;\n      ATTN_B.delay_out = ATTN_B.clock_time + 0.2;\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 4:\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n        ATTN_B.delay_out = ATTN_B.Memory5;\n      } else {\n        ATTN_B.state_out = 5.0;\n        ATTN_B.delay_out = ATTN_B.clock_time + 1.5;\n      }\n\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.left_trigger_out = 0.0;\n      ATTN_B.right_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 5:\n      if (ATTN_B.Lick != 0.0) {\n        ATTN_B.numLicks_out = ATTN_B.Memory9 + 1.0;\n      } else {\n        ATTN_B.numLicks_out = ATTN_B.Memory9;\n      }\n\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n      } else if ((ATTN_B.Memory9 != 0.0) && (ATTN_B.Memory10 != 0.0)) {\n        ATTN_B.state_out = 6.0;\n      } else {\n        ATTN_B.state_out = 1.0;\n      }\n\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.delay_out = ATTN_B.Memory5;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 6:\n      ATTN_B.reward_trigger_out = 1.0;\n      ATTN_B.state_out = 7.0;\n      ATTN_B.delay_out = ATTN_B.clock_time + 0.5;\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 7:\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n      } else {\n        ATTN_B.state_out = 1.0;\n      }\n\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.delay_out = ATTN_B.Memory5;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     default:\n      ATTN_B.state_out = ATTN_B.Memory2;\n      ATTN_B.localTime_out = ATTN_B.Memory1;\n      ATTN_B.trialNum_out = ATTN_B.Memory;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.delay_out = ATTN_B.Memory5;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n    }\n    break;\n\n   case 3:\n    switch (static_cast<int32_T>(ATTN_B.Memory2)) {\n     case 1:\n      ATTN_B.npxlsAcq_out = 1.0;\n      ATTN_B.state_out = 2.0;\n      ATTN_B.localTime_out = 1.0;\n      ATTN_B.trialNum_out = 1.0;\n      ATTN_B.right_trigger_out = 0.0;\n      ATTN_B.left_trigger_out = 0.0;\n      if ((!(ATTN_B.Memory10 != 0.0)) && (!(ATTN_B.Memory9 != 0.0))) {\n        b_y1 = 1.0;\n        while ((b_y1 >= 4.0) || (b_y1 <= 2.0)) {\n          b_y1 = ATTN_rand();\n          b_y1 = std::log(b_y1);\n          b_y1 *= -3.0;\n        }\n\n        ATTN_B.delay_out = ATTN_B.clock_time + b_y1;\n      } else {\n        b_y1 = 4.0;\n        while ((b_y1 >= 9.0) || (b_y1 <= 5.0)) {\n          b_y1 = ATTN_rand();\n          b_y1 = std::log(b_y1);\n          b_y1 *= -7.0;\n        }\n\n        ATTN_B.delay_out = ATTN_B.clock_time + b_y1;\n      }\n\n      ATTN_B.numLicks_out = 0.0;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = 0.0;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 2:\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n      } else {\n        ATTN_B.state_out = 3.0;\n      }\n\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.delay_out = ATTN_B.Memory5;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 3:\n      if (ATTN_rand() <= 0.8) {\n        if (ATTN_cal->targetSide != 0.0) {\n          ATTN_B.right_trigger_out = 1.0;\n          ATTN_B.left_trigger_out = 0.0;\n        } else {\n          ATTN_B.left_trigger_out = 1.0;\n          ATTN_B.right_trigger_out = 0.0;\n        }\n\n        ATTN_B.was_target_out = 0.0;\n      } else {\n        if (ATTN_cal->targetSide != 0.0) {\n          ATTN_B.left_trigger_out = 1.0;\n          ATTN_B.right_trigger_out = 0.0;\n        } else {\n          ATTN_B.right_trigger_out = 1.0;\n          ATTN_B.left_trigger_out = 0.0;\n        }\n\n        ATTN_B.was_target_out = 1.0;\n      }\n\n      ATTN_B.state_out = 4.0;\n      ATTN_B.delay_out = ATTN_B.clock_time + 0.2;\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 4:\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n        ATTN_B.delay_out = ATTN_B.Memory5;\n      } else {\n        ATTN_B.state_out = 5.0;\n        ATTN_B.delay_out = ATTN_B.clock_time + 1.0;\n      }\n\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.left_trigger_out = 0.0;\n      ATTN_B.right_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 5:\n      if ((ATTN_B.Memory10 != 0.0) && (ATTN_rand() < 0.2)) {\n        ATTN_B.numLicks_out = ATTN_B.Memory9 + 1.0;\n      } else if ((!(ATTN_B.Memory10 != 0.0)) && (ATTN_rand() < 0.001)) {\n        ATTN_B.numLicks_out = ATTN_B.Memory9 + 1.0;\n      } else {\n        ATTN_B.numLicks_out = ATTN_B.Memory9;\n      }\n\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n      } else if ((ATTN_B.Memory9 != 0.0) && (ATTN_B.Memory10 != 0.0)) {\n        ATTN_B.state_out = 6.0;\n      } else {\n        ATTN_B.state_out = 1.0;\n      }\n\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.delay_out = ATTN_B.Memory5;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 6:\n      ATTN_B.reward_trigger_out = 1.0;\n      ATTN_B.state_out = 7.0;\n      ATTN_B.delay_out = ATTN_B.clock_time + 0.5;\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     case 7:\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n      } else {\n        ATTN_B.state_out = 1.0;\n      }\n\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.delay_out = ATTN_B.Memory5;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n\n     default:\n      ATTN_B.state_out = ATTN_B.Memory2;\n      ATTN_B.localTime_out = ATTN_B.Memory1;\n      ATTN_B.trialNum_out = ATTN_B.Memory;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.delay_out = ATTN_B.Memory5;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n      break;\n    }\n    break;\n\n   case 111:\n    if (static_cast<int32_T>(ATTN_B.Memory2) == 1) {\n      ATTN_B.npxlsAcq_out = 0.0;\n      ATTN_B.localTime_out = 1.0;\n      ATTN_B.trialNum_out = 1.0;\n      ATTN_B.right_trigger_out = 0.0;\n      ATTN_B.left_trigger_out = 0.0;\n      ATTN_B.delay_out = ATTN_B.clock_time + 10.0;\n      ATTN_B.numLicks_out = 0.0;\n      ATTN_B.reward_trigger_out = 1.0;\n      ATTN_B.was_target_out = 0.0;\n      ATTN_B.reward_duration_out = 0.02;\n      ATTN_B.state_out = 2.0;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n    } else {\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n        ATTN_B.reward_trigger_out = 0.0;\n        ATTN_B.delay_out = ATTN_B.Memory5;\n        ATTN_B.reward_duration_out = 0.02;\n      } else {\n        ATTN_B.state_out = ATTN_B.Memory2 + 1.0;\n        ATTN_B.reward_trigger_out = 1.0;\n        ATTN_B.delay_out = ATTN_B.clock_time + 10.0;\n        ATTN_B.reward_duration_out = 0.02;\n      }\n\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.left_trigger_out = ATTN_B.Memory6;\n      ATTN_B.right_trigger_out = ATTN_B.Memory8;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n    }\n    break;\n\n   case 222:\n    if (static_cast<int32_T>(ATTN_B.Memory2) == 1) {\n      ATTN_B.npxlsAcq_out = 0.0;\n      ATTN_B.localTime_out = 1.0;\n      ATTN_B.trialNum_out = 1.0;\n      if (ATTN_cal->targetSide != 0.0) {\n        ATTN_B.right_trigger_out = 1.0;\n        ATTN_B.left_trigger_out = 0.0;\n      } else {\n        ATTN_B.left_trigger_out = 1.0;\n        ATTN_B.right_trigger_out = 0.0;\n      }\n\n      ATTN_B.delay_out = ATTN_B.clock_time + 10.0;\n      ATTN_B.numLicks_out = 0.0;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = 0.0;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.state_out = 2.0;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n    } else {\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n        ATTN_B.delay_out = ATTN_B.Memory5;\n        ATTN_B.left_trigger_out = 0.0;\n        ATTN_B.right_trigger_out = 0.0;\n      } else {\n        ATTN_B.state_out = ATTN_B.Memory2 + 1.0;\n        ATTN_B.delay_out = ATTN_B.clock_time + 10.0;\n        if (ATTN_cal->targetSide != 0.0) {\n          ATTN_B.right_trigger_out = 1.0;\n          ATTN_B.left_trigger_out = 0.0;\n        } else {\n          ATTN_B.left_trigger_out = 1.0;\n          ATTN_B.right_trigger_out = 0.0;\n        }\n      }\n\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.stim_duration_out = ATTN_cal->triangleDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n    }\n    break;\n\n   default:\n    if (static_cast<int32_T>(ATTN_B.Memory2) == 1) {\n      ATTN_B.npxlsAcq_out = 0.0;\n      ATTN_B.localTime_out = 1.0;\n      ATTN_B.trialNum_out = 1.0;\n      if (ATTN_cal->targetSide != 0.0) {\n        ATTN_B.right_trigger_out = 1.0;\n        ATTN_B.left_trigger_out = 0.0;\n      } else {\n        ATTN_B.left_trigger_out = 1.0;\n        ATTN_B.right_trigger_out = 0.0;\n      }\n\n      ATTN_B.delay_out = ATTN_B.clock_time + 10.0;\n      ATTN_B.numLicks_out = 0.0;\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.was_target_out = 0.0;\n      ATTN_B.stim_duration_out = 0.05;\n      ATTN_B.state_out = 2.0;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n    } else {\n      if (ATTN_B.clock_time < ATTN_B.Memory5) {\n        ATTN_B.state_out = ATTN_B.Memory2;\n        ATTN_B.delay_out = ATTN_B.Memory5;\n        ATTN_B.left_trigger_out = 0.0;\n        ATTN_B.right_trigger_out = 0.0;\n        ATTN_B.stim_duration_out = (ATTN_B.Memory2 - 1.0) * 0.05;\n      } else {\n        ATTN_B.state_out = ATTN_B.Memory2 + 1.0;\n        ATTN_B.delay_out = ATTN_B.clock_time + 10.0;\n        if (ATTN_cal->targetSide != 0.0) {\n          ATTN_B.right_trigger_out = 1.0;\n          ATTN_B.left_trigger_out = 0.0;\n        } else {\n          ATTN_B.left_trigger_out = 1.0;\n          ATTN_B.right_trigger_out = 0.0;\n        }\n\n        ATTN_B.stim_duration_out = 0.05 * ATTN_B.Memory2;\n      }\n\n      ATTN_B.reward_trigger_out = 0.0;\n      ATTN_B.localTime_out = ATTN_B.Memory1 + 1.0;\n      ATTN_B.trialNum_out = ATTN_B.Memory + 1.0;\n      ATTN_B.npxlsAcq_out = ATTN_B.Memory3;\n      ATTN_B.numLicks_out = ATTN_B.Memory9;\n      ATTN_B.was_target_out = ATTN_B.Memory10;\n      ATTN_B.reward_duration_out = ATTN_cal->rewardDuration;\n      ATTN_B.onsetTone_trig = 0.0;\n    }\n    break;\n  }\n\n  /* End of MATLAB Function: '<Root>/MATLAB Function' */\n\n  /* Clock: '<S4>/Clock1' */\n  ATTN_B.Clock1 = ATTN_M->Timing.t[0];\n\n  /* MATLAB Function: '<S4>/MATLAB Function1' incorporates:\n   *  Constant: '<Root>/triangleAmplitude'\n   */\n  ATTN_MATLABFunction2(ATTN_B.Memory8, ATTN_B.stim_duration_out,\n                       ATTN_cal->triangleAmplitude, ATTN_B.Clock1,\n                       &ATTN_B.sf_MATLABFunction1_d,\n                       &ATTN_DW.sf_MATLABFunction1_d);\n\n  /* Clock: '<S3>/Clock2' */\n  ATTN_B.Clock2 = ATTN_M->Timing.t[0];\n\n  /* MATLAB Function: '<S3>/MATLAB Function2' incorporates:\n   *  Constant: '<Root>/triangleAmplitude'\n   */\n  ATTN_MATLABFunction2(ATTN_B.Memory6, ATTN_B.stim_duration_out,\n                       ATTN_cal->triangleAmplitude, ATTN_B.Clock2,\n                       &ATTN_B.sf_MATLABFunction2, &ATTN_DW.sf_MATLABFunction2);\n\n  /* S-Function (sg_IO191_da_s): '<Root>/Analog output ' */\n\n  /* Level2 S-Function Block: '<Root>/Analog output ' (sg_IO191_da_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[2];\n    sfcnOutputs(rts,0);\n  }\n\n  /* DiscretePulseGenerator: '<Root>/Whisker Trig' */\n  b_y1 = ATTN_cal->T_whisk / 2.0;\n\n  /* DiscretePulseGenerator: '<Root>/Whisker Trig' */\n  ATTN_B.whiskCam_trig = (ATTN_DW.clockTickCounter < b_y1) &&\n    (ATTN_DW.clockTickCounter >= 0) ? ATTN_cal->WhiskerTrig_Amp : 0.0;\n\n  /* DiscretePulseGenerator: '<Root>/Whisker Trig' */\n  if (ATTN_DW.clockTickCounter >= ATTN_cal->T_whisk - 1.0) {\n    ATTN_DW.clockTickCounter = 0;\n  } else {\n    ATTN_DW.clockTickCounter++;\n  }\n\n  /* DiscretePulseGenerator: '<Root>/Npxls Trig' */\n  b_y1 = ATTN_cal->T_npxls / 2.0;\n\n  /* DiscretePulseGenerator: '<Root>/Npxls Trig' */\n  ATTN_B.npxls_trig = (ATTN_DW.clockTickCounter_n < b_y1) &&\n    (ATTN_DW.clockTickCounter_n >= 0) ? ATTN_cal->NpxlsTrig_Amp : 0.0;\n\n  /* DiscretePulseGenerator: '<Root>/Npxls Trig' */\n  if (ATTN_DW.clockTickCounter_n >= ATTN_cal->T_npxls - 1.0) {\n    ATTN_DW.clockTickCounter_n = 0;\n  } else {\n    ATTN_DW.clockTickCounter_n++;\n  }\n\n  /* DiscretePulseGenerator: '<Root>/Pupil Trig' */\n  b_y1 = ATTN_cal->T_pupil / 2.0;\n\n  /* DiscretePulseGenerator: '<Root>/Pupil Trig' */\n  ATTN_B.pupilCam_trig = (ATTN_DW.clockTickCounter_c < b_y1) &&\n    (ATTN_DW.clockTickCounter_c >= 0) ? ATTN_cal->PupilTrig_Amp : 0.0;\n\n  /* DiscretePulseGenerator: '<Root>/Pupil Trig' */\n  if (ATTN_DW.clockTickCounter_c >= ATTN_cal->T_pupil - 1.0) {\n    ATTN_DW.clockTickCounter_c = 0;\n  } else {\n    ATTN_DW.clockTickCounter_c++;\n  }\n\n  /* Clock: '<S5>/Clock1' */\n  ATTN_B.Clock1_b = ATTN_M->Timing.t[0];\n\n  /* MATLAB Function: '<S5>/MATLAB Function1' incorporates:\n   *  Constant: '<S5>/Constant4'\n   */\n  ATTN_DW.sfEvent_a = ATTN_CALL_EVENT_n;\n  if (ATTN_B.reward_trigger_out != 0.0) {\n    ATTN_DW.t0_p = ATTN_B.Clock1_b;\n    ATTN_DW.t0_not_empty_p = true;\n    ATTN_B.y = ATTN_cal->Constant4_Value;\n  } else if (ATTN_DW.t0_not_empty_p) {\n    if (ATTN_B.Clock1_b - ATTN_DW.t0_p <= ATTN_B.reward_duration_out) {\n      ATTN_B.y = ATTN_cal->Constant4_Value;\n    } else {\n      ATTN_B.y = 0.0;\n    }\n  } else {\n    ATTN_B.y = 0.0;\n  }\n\n  /* End of MATLAB Function: '<S5>/MATLAB Function1' */\n\n  /* Clock: '<S6>/Clock1' */\n  ATTN_B.Clock1_l = ATTN_M->Timing.t[0];\n\n  /* MATLAB Function: '<S6>/MATLAB Function1' */\n  ATTN_DW.sfEvent = ATTN_CALL_EVENT_n;\n  if (ATTN_B.onsetTone_trig != 0.0) {\n    ATTN_B.tonePulse = 1.0;\n    ATTN_DW.t0 = ATTN_B.Clock1_l;\n    ATTN_DW.t0_not_empty = true;\n  } else if (ATTN_DW.t0_not_empty) {\n    ATTN_B.tonePulse = (ATTN_B.Clock1_l - ATTN_DW.t0 < 1.5);\n  } else {\n    ATTN_B.tonePulse = 0.0;\n  }\n\n  /* End of MATLAB Function: '<S6>/MATLAB Function1' */\n\n  /* S-Function (sg_IO191_do_s): '<Root>/Digital output ' */\n\n  /* Level2 S-Function Block: '<Root>/Digital output ' (sg_IO191_do_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[3];\n    sfcnOutputs(rts,0);\n  }\n\n  /* S-Function (sg_IO191_di_s): '<Root>/Digital input ' */\n\n  /* Level2 S-Function Block: '<Root>/Digital input ' (sg_IO191_di_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[4];\n    sfcnOutputs(rts,0);\n  }\n\n  /* RateTransition generated from: '<Root>/Digital input ' */\n  ATTN_B.HiddenRateTransitionForToWks_In = ATTN_B.PulseGen1Hz;\n\n  /* RelationalOperator: '<Root>/Relational Operator' incorporates:\n   *  Constant: '<Root>/Constant'\n   */\n  ATTN_B.RelationalOperator = (ATTN_B.counter_out >= ATTN_cal->maxFrame);\n\n  /* Stop: '<Root>/Stop Simulation' */\n  if (ATTN_B.RelationalOperator) {\n    rtmSetStopRequested(ATTN_M, 1);\n  }\n\n  /* End of Stop: '<Root>/Stop Simulation' */\n\n  /* Update for Memory: '<Root>/Memory8' */\n  ATTN_DW.Memory8_PreviousInput = ATTN_B.right_trigger_out;\n\n  /* Update for Memory: '<Root>/Memory2' */\n  ATTN_DW.Memory2_PreviousInput = ATTN_B.state_out;\n\n  /* Update for Memory: '<Root>/Memory1' */\n  ATTN_DW.Memory1_PreviousInput = ATTN_B.localTime_out;\n\n  /* Update for Memory: '<Root>/Memory' */\n  ATTN_DW.Memory_PreviousInput = ATTN_B.trialNum_out;\n\n  /* Update for DiscreteFilter: '<Root>/Discrete Filter' */\n  ATTN_DW.DiscreteFilter_states = ATTN_DW.DiscreteFilter_tmp;\n\n  /* Update for Memory: '<Root>/Memory11' */\n  ATTN_DW.Memory11_PreviousInput = ATTN_B.y1;\n\n  /* Update for Memory: '<Root>/Memory7' */\n  ATTN_DW.Memory7_PreviousInput = ATTN_B.y2;\n\n  /* Update for Memory: '<Root>/Memory3' */\n  ATTN_DW.Memory3_PreviousInput = ATTN_B.npxlsAcq_out;\n\n  /* Update for Memory: '<Root>/Memory4' */\n  ATTN_DW.Memory4_PreviousInput = ATTN_B.counter_out;\n\n  /* Update for Memory: '<Root>/Memory9' */\n  ATTN_DW.Memory9_PreviousInput = ATTN_B.numLicks_out;\n\n  /* Update for Memory: '<Root>/Memory5' */\n  ATTN_DW.Memory5_PreviousInput = ATTN_B.delay_out;\n\n  /* Update for Memory: '<Root>/Memory6' */\n  ATTN_DW.Memory6_PreviousInput = ATTN_B.left_trigger_out;\n\n  /* Update for Memory: '<Root>/Memory10' */\n  ATTN_DW.Memory10_PreviousInput = ATTN_B.was_target_out;\n\n  /* Update absolute time for base rate */\n  /* The \"clockTick0\" counts the number of times the code of this task has\n   * been executed. The absolute time is the multiplication of \"clockTick0\"\n   * and \"Timing.stepSize0\". Size of \"clockTick0\" ensures timer will not\n   * overflow during the application lifespan selected.\n   * Timer of this task consists of two 32 bit unsigned integers.\n   * The two integers represent the low bits Timing.clockTick0 and the high bits\n   * Timing.clockTickH0. When the low bit overflows to 0, the high bits increment.\n   */\n  if (!(++ATTN_M->Timing.clockTick0)) {\n    ++ATTN_M->Timing.clockTickH0;\n  }\n\n  ATTN_M->Timing.t[0] = ATTN_M->Timing.clockTick0 * ATTN_M->Timing.stepSize0 +\n    ATTN_M->Timing.clockTickH0 * ATTN_M->Timing.stepSize0 * 4294967296.0;\n\n  {\n    /* Update absolute timer for sample time: [0.001s, 0.0s] */\n    /* The \"clockTick1\" counts the number of times the code of this task has\n     * been executed. The absolute time is the multiplication of \"clockTick1\"\n     * and \"Timing.stepSize1\". Size of \"clockTick1\" ensures timer will not\n     * overflow during the application lifespan selected.\n     * Timer of this task consists of two 32 bit unsigned integers.\n     * The two integers represent the low bits Timing.clockTick1 and the high bits\n     * Timing.clockTickH1. When the low bit overflows to 0, the high bits increment.\n     */\n    if (!(++ATTN_M->Timing.clockTick1)) {\n      ++ATTN_M->Timing.clockTickH1;\n    }\n\n    ATTN_M->Timing.t[1] = ATTN_M->Timing.clockTick1 * ATTN_M->Timing.stepSize1 +\n      ATTN_M->Timing.clockTickH1 * ATTN_M->Timing.stepSize1 * 4294967296.0;\n  }\n}\n\n/* Model initialize function */\nvoid ATTN_initialize(void)\n{\n  /* Registration code */\n\n  /* initialize non-finites */\n  rt_InitInfAndNaN(sizeof(real_T));\n\n  {\n    /* Setup solver object */\n    rtsiSetSimTimeStepPtr(&ATTN_M->solverInfo, &ATTN_M->Timing.simTimeStep);\n    rtsiSetTPtr(&ATTN_M->solverInfo, &rtmGetTPtr(ATTN_M));\n    rtsiSetStepSizePtr(&ATTN_M->solverInfo, &ATTN_M->Timing.stepSize0);\n    rtsiSetErrorStatusPtr(&ATTN_M->solverInfo, (&rtmGetErrorStatus(ATTN_M)));\n    rtsiSetRTModelPtr(&ATTN_M->solverInfo, ATTN_M);\n  }\n\n  rtsiSetSimTimeStep(&ATTN_M->solverInfo, MAJOR_TIME_STEP);\n  rtsiSetSolverName(&ATTN_M->solverInfo,\"FixedStepDiscrete\");\n  ATTN_M->solverInfoPtr = (&ATTN_M->solverInfo);\n\n  /* Initialize timing info */\n  {\n    int_T *mdlTsMap = ATTN_M->Timing.sampleTimeTaskIDArray;\n    mdlTsMap[0] = 0;\n    mdlTsMap[1] = 1;\n\n    /* polyspace +2 MISRA2012:D4.1 [Justified:Low] \"ATTN_M points to\n       static memory which is guaranteed to be non-NULL\" */\n    ATTN_M->Timing.sampleTimeTaskIDPtr = (&mdlTsMap[0]);\n    ATTN_M->Timing.sampleTimes = (&ATTN_M->Timing.sampleTimesArray[0]);\n    ATTN_M->Timing.offsetTimes = (&ATTN_M->Timing.offsetTimesArray[0]);\n\n    /* task periods */\n    ATTN_M->Timing.sampleTimes[0] = (0.0);\n    ATTN_M->Timing.sampleTimes[1] = (0.001);\n\n    /* task offsets */\n    ATTN_M->Timing.offsetTimes[0] = (0.0);\n    ATTN_M->Timing.offsetTimes[1] = (0.0);\n  }\n\n  rtmSetTPtr(ATTN_M, &ATTN_M->Timing.tArray[0]);\n\n  {\n    int_T *mdlSampleHits = ATTN_M->Timing.sampleHitArray;\n    mdlSampleHits[0] = 1;\n    mdlSampleHits[1] = 1;\n    ATTN_M->Timing.sampleHits = (&mdlSampleHits[0]);\n  }\n\n  rtmSetTFinal(ATTN_M, -1);\n  ATTN_M->Timing.stepSize0 = 0.001;\n  ATTN_M->Timing.stepSize1 = 0.001;\n  ATTN_M->solverInfoPtr = (&ATTN_M->solverInfo);\n  ATTN_M->Timing.stepSize = (0.001);\n  rtsiSetFixedStepSize(&ATTN_M->solverInfo, 0.001);\n  rtsiSetSolverMode(&ATTN_M->solverInfo, SOLVER_MODE_SINGLETASKING);\n\n  /* block I/O */\n  (void) std::memset((static_cast<void *>(&ATTN_B)), 0,\n                     sizeof(B_ATTN_T));\n\n  /* states (dwork) */\n  (void) std::memset(static_cast<void *>(&ATTN_DW), 0,\n                     sizeof(DW_ATTN_T));\n\n  /* child S-Function registration */\n  {\n    RTWSfcnInfo *sfcnInfo = &ATTN_M->NonInlinedSFcns.sfcnInfo;\n    ATTN_M->sfcnInfo = (sfcnInfo);\n    rtssSetErrorStatusPtr(sfcnInfo, (&rtmGetErrorStatus(ATTN_M)));\n    ATTN_M->Sizes.numSampTimes = (2);\n    rtssSetNumRootSampTimesPtr(sfcnInfo, &ATTN_M->Sizes.numSampTimes);\n    ATTN_M->NonInlinedSFcns.taskTimePtrs[0] = (&rtmGetTPtr(ATTN_M)[0]);\n    ATTN_M->NonInlinedSFcns.taskTimePtrs[1] = (&rtmGetTPtr(ATTN_M)[1]);\n    rtssSetTPtrPtr(sfcnInfo,ATTN_M->NonInlinedSFcns.taskTimePtrs);\n    rtssSetTStartPtr(sfcnInfo, &rtmGetTStart(ATTN_M));\n    rtssSetTFinalPtr(sfcnInfo, &rtmGetTFinal(ATTN_M));\n    rtssSetTimeOfLastOutputPtr(sfcnInfo, &rtmGetTimeOfLastOutput(ATTN_M));\n    rtssSetStepSizePtr(sfcnInfo, &ATTN_M->Timing.stepSize);\n    rtssSetStopRequestedPtr(sfcnInfo, &rtmGetStopRequested(ATTN_M));\n    rtssSetDerivCacheNeedsResetPtr(sfcnInfo, &ATTN_M->derivCacheNeedsReset);\n    rtssSetZCCacheNeedsResetPtr(sfcnInfo, &ATTN_M->zCCacheNeedsReset);\n    rtssSetContTimeOutputInconsistentWithStateAtMajorStepPtr(sfcnInfo,\n      &ATTN_M->CTOutputIncnstWithState);\n    rtssSetSampleHitsPtr(sfcnInfo, &ATTN_M->Timing.sampleHits);\n    rtssSetPerTaskSampleHitsPtr(sfcnInfo, &ATTN_M->Timing.perTaskSampleHits);\n    rtssSetSimModePtr(sfcnInfo, &ATTN_M->simMode);\n    rtssSetSolverInfoPtr(sfcnInfo, &ATTN_M->solverInfoPtr);\n  }\n\n  ATTN_M->Sizes.numSFcns = (5);\n\n  /* register each child */\n  {\n    (void) std::memset(static_cast<void *>\n                       (&ATTN_M->NonInlinedSFcns.childSFunctions[0]), 0,\n                       5*sizeof(SimStruct));\n    ATTN_M->childSfunctions = (&ATTN_M->NonInlinedSFcns.childSFunctionPtrs[0]);\n\n    {\n      int_T i;\n      for (i = 0; i < 5; i++) {\n        ATTN_M->childSfunctions[i] = (&ATTN_M->NonInlinedSFcns.childSFunctions[i]);\n      }\n    }\n\n    /* Level2 S-Function Block: ATTN/<Root>/Setup  (sg_IO191_setup_s) */\n    {\n      SimStruct *rts = ATTN_M->childSfunctions[0];\n\n      /* timing info */\n      time_T *sfcnPeriod = ATTN_M->NonInlinedSFcns.Sfcn0.sfcnPeriod;\n      time_T *sfcnOffset = ATTN_M->NonInlinedSFcns.Sfcn0.sfcnOffset;\n      int_T *sfcnTsMap = ATTN_M->NonInlinedSFcns.Sfcn0.sfcnTsMap;\n      (void) std::memset(static_cast<void*>(sfcnPeriod), 0,\n                         sizeof(time_T)*1);\n      (void) std::memset(static_cast<void*>(sfcnOffset), 0,\n                         sizeof(time_T)*1);\n      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);\n      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);\n      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);\n\n      {\n        ssSetBlkInfo2Ptr(rts, &ATTN_M->NonInlinedSFcns.blkInfo2[0]);\n      }\n\n      _ssSetBlkInfo2PortInfo2Ptr(rts,\n        &ATTN_M->NonInlinedSFcns.inputOutputPortInfo2[0]);\n\n      /* Set up the mdlInfo pointer */\n      ssSetRTWSfcnInfo(rts, ATTN_M->sfcnInfo);\n\n      /* Allocate memory of model methods 2 */\n      {\n        ssSetModelMethods2(rts, &ATTN_M->NonInlinedSFcns.methods2[0]);\n      }\n\n      /* Allocate memory of model methods 3 */\n      {\n        ssSetModelMethods3(rts, &ATTN_M->NonInlinedSFcns.methods3[0]);\n      }\n\n      /* Allocate memory of model methods 4 */\n      {\n        ssSetModelMethods4(rts, &ATTN_M->NonInlinedSFcns.methods4[0]);\n      }\n\n      /* Allocate memory for states auxilliary information */\n      {\n        ssSetStatesInfo2(rts, &ATTN_M->NonInlinedSFcns.statesInfo2[0]);\n        ssSetPeriodicStatesInfo(rts, &ATTN_M->\n          NonInlinedSFcns.periodicStatesInfo[0]);\n      }\n\n      /* path info */\n      ssSetModelName(rts, \"Setup \");\n      ssSetPath(rts, \"ATTN/Setup \");\n      ssSetRTModel(rts,ATTN_M);\n      ssSetParentSS(rts, (NULL));\n      ssSetRootSS(rts, rts);\n      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);\n\n      /* parameters */\n      {\n        mxArray **sfcnParams = (mxArray **)\n          &ATTN_M->NonInlinedSFcns.Sfcn0.params;\n        ssSetSFcnParamsCount(rts, 9);\n        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);\n        ssSetSFcnParam(rts, 0, (mxArray*)ATTN_cal->Setup_P1_Size);\n        ssSetSFcnParam(rts, 1, (mxArray*)ATTN_cal->Setup_P2_Size);\n        ssSetSFcnParam(rts, 2, (mxArray*)ATTN_cal->Setup_P3_Size);\n        ssSetSFcnParam(rts, 3, (mxArray*)ATTN_cal->Setup_P4_Size);\n        ssSetSFcnParam(rts, 4, (mxArray*)ATTN_cal->Setup_P5_Size);\n        ssSetSFcnParam(rts, 5, (mxArray*)ATTN_cal->Setup_P6_Size);\n        ssSetSFcnParam(rts, 6, (mxArray*)ATTN_cal->Setup_P7_Size);\n        ssSetSFcnParam(rts, 7, (mxArray*)ATTN_cal->Setup_P8_Size);\n        ssSetSFcnParam(rts, 8, (mxArray*)ATTN_cal->Setup_P9_Size);\n      }\n\n      /* work vectors */\n      ssSetRWork(rts, (real_T *) &ATTN_DW.Setup_RWORK[0]);\n      ssSetPWork(rts, (void **) &ATTN_DW.Setup_PWORK);\n\n      {\n        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)\n          &ATTN_M->NonInlinedSFcns.Sfcn0.dWork;\n        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)\n          &ATTN_M->NonInlinedSFcns.Sfcn0.dWorkAux;\n        ssSetSFcnDWork(rts, dWorkRecord);\n        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);\n        ssSetNumDWorkAsInt(rts, 2);\n\n        /* RWORK */\n        ssSetDWorkWidthAsInt(rts, 0, 2);\n        ssSetDWorkDataType(rts, 0,SS_DOUBLE);\n        ssSetDWorkComplexSignal(rts, 0, 0);\n        ssSetDWork(rts, 0, &ATTN_DW.Setup_RWORK[0]);\n\n        /* PWORK */\n        ssSetDWorkWidthAsInt(rts, 1, 1);\n        ssSetDWorkDataType(rts, 1,SS_POINTER);\n        ssSetDWorkComplexSignal(rts, 1, 0);\n        ssSetDWork(rts, 1, &ATTN_DW.Setup_PWORK);\n      }\n\n      /* registration */\n      sg_IO191_setup_s(rts);\n      sfcnInitializeSizes(rts);\n      sfcnInitializeSampleTimes(rts);\n\n      /* adjust sample time */\n      ssSetSampleTime(rts, 0, 0.001);\n      ssSetOffsetTime(rts, 0, 0.0);\n      sfcnTsMap[0] = 1;\n\n      /* set compiled values of dynamic vector attributes */\n      ssSetNumNonsampledZCsAsInt(rts, 0);\n\n      /* Update connectivity flags for each port */\n      /* Update the BufferDstPort flags for each input port */\n    }\n\n    /* Level2 S-Function Block: ATTN/<Root>/Analog input  (sg_IO191_ad_s) */\n    {\n      SimStruct *rts = ATTN_M->childSfunctions[1];\n\n      /* timing info */\n      time_T *sfcnPeriod = ATTN_M->NonInlinedSFcns.Sfcn1.sfcnPeriod;\n      time_T *sfcnOffset = ATTN_M->NonInlinedSFcns.Sfcn1.sfcnOffset;\n      int_T *sfcnTsMap = ATTN_M->NonInlinedSFcns.Sfcn1.sfcnTsMap;\n      (void) std::memset(static_cast<void*>(sfcnPeriod), 0,\n                         sizeof(time_T)*1);\n      (void) std::memset(static_cast<void*>(sfcnOffset), 0,\n                         sizeof(time_T)*1);\n      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);\n      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);\n      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);\n\n      {\n        ssSetBlkInfo2Ptr(rts, &ATTN_M->NonInlinedSFcns.blkInfo2[1]);\n      }\n\n      _ssSetBlkInfo2PortInfo2Ptr(rts,\n        &ATTN_M->NonInlinedSFcns.inputOutputPortInfo2[1]);\n\n      /* Set up the mdlInfo pointer */\n      ssSetRTWSfcnInfo(rts, ATTN_M->sfcnInfo);\n\n      /* Allocate memory of model methods 2 */\n      {\n        ssSetModelMethods2(rts, &ATTN_M->NonInlinedSFcns.methods2[1]);\n      }\n\n      /* Allocate memory of model methods 3 */\n      {\n        ssSetModelMethods3(rts, &ATTN_M->NonInlinedSFcns.methods3[1]);\n      }\n\n      /* Allocate memory of model methods 4 */\n      {\n        ssSetModelMethods4(rts, &ATTN_M->NonInlinedSFcns.methods4[1]);\n      }\n\n      /* Allocate memory for states auxilliary information */\n      {\n        ssSetStatesInfo2(rts, &ATTN_M->NonInlinedSFcns.statesInfo2[1]);\n        ssSetPeriodicStatesInfo(rts, &ATTN_M->\n          NonInlinedSFcns.periodicStatesInfo[1]);\n      }\n\n      /* outputs */\n      {\n        ssSetPortInfoForOutputs(rts,\n          &ATTN_M->NonInlinedSFcns.Sfcn1.outputPortInfo[0]);\n        ssSetPortInfoForOutputs(rts,\n          &ATTN_M->NonInlinedSFcns.Sfcn1.outputPortInfo[0]);\n        _ssSetNumOutputPorts(rts, 2);\n        _ssSetPortInfo2ForOutputUnits(rts,\n          &ATTN_M->NonInlinedSFcns.Sfcn1.outputPortUnits[0]);\n        ssSetOutputPortUnit(rts, 0, 0);\n        ssSetOutputPortUnit(rts, 1, 0);\n        _ssSetPortInfo2ForOutputCoSimAttribute(rts,\n          &ATTN_M->NonInlinedSFcns.Sfcn1.outputPortCoSimAttribute[0]);\n        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);\n        ssSetOutputPortIsContinuousQuantity(rts, 1, 0);\n\n        /* port 0 */\n        {\n          _ssSetOutputPortNumDimensions(rts, 0, 1);\n          ssSetOutputPortWidthAsInt(rts, 0, 1);\n          ssSetOutputPortSignal(rts, 0, ((real_T *) &ATTN_B.Analoginput_o1));\n        }\n\n        /* port 1 */\n        {\n          _ssSetOutputPortNumDimensions(rts, 1, 1);\n          ssSetOutputPortWidthAsInt(rts, 1, 1);\n          ssSetOutputPortSignal(rts, 1, ((real_T *) &ATTN_B.lickometer_piezo));\n        }\n      }\n\n      /* path info */\n      ssSetModelName(rts, \"Analog input \");\n      ssSetPath(rts, \"ATTN/Analog input \");\n      ssSetRTModel(rts,ATTN_M);\n      ssSetParentSS(rts, (NULL));\n      ssSetRootSS(rts, rts);\n      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);\n\n      /* parameters */\n      {\n        mxArray **sfcnParams = (mxArray **)\n          &ATTN_M->NonInlinedSFcns.Sfcn1.params;\n        ssSetSFcnParamsCount(rts, 9);\n        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);\n        ssSetSFcnParam(rts, 0, (mxArray*)ATTN_cal->Analoginput_P1_Size);\n        ssSetSFcnParam(rts, 1, (mxArray*)ATTN_cal->Analoginput_P2_Size);\n        ssSetSFcnParam(rts, 2, (mxArray*)ATTN_cal->Analoginput_P3_Size);\n        ssSetSFcnParam(rts, 3, (mxArray*)ATTN_cal->Analoginput_P4_Size);\n        ssSetSFcnParam(rts, 4, (mxArray*)ATTN_cal->Analoginput_P5_Size);\n        ssSetSFcnParam(rts, 5, (mxArray*)ATTN_cal->Analoginput_P6_Size);\n        ssSetSFcnParam(rts, 6, (mxArray*)ATTN_cal->Analoginput_P7_Size);\n        ssSetSFcnParam(rts, 7, (mxArray*)ATTN_cal->Analoginput_P8_Size);\n        ssSetSFcnParam(rts, 8, (mxArray*)ATTN_cal->Analoginput_P9_Size);\n      }\n\n      /* work vectors */\n      ssSetIWork(rts, (int_T *) &ATTN_DW.Analoginput_IWORK[0]);\n      ssSetPWork(rts, (void **) &ATTN_DW.Analoginput_PWORK);\n\n      {\n        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)\n          &ATTN_M->NonInlinedSFcns.Sfcn1.dWork;\n        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)\n          &ATTN_M->NonInlinedSFcns.Sfcn1.dWorkAux;\n        ssSetSFcnDWork(rts, dWorkRecord);\n        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);\n        ssSetNumDWorkAsInt(rts, 2);\n\n        /* IWORK */\n        ssSetDWorkWidthAsInt(rts, 0, 2);\n        ssSetDWorkDataType(rts, 0,SS_INTEGER);\n        ssSetDWorkComplexSignal(rts, 0, 0);\n        ssSetDWork(rts, 0, &ATTN_DW.Analoginput_IWORK[0]);\n\n        /* PWORK */\n        ssSetDWorkWidthAsInt(rts, 1, 1);\n        ssSetDWorkDataType(rts, 1,SS_POINTER);\n        ssSetDWorkComplexSignal(rts, 1, 0);\n        ssSetDWork(rts, 1, &ATTN_DW.Analoginput_PWORK);\n      }\n\n      /* registration */\n      sg_IO191_ad_s(rts);\n      sfcnInitializeSizes(rts);\n      sfcnInitializeSampleTimes(rts);\n\n      /* adjust sample time */\n      ssSetSampleTime(rts, 0, 0.001);\n      ssSetOffsetTime(rts, 0, 0.0);\n      sfcnTsMap[0] = 1;\n\n      /* set compiled values of dynamic vector attributes */\n      ssSetNumNonsampledZCsAsInt(rts, 0);\n\n      /* Update connectivity flags for each port */\n      _ssSetOutputPortConnected(rts, 0, 0);\n      _ssSetOutputPortConnected(rts, 1, 1);\n      _ssSetOutputPortBeingMerged(rts, 0, 0);\n      _ssSetOutputPortBeingMerged(rts, 1, 0);\n\n      /* Update the BufferDstPort flags for each input port */\n    }\n\n    /* Level2 S-Function Block: ATTN/<Root>/Analog output  (sg_IO191_da_s) */\n    {\n      SimStruct *rts = ATTN_M->childSfunctions[2];\n\n      /* timing info */\n      time_T *sfcnPeriod = ATTN_M->NonInlinedSFcns.Sfcn2.sfcnPeriod;\n      time_T *sfcnOffset = ATTN_M->NonInlinedSFcns.Sfcn2.sfcnOffset;\n      int_T *sfcnTsMap = ATTN_M->NonInlinedSFcns.Sfcn2.sfcnTsMap;\n      (void) std::memset(static_cast<void*>(sfcnPeriod), 0,\n                         sizeof(time_T)*1);\n      (void) std::memset(static_cast<void*>(sfcnOffset), 0,\n                         sizeof(time_T)*1);\n      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);\n      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);\n      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);\n\n      {\n        ssSetBlkInfo2Ptr(rts, &ATTN_M->NonInlinedSFcns.blkInfo2[2]);\n      }\n\n      _ssSetBlkInfo2PortInfo2Ptr(rts,\n        &ATTN_M->NonInlinedSFcns.inputOutputPortInfo2[2]);\n\n      /* Set up the mdlInfo pointer */\n      ssSetRTWSfcnInfo(rts, ATTN_M->sfcnInfo);\n\n      /* Allocate memory of model methods 2 */\n      {\n        ssSetModelMethods2(rts, &ATTN_M->NonInlinedSFcns.methods2[2]);\n      }\n\n      /* Allocate memory of model methods 3 */\n      {\n        ssSetModelMethods3(rts, &ATTN_M->NonInlinedSFcns.methods3[2]);\n      }\n\n      /* Allocate memory of model methods 4 */\n      {\n        ssSetModelMethods4(rts, &ATTN_M->NonInlinedSFcns.methods4[2]);\n      }\n\n      /* Allocate memory for states auxilliary information */\n      {\n        ssSetStatesInfo2(rts, &ATTN_M->NonInlinedSFcns.statesInfo2[2]);\n        ssSetPeriodicStatesInfo(rts, &ATTN_M->\n          NonInlinedSFcns.periodicStatesInfo[2]);\n      }\n\n      /* inputs */\n      {\n        _ssSetNumInputPorts(rts, 2);\n        ssSetPortInfoForInputs(rts, &ATTN_M->\n          NonInlinedSFcns.Sfcn2.inputPortInfo[0]);\n        ssSetPortInfoForInputs(rts, &ATTN_M->\n          NonInlinedSFcns.Sfcn2.inputPortInfo[0]);\n        _ssSetPortInfo2ForInputUnits(rts,\n          &ATTN_M->NonInlinedSFcns.Sfcn2.inputPortUnits[0]);\n        ssSetInputPortUnit(rts, 0, 0);\n        ssSetInputPortUnit(rts, 1, 0);\n        _ssSetPortInfo2ForInputCoSimAttribute(rts,\n          &ATTN_M->NonInlinedSFcns.Sfcn2.inputPortCoSimAttribute[0]);\n        ssSetInputPortIsContinuousQuantity(rts, 0, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 1, 0);\n\n        /* port 0 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 0, 1);\n          ssSetInputPortSignal(rts, 0, &ATTN_B.sf_MATLABFunction1_d.y);\n          _ssSetInputPortNumDimensions(rts, 0, 1);\n          ssSetInputPortWidthAsInt(rts, 0, 1);\n        }\n\n        /* port 1 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 1, 1);\n          ssSetInputPortSignal(rts, 1, &ATTN_B.sf_MATLABFunction2.y);\n          _ssSetInputPortNumDimensions(rts, 1, 1);\n          ssSetInputPortWidthAsInt(rts, 1, 1);\n        }\n      }\n\n      /* path info */\n      ssSetModelName(rts, \"Analog output \");\n      ssSetPath(rts, \"ATTN/Analog output \");\n      ssSetRTModel(rts,ATTN_M);\n      ssSetParentSS(rts, (NULL));\n      ssSetRootSS(rts, rts);\n      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);\n\n      /* parameters */\n      {\n        mxArray **sfcnParams = (mxArray **)\n          &ATTN_M->NonInlinedSFcns.Sfcn2.params;\n        ssSetSFcnParamsCount(rts, 7);\n        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);\n        ssSetSFcnParam(rts, 0, (mxArray*)ATTN_cal->Analogoutput_P1_Size);\n        ssSetSFcnParam(rts, 1, (mxArray*)ATTN_cal->Analogoutput_P2_Size);\n        ssSetSFcnParam(rts, 2, (mxArray*)ATTN_cal->Analogoutput_P3_Size);\n        ssSetSFcnParam(rts, 3, (mxArray*)ATTN_cal->Analogoutput_P4_Size);\n        ssSetSFcnParam(rts, 4, (mxArray*)ATTN_cal->Analogoutput_P5_Size);\n        ssSetSFcnParam(rts, 5, (mxArray*)ATTN_cal->Analogoutput_P6_Size);\n        ssSetSFcnParam(rts, 6, (mxArray*)ATTN_cal->Analogoutput_P7_Size);\n      }\n\n      /* work vectors */\n      ssSetPWork(rts, (void **) &ATTN_DW.Analogoutput_PWORK);\n\n      {\n        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)\n          &ATTN_M->NonInlinedSFcns.Sfcn2.dWork;\n        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)\n          &ATTN_M->NonInlinedSFcns.Sfcn2.dWorkAux;\n        ssSetSFcnDWork(rts, dWorkRecord);\n        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);\n        ssSetNumDWorkAsInt(rts, 1);\n\n        /* PWORK */\n        ssSetDWorkWidthAsInt(rts, 0, 1);\n        ssSetDWorkDataType(rts, 0,SS_POINTER);\n        ssSetDWorkComplexSignal(rts, 0, 0);\n        ssSetDWork(rts, 0, &ATTN_DW.Analogoutput_PWORK);\n      }\n\n      /* registration */\n      sg_IO191_da_s(rts);\n      sfcnInitializeSizes(rts);\n      sfcnInitializeSampleTimes(rts);\n\n      /* adjust sample time */\n      ssSetSampleTime(rts, 0, 0.001);\n      ssSetOffsetTime(rts, 0, 0.0);\n      sfcnTsMap[0] = 1;\n\n      /* set compiled values of dynamic vector attributes */\n      ssSetNumNonsampledZCsAsInt(rts, 0);\n\n      /* Update connectivity flags for each port */\n      _ssSetInputPortConnected(rts, 0, 1);\n      _ssSetInputPortConnected(rts, 1, 1);\n\n      /* Update the BufferDstPort flags for each input port */\n      ssSetInputPortBufferDstPort(rts, 0, -1);\n      ssSetInputPortBufferDstPort(rts, 1, -1);\n    }\n\n    /* Level2 S-Function Block: ATTN/<Root>/Digital output  (sg_IO191_do_s) */\n    {\n      SimStruct *rts = ATTN_M->childSfunctions[3];\n\n      /* timing info */\n      time_T *sfcnPeriod = ATTN_M->NonInlinedSFcns.Sfcn3.sfcnPeriod;\n      time_T *sfcnOffset = ATTN_M->NonInlinedSFcns.Sfcn3.sfcnOffset;\n      int_T *sfcnTsMap = ATTN_M->NonInlinedSFcns.Sfcn3.sfcnTsMap;\n      (void) std::memset(static_cast<void*>(sfcnPeriod), 0,\n                         sizeof(time_T)*1);\n      (void) std::memset(static_cast<void*>(sfcnOffset), 0,\n                         sizeof(time_T)*1);\n      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);\n      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);\n      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);\n\n      {\n        ssSetBlkInfo2Ptr(rts, &ATTN_M->NonInlinedSFcns.blkInfo2[3]);\n      }\n\n      _ssSetBlkInfo2PortInfo2Ptr(rts,\n        &ATTN_M->NonInlinedSFcns.inputOutputPortInfo2[3]);\n\n      /* Set up the mdlInfo pointer */\n      ssSetRTWSfcnInfo(rts, ATTN_M->sfcnInfo);\n\n      /* Allocate memory of model methods 2 */\n      {\n        ssSetModelMethods2(rts, &ATTN_M->NonInlinedSFcns.methods2[3]);\n      }\n\n      /* Allocate memory of model methods 3 */\n      {\n        ssSetModelMethods3(rts, &ATTN_M->NonInlinedSFcns.methods3[3]);\n      }\n\n      /* Allocate memory of model methods 4 */\n      {\n        ssSetModelMethods4(rts, &ATTN_M->NonInlinedSFcns.methods4[3]);\n      }\n\n      /* Allocate memory for states auxilliary information */\n      {\n        ssSetStatesInfo2(rts, &ATTN_M->NonInlinedSFcns.statesInfo2[3]);\n        ssSetPeriodicStatesInfo(rts, &ATTN_M->\n          NonInlinedSFcns.periodicStatesInfo[3]);\n      }\n\n      /* inputs */\n      {\n        _ssSetNumInputPorts(rts, 15);\n        ssSetPortInfoForInputs(rts, &ATTN_M->\n          NonInlinedSFcns.Sfcn3.inputPortInfo[0]);\n        ssSetPortInfoForInputs(rts, &ATTN_M->\n          NonInlinedSFcns.Sfcn3.inputPortInfo[0]);\n        _ssSetPortInfo2ForInputUnits(rts,\n          &ATTN_M->NonInlinedSFcns.Sfcn3.inputPortUnits[0]);\n        ssSetInputPortUnit(rts, 0, 0);\n        ssSetInputPortUnit(rts, 1, 0);\n        ssSetInputPortUnit(rts, 2, 0);\n        ssSetInputPortUnit(rts, 3, 0);\n        ssSetInputPortUnit(rts, 4, 0);\n        ssSetInputPortUnit(rts, 5, 0);\n        ssSetInputPortUnit(rts, 6, 0);\n        ssSetInputPortUnit(rts, 7, 0);\n        ssSetInputPortUnit(rts, 8, 0);\n        ssSetInputPortUnit(rts, 9, 0);\n        ssSetInputPortUnit(rts, 10, 0);\n        ssSetInputPortUnit(rts, 11, 0);\n        ssSetInputPortUnit(rts, 12, 0);\n        ssSetInputPortUnit(rts, 13, 0);\n        ssSetInputPortUnit(rts, 14, 0);\n        _ssSetPortInfo2ForInputCoSimAttribute(rts,\n          &ATTN_M->NonInlinedSFcns.Sfcn3.inputPortCoSimAttribute[0]);\n        ssSetInputPortIsContinuousQuantity(rts, 0, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 1, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 2, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 3, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 4, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 5, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 6, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 7, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 8, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 9, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 10, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 11, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 12, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 13, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 14, 0);\n\n        /* port 0 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 0, 1);\n          ssSetInputPortSignal(rts, 0, &ATTN_B.whiskCam_trig);\n          _ssSetInputPortNumDimensions(rts, 0, 1);\n          ssSetInputPortWidthAsInt(rts, 0, 1);\n        }\n\n        /* port 1 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 1, 1);\n          ssSetInputPortSignal(rts, 1, &ATTN_B.npxls_trig);\n          _ssSetInputPortNumDimensions(rts, 1, 1);\n          ssSetInputPortWidthAsInt(rts, 1, 1);\n        }\n\n        /* port 2 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 2, 1);\n          ssSetInputPortSignal(rts, 2, &ATTN_B.pupilCam_trig);\n          _ssSetInputPortNumDimensions(rts, 2, 1);\n          ssSetInputPortWidthAsInt(rts, 2, 1);\n        }\n\n        /* port 3 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 3, 1);\n          ssSetInputPortSignal(rts, 3, &ATTN_B.npxlsAcq_out);\n          _ssSetInputPortNumDimensions(rts, 3, 1);\n          ssSetInputPortWidthAsInt(rts, 3, 1);\n        }\n\n        /* port 4 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 4, 1);\n          ssSetInputPortSignal(rts, 4, &ATTN_B.y);\n          _ssSetInputPortNumDimensions(rts, 4, 1);\n          ssSetInputPortWidthAsInt(rts, 4, 1);\n        }\n\n        /* port 5 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 5, 1);\n          ssSetInputPortSignal(rts, 5, (const_cast<real_T*>(&ATTN_RGND)));\n          _ssSetInputPortNumDimensions(rts, 5, 1);\n          ssSetInputPortWidthAsInt(rts, 5, 1);\n        }\n\n        /* port 6 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 6, 1);\n          ssSetInputPortSignal(rts, 6, (const_cast<real_T*>(&ATTN_RGND)));\n          _ssSetInputPortNumDimensions(rts, 6, 1);\n          ssSetInputPortWidthAsInt(rts, 6, 1);\n        }\n\n        /* port 7 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 7, 1);\n          ssSetInputPortSignal(rts, 7, (const_cast<real_T*>(&ATTN_RGND)));\n          _ssSetInputPortNumDimensions(rts, 7, 1);\n          ssSetInputPortWidthAsInt(rts, 7, 1);\n        }\n\n        /* port 8 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 8, 1);\n          ssSetInputPortSignal(rts, 8, (const_cast<real_T*>(&ATTN_RGND)));\n          _ssSetInputPortNumDimensions(rts, 8, 1);\n          ssSetInputPortWidthAsInt(rts, 8, 1);\n        }\n\n        /* port 9 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 9, 1);\n          ssSetInputPortSignal(rts, 9, (const_cast<real_T*>(&ATTN_RGND)));\n          _ssSetInputPortNumDimensions(rts, 9, 1);\n          ssSetInputPortWidthAsInt(rts, 9, 1);\n        }\n\n        /* port 10 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 10, 1);\n          ssSetInputPortSignal(rts, 10, (const_cast<real_T*>(&ATTN_RGND)));\n          _ssSetInputPortNumDimensions(rts, 10, 1);\n          ssSetInputPortWidthAsInt(rts, 10, 1);\n        }\n\n        /* port 11 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 11, 1);\n          ssSetInputPortSignal(rts, 11, (const_cast<real_T*>(&ATTN_RGND)));\n          _ssSetInputPortNumDimensions(rts, 11, 1);\n          ssSetInputPortWidthAsInt(rts, 11, 1);\n        }\n\n        /* port 12 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 12, 1);\n          ssSetInputPortSignal(rts, 12, (const_cast<real_T*>(&ATTN_RGND)));\n          _ssSetInputPortNumDimensions(rts, 12, 1);\n          ssSetInputPortWidthAsInt(rts, 12, 1);\n        }\n\n        /* port 13 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 13, 1);\n          ssSetInputPortSignal(rts, 13, (const_cast<real_T*>(&ATTN_RGND)));\n          _ssSetInputPortNumDimensions(rts, 13, 1);\n          ssSetInputPortWidthAsInt(rts, 13, 1);\n        }\n\n        /* port 14 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 14, 1);\n          ssSetInputPortSignal(rts, 14, &ATTN_B.tonePulse);\n          _ssSetInputPortNumDimensions(rts, 14, 1);\n          ssSetInputPortWidthAsInt(rts, 14, 1);\n        }\n      }\n\n      /* path info */\n      ssSetModelName(rts, \"Digital output \");\n      ssSetPath(rts, \"ATTN/Digital output \");\n      ssSetRTModel(rts,ATTN_M);\n      ssSetParentSS(rts, (NULL));\n      ssSetRootSS(rts, rts);\n      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);\n\n      /* parameters */\n      {\n        mxArray **sfcnParams = (mxArray **)\n          &ATTN_M->NonInlinedSFcns.Sfcn3.params;\n        ssSetSFcnParamsCount(rts, 6);\n        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);\n        ssSetSFcnParam(rts, 0, (mxArray*)ATTN_cal->Digitaloutput_P1_Size);\n        ssSetSFcnParam(rts, 1, (mxArray*)ATTN_cal->Digitaloutput_P2_Size);\n        ssSetSFcnParam(rts, 2, (mxArray*)ATTN_cal->Digitaloutput_P3_Size);\n        ssSetSFcnParam(rts, 3, (mxArray*)ATTN_cal->Digitaloutput_P4_Size);\n        ssSetSFcnParam(rts, 4, (mxArray*)ATTN_cal->Digitaloutput_P5_Size);\n        ssSetSFcnParam(rts, 5, (mxArray*)ATTN_cal->Digitaloutput_P6_Size);\n      }\n\n      /* work vectors */\n      ssSetPWork(rts, (void **) &ATTN_DW.Digitaloutput_PWORK);\n\n      {\n        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)\n          &ATTN_M->NonInlinedSFcns.Sfcn3.dWork;\n        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)\n          &ATTN_M->NonInlinedSFcns.Sfcn3.dWorkAux;\n        ssSetSFcnDWork(rts, dWorkRecord);\n        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);\n        ssSetNumDWorkAsInt(rts, 1);\n\n        /* PWORK */\n        ssSetDWorkWidthAsInt(rts, 0, 1);\n        ssSetDWorkDataType(rts, 0,SS_POINTER);\n        ssSetDWorkComplexSignal(rts, 0, 0);\n        ssSetDWork(rts, 0, &ATTN_DW.Digitaloutput_PWORK);\n      }\n\n      /* registration */\n      sg_IO191_do_s(rts);\n      sfcnInitializeSizes(rts);\n      sfcnInitializeSampleTimes(rts);\n\n      /* adjust sample time */\n      ssSetSampleTime(rts, 0, 0.001);\n      ssSetOffsetTime(rts, 0, 0.0);\n      sfcnTsMap[0] = 1;\n\n      /* set compiled values of dynamic vector attributes */\n      ssSetNumNonsampledZCsAsInt(rts, 0);\n\n      /* Update connectivity flags for each port */\n      _ssSetInputPortConnected(rts, 0, 1);\n      _ssSetInputPortConnected(rts, 1, 1);\n      _ssSetInputPortConnected(rts, 2, 1);\n      _ssSetInputPortConnected(rts, 3, 1);\n      _ssSetInputPortConnected(rts, 4, 1);\n      _ssSetInputPortConnected(rts, 5, 0);\n      _ssSetInputPortConnected(rts, 6, 0);\n      _ssSetInputPortConnected(rts, 7, 0);\n      _ssSetInputPortConnected(rts, 8, 0);\n      _ssSetInputPortConnected(rts, 9, 0);\n      _ssSetInputPortConnected(rts, 10, 0);\n      _ssSetInputPortConnected(rts, 11, 0);\n      _ssSetInputPortConnected(rts, 12, 0);\n      _ssSetInputPortConnected(rts, 13, 0);\n      _ssSetInputPortConnected(rts, 14, 1);\n\n      /* Update the BufferDstPort flags for each input port */\n      ssSetInputPortBufferDstPort(rts, 0, -1);\n      ssSetInputPortBufferDstPort(rts, 1, -1);\n      ssSetInputPortBufferDstPort(rts, 2, -1);\n      ssSetInputPortBufferDstPort(rts, 3, -1);\n      ssSetInputPortBufferDstPort(rts, 4, -1);\n      ssSetInputPortBufferDstPort(rts, 5, -1);\n      ssSetInputPortBufferDstPort(rts, 6, -1);\n      ssSetInputPortBufferDstPort(rts, 7, -1);\n      ssSetInputPortBufferDstPort(rts, 8, -1);\n      ssSetInputPortBufferDstPort(rts, 9, -1);\n      ssSetInputPortBufferDstPort(rts, 10, -1);\n      ssSetInputPortBufferDstPort(rts, 11, -1);\n      ssSetInputPortBufferDstPort(rts, 12, -1);\n      ssSetInputPortBufferDstPort(rts, 13, -1);\n      ssSetInputPortBufferDstPort(rts, 14, -1);\n    }\n\n    /* Level2 S-Function Block: ATTN/<Root>/Digital input  (sg_IO191_di_s) */\n    {\n      SimStruct *rts = ATTN_M->childSfunctions[4];\n\n      /* timing info */\n      time_T *sfcnPeriod = ATTN_M->NonInlinedSFcns.Sfcn4.sfcnPeriod;\n      time_T *sfcnOffset = ATTN_M->NonInlinedSFcns.Sfcn4.sfcnOffset;\n      int_T *sfcnTsMap = ATTN_M->NonInlinedSFcns.Sfcn4.sfcnTsMap;\n      (void) std::memset(static_cast<void*>(sfcnPeriod), 0,\n                         sizeof(time_T)*1);\n      (void) std::memset(static_cast<void*>(sfcnOffset), 0,\n                         sizeof(time_T)*1);\n      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);\n      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);\n      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);\n\n      {\n        ssSetBlkInfo2Ptr(rts, &ATTN_M->NonInlinedSFcns.blkInfo2[4]);\n      }\n\n      _ssSetBlkInfo2PortInfo2Ptr(rts,\n        &ATTN_M->NonInlinedSFcns.inputOutputPortInfo2[4]);\n\n      /* Set up the mdlInfo pointer */\n      ssSetRTWSfcnInfo(rts, ATTN_M->sfcnInfo);\n\n      /* Allocate memory of model methods 2 */\n      {\n        ssSetModelMethods2(rts, &ATTN_M->NonInlinedSFcns.methods2[4]);\n      }\n\n      /* Allocate memory of model methods 3 */\n      {\n        ssSetModelMethods3(rts, &ATTN_M->NonInlinedSFcns.methods3[4]);\n      }\n\n      /* Allocate memory of model methods 4 */\n      {\n        ssSetModelMethods4(rts, &ATTN_M->NonInlinedSFcns.methods4[4]);\n      }\n\n      /* Allocate memory for states auxilliary information */\n      {\n        ssSetStatesInfo2(rts, &ATTN_M->NonInlinedSFcns.statesInfo2[4]);\n        ssSetPeriodicStatesInfo(rts, &ATTN_M->\n          NonInlinedSFcns.periodicStatesInfo[4]);\n      }\n\n      /* outputs */\n      {\n        ssSetPortInfoForOutputs(rts,\n          &ATTN_M->NonInlinedSFcns.Sfcn4.outputPortInfo[0]);\n        ssSetPortInfoForOutputs(rts,\n          &ATTN_M->NonInlinedSFcns.Sfcn4.outputPortInfo[0]);\n        _ssSetNumOutputPorts(rts, 1);\n        _ssSetPortInfo2ForOutputUnits(rts,\n          &ATTN_M->NonInlinedSFcns.Sfcn4.outputPortUnits[0]);\n        ssSetOutputPortUnit(rts, 0, 0);\n        _ssSetPortInfo2ForOutputCoSimAttribute(rts,\n          &ATTN_M->NonInlinedSFcns.Sfcn4.outputPortCoSimAttribute[0]);\n        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);\n\n        /* port 0 */\n        {\n          _ssSetOutputPortNumDimensions(rts, 0, 1);\n          ssSetOutputPortWidthAsInt(rts, 0, 1);\n          ssSetOutputPortSignal(rts, 0, ((real_T *) &ATTN_B.PulseGen1Hz));\n        }\n      }\n\n      /* path info */\n      ssSetModelName(rts, \"Digital input \");\n      ssSetPath(rts, \"ATTN/Digital input \");\n      ssSetRTModel(rts,ATTN_M);\n      ssSetParentSS(rts, (NULL));\n      ssSetRootSS(rts, rts);\n      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);\n\n      /* parameters */\n      {\n        mxArray **sfcnParams = (mxArray **)\n          &ATTN_M->NonInlinedSFcns.Sfcn4.params;\n        ssSetSFcnParamsCount(rts, 4);\n        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);\n        ssSetSFcnParam(rts, 0, (mxArray*)ATTN_cal->Digitalinput_P1_Size);\n        ssSetSFcnParam(rts, 1, (mxArray*)ATTN_cal->Digitalinput_P2_Size);\n        ssSetSFcnParam(rts, 2, (mxArray*)ATTN_cal->Digitalinput_P3_Size);\n        ssSetSFcnParam(rts, 3, (mxArray*)ATTN_cal->Digitalinput_P4_Size);\n      }\n\n      /* work vectors */\n      ssSetPWork(rts, (void **) &ATTN_DW.Digitalinput_PWORK);\n\n      {\n        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)\n          &ATTN_M->NonInlinedSFcns.Sfcn4.dWork;\n        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)\n          &ATTN_M->NonInlinedSFcns.Sfcn4.dWorkAux;\n        ssSetSFcnDWork(rts, dWorkRecord);\n        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);\n        ssSetNumDWorkAsInt(rts, 1);\n\n        /* PWORK */\n        ssSetDWorkWidthAsInt(rts, 0, 1);\n        ssSetDWorkDataType(rts, 0,SS_POINTER);\n        ssSetDWorkComplexSignal(rts, 0, 0);\n        ssSetDWork(rts, 0, &ATTN_DW.Digitalinput_PWORK);\n      }\n\n      /* registration */\n      sg_IO191_di_s(rts);\n      sfcnInitializeSizes(rts);\n      sfcnInitializeSampleTimes(rts);\n\n      /* adjust sample time */\n      ssSetSampleTime(rts, 0, 0.001);\n      ssSetOffsetTime(rts, 0, 0.0);\n      sfcnTsMap[0] = 1;\n\n      /* set compiled values of dynamic vector attributes */\n      ssSetNumNonsampledZCsAsInt(rts, 0);\n\n      /* Update connectivity flags for each port */\n      _ssSetOutputPortConnected(rts, 0, 1);\n      _ssSetOutputPortBeingMerged(rts, 0, 0);\n\n      /* Update the BufferDstPort flags for each input port */\n    }\n  }\n\n  /* Start for S-Function (sg_IO191_setup_s): '<Root>/Setup ' */\n  /* Level2 S-Function Block: '<Root>/Setup ' (sg_IO191_setup_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[0];\n    sfcnStart(rts);\n    if (ssGetErrorStatus(rts) != (NULL))\n      return;\n  }\n\n  /* Start for S-Function (sg_IO191_ad_s): '<Root>/Analog input ' */\n  /* Level2 S-Function Block: '<Root>/Analog input ' (sg_IO191_ad_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[1];\n    sfcnStart(rts);\n    if (ssGetErrorStatus(rts) != (NULL))\n      return;\n  }\n\n  /* Start for S-Function (sg_IO191_da_s): '<Root>/Analog output ' */\n  /* Level2 S-Function Block: '<Root>/Analog output ' (sg_IO191_da_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[2];\n    sfcnStart(rts);\n    if (ssGetErrorStatus(rts) != (NULL))\n      return;\n  }\n\n  /* Start for S-Function (sg_IO191_do_s): '<Root>/Digital output ' */\n  /* Level2 S-Function Block: '<Root>/Digital output ' (sg_IO191_do_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[3];\n    sfcnStart(rts);\n    if (ssGetErrorStatus(rts) != (NULL))\n      return;\n  }\n\n  /* Start for S-Function (sg_IO191_di_s): '<Root>/Digital input ' */\n  /* Level2 S-Function Block: '<Root>/Digital input ' (sg_IO191_di_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[4];\n    sfcnStart(rts);\n    if (ssGetErrorStatus(rts) != (NULL))\n      return;\n  }\n\n  {\n    static const uint32_T tmp[625] = { 5489U, 1301868182U, 2938499221U,\n      2950281878U, 1875628136U, 751856242U, 944701696U, 2243192071U, 694061057U,\n      219885934U, 2066767472U, 3182869408U, 485472502U, 2336857883U, 1071588843U,\n      3418470598U, 951210697U, 3693558366U, 2923482051U, 1793174584U,\n      2982310801U, 1586906132U, 1951078751U, 1808158765U, 1733897588U,\n      431328322U, 4202539044U, 530658942U, 1714810322U, 3025256284U, 3342585396U,\n      1937033938U, 2640572511U, 1654299090U, 3692403553U, 4233871309U,\n      3497650794U, 862629010U, 2943236032U, 2426458545U, 1603307207U,\n      1133453895U, 3099196360U, 2208657629U, 2747653927U, 931059398U, 761573964U,\n      3157853227U, 785880413U, 730313442U, 124945756U, 2937117055U, 3295982469U,\n      1724353043U, 3021675344U, 3884886417U, 4010150098U, 4056961966U,\n      699635835U, 2681338818U, 1339167484U, 720757518U, 2800161476U, 2376097373U,\n      1532957371U, 3902664099U, 1238982754U, 3725394514U, 3449176889U,\n      3570962471U, 4287636090U, 4087307012U, 3603343627U, 202242161U,\n      2995682783U, 1620962684U, 3704723357U, 371613603U, 2814834333U,\n      2111005706U, 624778151U, 2094172212U, 4284947003U, 1211977835U, 991917094U,\n      1570449747U, 2962370480U, 1259410321U, 170182696U, 146300961U, 2836829791U,\n      619452428U, 2723670296U, 1881399711U, 1161269684U, 1675188680U,\n      4132175277U, 780088327U, 3409462821U, 1036518241U, 1834958505U,\n      3048448173U, 161811569U, 618488316U, 44795092U, 3918322701U, 1924681712U,\n      3239478144U, 383254043U, 4042306580U, 2146983041U, 3992780527U,\n      3518029708U, 3545545436U, 3901231469U, 1896136409U, 2028528556U,\n      2339662006U, 501326714U, 2060962201U, 2502746480U, 561575027U, 581893337U,\n      3393774360U, 1778912547U, 3626131687U, 2175155826U, 319853231U, 986875531U,\n      819755096U, 2915734330U, 2688355739U, 3482074849U, 2736559U, 2296975761U,\n      1029741190U, 2876812646U, 690154749U, 579200347U, 4027461746U, 1285330465U,\n      2701024045U, 4117700889U, 759495121U, 3332270341U, 2313004527U,\n      2277067795U, 4131855432U, 2722057515U, 1264804546U, 3848622725U,\n      2211267957U, 4100593547U, 959123777U, 2130745407U, 3194437393U, 486673947U,\n      1377371204U, 17472727U, 352317554U, 3955548058U, 159652094U, 1232063192U,\n      3835177280U, 49423123U, 3083993636U, 733092U, 2120519771U, 2573409834U,\n      1112952433U, 3239502554U, 761045320U, 1087580692U, 2540165110U, 641058802U,\n      1792435497U, 2261799288U, 1579184083U, 627146892U, 2165744623U,\n      2200142389U, 2167590760U, 2381418376U, 1793358889U, 3081659520U,\n      1663384067U, 2009658756U, 2689600308U, 739136266U, 2304581039U,\n      3529067263U, 591360555U, 525209271U, 3131882996U, 294230224U, 2076220115U,\n      3113580446U, 1245621585U, 1386885462U, 3203270426U, 123512128U, 12350217U,\n      354956375U, 4282398238U, 3356876605U, 3888857667U, 157639694U, 2616064085U,\n      1563068963U, 2762125883U, 4045394511U, 4180452559U, 3294769488U,\n      1684529556U, 1002945951U, 3181438866U, 22506664U, 691783457U, 2685221343U,\n      171579916U, 3878728600U, 2475806724U, 2030324028U, 3331164912U,\n      1708711359U, 1970023127U, 2859691344U, 2588476477U, 2748146879U,\n      136111222U, 2967685492U, 909517429U, 2835297809U, 3206906216U, 3186870716U,\n      341264097U, 2542035121U, 3353277068U, 548223577U, 3170936588U, 1678403446U,\n      297435620U, 2337555430U, 466603495U, 1132321815U, 1208589219U, 696392160U,\n      894244439U, 2562678859U, 470224582U, 3306867480U, 201364898U, 2075966438U,\n      1767227936U, 2929737987U, 3674877796U, 2654196643U, 3692734598U,\n      3528895099U, 2796780123U, 3048728353U, 842329300U, 191554730U, 2922459673U,\n      3489020079U, 3979110629U, 1022523848U, 2202932467U, 3583655201U,\n      3565113719U, 587085778U, 4176046313U, 3013713762U, 950944241U, 396426791U,\n      3784844662U, 3477431613U, 3594592395U, 2782043838U, 3392093507U,\n      3106564952U, 2829419931U, 1358665591U, 2206918825U, 3170783123U, 31522386U,\n      2988194168U, 1782249537U, 1105080928U, 843500134U, 1225290080U,\n      1521001832U, 3605886097U, 2802786495U, 2728923319U, 3996284304U,\n      903417639U, 1171249804U, 1020374987U, 2824535874U, 423621996U, 1988534473U,\n      2493544470U, 1008604435U, 1756003503U, 1488867287U, 1386808992U,\n      732088248U, 1780630732U, 2482101014U, 976561178U, 1543448953U, 2602866064U,\n      2021139923U, 1952599828U, 2360242564U, 2117959962U, 2753061860U,\n      2388623612U, 4138193781U, 2962920654U, 2284970429U, 766920861U,\n      3457264692U, 2879611383U, 815055854U, 2332929068U, 1254853997U,\n      3740375268U, 3799380844U, 4091048725U, 2006331129U, 1982546212U,\n      686850534U, 1907447564U, 2682801776U, 2780821066U, 998290361U, 1342433871U,\n      4195430425U, 607905174U, 3902331779U, 2454067926U, 1708133115U,\n      1170874362U, 2008609376U, 3260320415U, 2211196135U, 433538229U,\n      2728786374U, 2189520818U, 262554063U, 1182318347U, 3710237267U,\n      1221022450U, 715966018U, 2417068910U, 2591870721U, 2870691989U,\n      3418190842U, 4238214053U, 1540704231U, 1575580968U, 2095917976U,\n      4078310857U, 2313532447U, 2110690783U, 4056346629U, 4061784526U,\n      1123218514U, 551538993U, 597148360U, 4120175196U, 3581618160U, 3181170517U,\n      422862282U, 3227524138U, 1713114790U, 662317149U, 1230418732U, 928171837U,\n      1324564878U, 1928816105U, 1786535431U, 2878099422U, 3290185549U,\n      539474248U, 1657512683U, 552370646U, 1671741683U, 3655312128U, 1552739510U,\n      2605208763U, 1441755014U, 181878989U, 3124053868U, 1447103986U,\n      3183906156U, 1728556020U, 3502241336U, 3055466967U, 1013272474U,\n      818402132U, 1715099063U, 2900113506U, 397254517U, 4194863039U, 1009068739U,\n      232864647U, 2540223708U, 2608288560U, 2415367765U, 478404847U, 3455100648U,\n      3182600021U, 2115988978U, 434269567U, 4117179324U, 3461774077U, 887256537U,\n      3545801025U, 286388911U, 3451742129U, 1981164769U, 786667016U, 3310123729U,\n      3097811076U, 2224235657U, 2959658883U, 3370969234U, 2514770915U,\n      3345656436U, 2677010851U, 2206236470U, 271648054U, 2342188545U,\n      4292848611U, 3646533909U, 3754009956U, 3803931226U, 4160647125U,\n      1477814055U, 4043852216U, 1876372354U, 3133294443U, 3871104810U,\n      3177020907U, 2074304428U, 3479393793U, 759562891U, 164128153U, 1839069216U,\n      2114162633U, 3989947309U, 3611054956U, 1333547922U, 835429831U, 494987340U,\n      171987910U, 1252001001U, 370809172U, 3508925425U, 2535703112U, 1276855041U,\n      1922855120U, 835673414U, 3030664304U, 613287117U, 171219893U, 3423096126U,\n      3376881639U, 2287770315U, 1658692645U, 1262815245U, 3957234326U,\n      1168096164U, 2968737525U, 2655813712U, 2132313144U, 3976047964U,\n      326516571U, 353088456U, 3679188938U, 3205649712U, 2654036126U, 1249024881U,\n      880166166U, 691800469U, 2229503665U, 1673458056U, 4032208375U, 1851778863U,\n      2563757330U, 376742205U, 1794655231U, 340247333U, 1505873033U, 396524441U,\n      879666767U, 3335579166U, 3260764261U, 3335999539U, 506221798U, 4214658741U,\n      975887814U, 2080536343U, 3360539560U, 571586418U, 138896374U, 4234352651U,\n      2737620262U, 3928362291U, 1516365296U, 38056726U, 3599462320U, 3585007266U,\n      3850961033U, 471667319U, 1536883193U, 2310166751U, 1861637689U,\n      2530999841U, 4139843801U, 2710569485U, 827578615U, 2012334720U,\n      2907369459U, 3029312804U, 2820112398U, 1965028045U, 35518606U, 2478379033U,\n      643747771U, 1924139484U, 4123405127U, 3811735531U, 3429660832U,\n      3285177704U, 1948416081U, 1311525291U, 1183517742U, 1739192232U,\n      3979815115U, 2567840007U, 4116821529U, 213304419U, 4125718577U,\n      1473064925U, 2442436592U, 1893310111U, 4195361916U, 3747569474U,\n      828465101U, 2991227658U, 750582866U, 1205170309U, 1409813056U, 678418130U,\n      1171531016U, 3821236156U, 354504587U, 4202874632U, 3882511497U,\n      1893248677U, 1903078632U, 26340130U, 2069166240U, 3657122492U, 3725758099U,\n      831344905U, 811453383U, 3447711422U, 2434543565U, 4166886888U, 3358210805U,\n      4142984013U, 2988152326U, 3527824853U, 982082992U, 2809155763U, 190157081U,\n      3340214818U, 2365432395U, 2548636180U, 2894533366U, 3474657421U,\n      2372634704U, 2845748389U, 43024175U, 2774226648U, 1987702864U, 3186502468U,\n      453610222U, 4204736567U, 1392892630U, 2471323686U, 2470534280U,\n      3541393095U, 4269885866U, 3909911300U, 759132955U, 1482612480U, 667715263U,\n      1795580598U, 2337923983U, 3390586366U, 581426223U, 1515718634U, 476374295U,\n      705213300U, 363062054U, 2084697697U, 2407503428U, 2292957699U, 2426213835U,\n      2199989172U, 1987356470U, 4026755612U, 2147252133U, 270400031U,\n      1367820199U, 2369854699U, 2844269403U, 79981964U, 624U };\n\n    /* InitializeConditions for Memory: '<Root>/Memory8' */\n    ATTN_DW.Memory8_PreviousInput = ATTN_cal->Memory8_InitialCondition;\n\n    /* InitializeConditions for Memory: '<Root>/Memory2' */\n    ATTN_DW.Memory2_PreviousInput = ATTN_cal->Memory2_InitialCondition;\n\n    /* InitializeConditions for Memory: '<Root>/Memory1' */\n    ATTN_DW.Memory1_PreviousInput = ATTN_cal->Memory1_InitialCondition;\n\n    /* InitializeConditions for Memory: '<Root>/Memory' */\n    ATTN_DW.Memory_PreviousInput = ATTN_cal->Memory_InitialCondition;\n\n    /* InitializeConditions for DiscreteFilter: '<Root>/Discrete Filter' */\n    ATTN_DW.DiscreteFilter_states = ATTN_cal->DiscreteFilter_InitialStates;\n\n    /* InitializeConditions for Memory: '<Root>/Memory11' */\n    ATTN_DW.Memory11_PreviousInput = ATTN_cal->Memory11_InitialCondition;\n\n    /* InitializeConditions for Memory: '<Root>/Memory7' */\n    ATTN_DW.Memory7_PreviousInput = ATTN_cal->Memory7_InitialCondition;\n\n    /* InitializeConditions for Memory: '<Root>/Memory3' */\n    ATTN_DW.Memory3_PreviousInput = ATTN_cal->Memory3_InitialCondition;\n\n    /* InitializeConditions for Memory: '<Root>/Memory4' */\n    ATTN_DW.Memory4_PreviousInput = ATTN_cal->Memory4_InitialCondition;\n\n    /* InitializeConditions for Memory: '<Root>/Memory9' */\n    ATTN_DW.Memory9_PreviousInput = ATTN_cal->Memory9_InitialCondition;\n\n    /* InitializeConditions for Memory: '<Root>/Memory5' */\n    ATTN_DW.Memory5_PreviousInput = ATTN_cal->Memory5_InitialCondition;\n\n    /* InitializeConditions for Memory: '<Root>/Memory6' */\n    ATTN_DW.Memory6_PreviousInput = ATTN_cal->Memory6_InitialCondition;\n\n    /* InitializeConditions for Memory: '<Root>/Memory10' */\n    ATTN_DW.Memory10_PreviousInput = ATTN_cal->Memory10_InitialCondition;\n\n    /* InitializeConditions for DiscretePulseGenerator: '<Root>/Whisker Trig' */\n    ATTN_DW.clockTickCounter = 0;\n\n    /* InitializeConditions for DiscretePulseGenerator: '<Root>/Npxls Trig' */\n    ATTN_DW.clockTickCounter_n = 0;\n\n    /* InitializeConditions for DiscretePulseGenerator: '<Root>/Pupil Trig' */\n    ATTN_DW.clockTickCounter_c = 0;\n\n    /* SystemInitialize for MATLAB Function: '<Root>/MATLAB Function1' */\n    ATTN_DW.sfEvent_b = ATTN_CALL_EVENT_n;\n    ATTN_DW.is_active_c6_ATTN = 0U;\n\n    /* SystemInitialize for MATLAB Function: '<Root>/MATLAB Function' */\n    std::memcpy(&ATTN_DW.state_k[0], &tmp[0], 625U * sizeof(uint32_T));\n    ATTN_DW.sfEvent_e = ATTN_CALL_EVENT_n;\n    ATTN_DW.is_active_c1_ATTN = 0U;\n    ATTN_DW.method = 7U;\n    ATTN_DW.method_not_empty = true;\n    ATTN_DW.state = 1144108930U;\n    ATTN_DW.state_not_empty = true;\n    ATTN_DW.state_p[0] = 362436069U;\n    ATTN_DW.state_p[1] = 521288629U;\n    ATTN_DW.state_not_empty_k = true;\n    ATTN_DW.state_not_empty_d = true;\n\n    /* SystemInitialize for MATLAB Function: '<S4>/MATLAB Function1' */\n    ATTN_MATLABFunction2_Init(&ATTN_DW.sf_MATLABFunction1_d);\n\n    /* SystemInitialize for MATLAB Function: '<S3>/MATLAB Function2' */\n    ATTN_MATLABFunction2_Init(&ATTN_DW.sf_MATLABFunction2);\n\n    /* SystemInitialize for MATLAB Function: '<S5>/MATLAB Function1' */\n    ATTN_DW.sfEvent_a = ATTN_CALL_EVENT_n;\n    ATTN_DW.t0_not_empty_p = false;\n    ATTN_DW.is_active_c5_ATTN = 0U;\n\n    /* SystemInitialize for MATLAB Function: '<S6>/MATLAB Function1' */\n    ATTN_DW.sfEvent = ATTN_CALL_EVENT_n;\n    ATTN_DW.t0_not_empty = false;\n    ATTN_DW.is_active_c2_ATTN = 0U;\n  }\n}\n\n/* Model terminate function */\nvoid ATTN_terminate(void)\n{\n  /* Terminate for S-Function (sg_IO191_setup_s): '<Root>/Setup ' */\n  /* Level2 S-Function Block: '<Root>/Setup ' (sg_IO191_setup_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[0];\n    sfcnTerminate(rts);\n  }\n\n  /* Terminate for S-Function (sg_IO191_ad_s): '<Root>/Analog input ' */\n  /* Level2 S-Function Block: '<Root>/Analog input ' (sg_IO191_ad_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[1];\n    sfcnTerminate(rts);\n  }\n\n  /* Terminate for S-Function (sg_IO191_da_s): '<Root>/Analog output ' */\n  /* Level2 S-Function Block: '<Root>/Analog output ' (sg_IO191_da_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[2];\n    sfcnTerminate(rts);\n  }\n\n  /* Terminate for S-Function (sg_IO191_do_s): '<Root>/Digital output ' */\n  /* Level2 S-Function Block: '<Root>/Digital output ' (sg_IO191_do_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[3];\n    sfcnTerminate(rts);\n  }\n\n  /* Terminate for S-Function (sg_IO191_di_s): '<Root>/Digital input ' */\n  /* Level2 S-Function Block: '<Root>/Digital input ' (sg_IO191_di_s) */\n  {\n    SimStruct *rts = ATTN_M->childSfunctions[4];\n    sfcnTerminate(rts);\n  }\n}\n"},{"name":"ATTN.h","type":"header","group":"model","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * ATTN.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.455\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Fri Dec  1 09:35:43 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_ATTN_h_\n#define RTW_HEADER_ATTN_h_\n#include <logsrv.h>\n#include \"rtwtypes.h\"\n#include \"simstruc.h\"\n#include \"fixedpoint.h\"\n#include \"verify/verifyIntrf.h\"\n#include \"ATTN_types.h\"\n#include <stddef.h>\n#include <cstring>\n#include \"ATTN_cal.h\"\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n/* Macros for accessing real-time model data structure */\n#ifndef rtmGetContTimeOutputInconsistentWithStateAtMajorStepFlag\n#define rtmGetContTimeOutputInconsistentWithStateAtMajorStepFlag(rtm) ((rtm)->CTOutputIncnstWithState)\n#endif\n\n#ifndef rtmSetContTimeOutputInconsistentWithStateAtMajorStepFlag\n#define rtmSetContTimeOutputInconsistentWithStateAtMajorStepFlag(rtm, val) ((rtm)->CTOutputIncnstWithState = (val))\n#endif\n\n#ifndef rtmGetDerivCacheNeedsReset\n#define rtmGetDerivCacheNeedsReset(rtm) ((rtm)->derivCacheNeedsReset)\n#endif\n\n#ifndef rtmSetDerivCacheNeedsReset\n#define rtmSetDerivCacheNeedsReset(rtm, val) ((rtm)->derivCacheNeedsReset = (val))\n#endif\n\n#ifndef rtmGetFinalTime\n#define rtmGetFinalTime(rtm)           ((rtm)->Timing.tFinal)\n#endif\n\n#ifndef rtmGetSampleHitArray\n#define rtmGetSampleHitArray(rtm)      ((rtm)->Timing.sampleHitArray)\n#endif\n\n#ifndef rtmGetStepSize\n#define rtmGetStepSize(rtm)            ((rtm)->Timing.stepSize)\n#endif\n\n#ifndef rtmGetZCCacheNeedsReset\n#define rtmGetZCCacheNeedsReset(rtm)   ((rtm)->zCCacheNeedsReset)\n#endif\n\n#ifndef rtmSetZCCacheNeedsReset\n#define rtmSetZCCacheNeedsReset(rtm, val) ((rtm)->zCCacheNeedsReset = (val))\n#endif\n\n#ifndef rtmGet_TimeOfLastOutput\n#define rtmGet_TimeOfLastOutput(rtm)   ((rtm)->Timing.timeOfLastOutput)\n#endif\n\n#ifndef rtmGetErrorStatus\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\n#endif\n\n#ifndef rtmSetErrorStatus\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\n#endif\n\n#ifndef rtmGetStopRequested\n#define rtmGetStopRequested(rtm)       ((rtm)->Timing.stopRequestedFlag)\n#endif\n\n#ifndef rtmSetStopRequested\n#define rtmSetStopRequested(rtm, val)  ((rtm)->Timing.stopRequestedFlag = (val))\n#endif\n\n#ifndef rtmGetStopRequestedPtr\n#define rtmGetStopRequestedPtr(rtm)    (&((rtm)->Timing.stopRequestedFlag))\n#endif\n\n#ifndef rtmGetT\n#define rtmGetT(rtm)                   (rtmGetTPtr((rtm))[0])\n#endif\n\n#ifndef rtmGetTFinal\n#define rtmGetTFinal(rtm)              ((rtm)->Timing.tFinal)\n#endif\n\n#ifndef rtmGetTPtr\n#define rtmGetTPtr(rtm)                ((rtm)->Timing.t)\n#endif\n\n#ifndef rtmGetTStart\n#define rtmGetTStart(rtm)              ((rtm)->Timing.tStart)\n#endif\n\n#ifndef rtmGetTimeOfLastOutput\n#define rtmGetTimeOfLastOutput(rtm)    ((rtm)->Timing.timeOfLastOutput)\n#endif\n\n/* Block signals for system '<S3>/MATLAB Function2' */\nstruct B_MATLABFunction2_ATTN_T {\n  real_T y;                            /* '<S3>/MATLAB Function2' */\n};\n\n/* Block states (default storage) for system '<S3>/MATLAB Function2' */\nstruct DW_MATLABFunction2_ATTN_T {\n  real_T t0;                           /* '<S3>/MATLAB Function2' */\n  real_T y0;                           /* '<S3>/MATLAB Function2' */\n  int32_T sfEvent;                     /* '<S3>/MATLAB Function2' */\n  uint8_T is_active_c3_ATTN;           /* '<S3>/MATLAB Function2' */\n  boolean_T doneDoubleBufferReInit;    /* '<S3>/MATLAB Function2' */\n  boolean_T t0_not_empty;              /* '<S3>/MATLAB Function2' */\n  boolean_T y0_not_empty;              /* '<S3>/MATLAB Function2' */\n};\n\n/* Block signals (default storage) */\nstruct B_ATTN_T {\n  real_T Memory8;                      /* '<Root>/Memory8' */\n  real_T Memory2;                      /* '<Root>/Memory2' */\n  real_T Memory1;                      /* '<Root>/Memory1' */\n  real_T Memory;                       /* '<Root>/Memory' */\n  real_T Analoginput_o1;               /* '<Root>/Analog input ' */\n  real_T lickometer_piezo;             /* '<Root>/Analog input ' */\n  real_T DiscreteFilter;               /* '<Root>/Discrete Filter' */\n  real_T Memory11;                     /* '<Root>/Memory11' */\n  real_T Memory7;                      /* '<Root>/Memory7' */\n  real_T clock_time;                   /* '<Root>/Clock' */\n  real_T Memory3;                      /* '<Root>/Memory3' */\n  real_T Memory4;                      /* '<Root>/Memory4' */\n  real_T Memory9;                      /* '<Root>/Memory9' */\n  real_T Memory5;                      /* '<Root>/Memory5' */\n  real_T Memory6;                      /* '<Root>/Memory6' */\n  real_T Memory10;                     /* '<Root>/Memory10' */\n  real_T Clock1;                       /* '<S4>/Clock1' */\n  real_T Clock2;                       /* '<S3>/Clock2' */\n  real_T whiskCam_trig;                /* '<Root>/Whisker Trig' */\n  real_T npxls_trig;                   /* '<Root>/Npxls Trig' */\n  real_T pupilCam_trig;                /* '<Root>/Pupil Trig' */\n  real_T Clock1_b;                     /* '<S5>/Clock1' */\n  real_T Clock1_l;                     /* '<S6>/Clock1' */\n  real_T PulseGen1Hz;                  /* '<Root>/Digital input ' */\n  real_T HiddenRateTransitionForToWks_In;\n  /* '<Root>/HiddenRateTransitionForToWks_InsertedFor_TAQSigLogging_InsertedFor_Digital input _at_outport_0_at_inport_0' */\n  real_T tonePulse;                    /* '<S6>/MATLAB Function1' */\n  real_T y;                            /* '<S5>/MATLAB Function1' */\n  real_T Lick;                         /* '<Root>/MATLAB Function1' */\n  real_T y1;                           /* '<Root>/MATLAB Function1' */\n  real_T y2;                           /* '<Root>/MATLAB Function1' */\n  real_T state_out;                    /* '<Root>/MATLAB Function' */\n  real_T localTime_out;                /* '<Root>/MATLAB Function' */\n  real_T trialNum_out;                 /* '<Root>/MATLAB Function' */\n  real_T npxlsAcq_out;                 /* '<Root>/MATLAB Function' */\n  real_T counter_out;                  /* '<Root>/MATLAB Function' */\n  real_T numLicks_out;                 /* '<Root>/MATLAB Function' */\n  real_T reward_trigger_out;           /* '<Root>/MATLAB Function' */\n  real_T right_trigger_out;            /* '<Root>/MATLAB Function' */\n  real_T left_trigger_out;             /* '<Root>/MATLAB Function' */\n  real_T delay_out;                    /* '<Root>/MATLAB Function' */\n  real_T was_target_out;               /* '<Root>/MATLAB Function' */\n  real_T reward_duration_out;          /* '<Root>/MATLAB Function' */\n  real_T stim_duration_out;            /* '<Root>/MATLAB Function' */\n  real_T onsetTone_trig;               /* '<Root>/MATLAB Function' */\n  boolean_T RelationalOperator;        /* '<Root>/Relational Operator' */\n  B_MATLABFunction2_ATTN_T sf_MATLABFunction1_d;/* '<S4>/MATLAB Function1' */\n  B_MATLABFunction2_ATTN_T sf_MATLABFunction2;/* '<S3>/MATLAB Function2' */\n};\n\n/* Block states (default storage) for system '<Root>' */\nstruct DW_ATTN_T {\n  real_T DiscreteFilter_states;        /* '<Root>/Discrete Filter' */\n  real_T Memory8_PreviousInput;        /* '<Root>/Memory8' */\n  real_T Memory2_PreviousInput;        /* '<Root>/Memory2' */\n  real_T Memory1_PreviousInput;        /* '<Root>/Memory1' */\n  real_T Memory_PreviousInput;         /* '<Root>/Memory' */\n  real_T DiscreteFilter_tmp;           /* '<Root>/Discrete Filter' */\n  real_T Memory11_PreviousInput;       /* '<Root>/Memory11' */\n  real_T Memory7_PreviousInput;        /* '<Root>/Memory7' */\n  real_T Memory3_PreviousInput;        /* '<Root>/Memory3' */\n  real_T Memory4_PreviousInput;        /* '<Root>/Memory4' */\n  real_T Memory9_PreviousInput;        /* '<Root>/Memory9' */\n  real_T Memory5_PreviousInput;        /* '<Root>/Memory5' */\n  real_T Memory6_PreviousInput;        /* '<Root>/Memory6' */\n  real_T Memory10_PreviousInput;       /* '<Root>/Memory10' */\n  real_T t0;                           /* '<S6>/MATLAB Function1' */\n  real_T t0_p;                         /* '<S5>/MATLAB Function1' */\n  real_T Setup_RWORK[2];               /* '<Root>/Setup ' */\n  void *Setup_PWORK;                   /* '<Root>/Setup ' */\n  void *Analoginput_PWORK;             /* '<Root>/Analog input ' */\n  void *Analogoutput_PWORK;            /* '<Root>/Analog output ' */\n  void *Digitaloutput_PWORK;           /* '<Root>/Digital output ' */\n  void *Digitalinput_PWORK;            /* '<Root>/Digital input ' */\n  struct {\n    void *LoggedData[5];\n  } Scope_PWORK;                       /* '<Root>/Scope' */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_Digit;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_Rewar;   /* synthesized block */\n\n  struct {\n    void *LoggedData;\n  } reward_scope_PWORK;                /* '<Root>/reward_scope' */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_Pupil;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_Npxls;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_Whisk;   /* synthesized block */\n\n  struct {\n    void *LoggedData;\n  } left_scope_PWORK;                  /* '<Root>/left_scope' */\n\n  struct {\n    void *LoggedData;\n  } right_scope_PWORK;                 /* '<Root>/right_scope' */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MATLA;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_n;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_k;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_h;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_f;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_p;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_o;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_c;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_m;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MA_cm;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_g;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_b;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_Clock;   /* synthesized block */\n\n  struct {\n    void *LoggedData;\n  } Scope2_PWORK;                      /* '<Root>/Scope2' */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_MAT_a;   /* synthesized block */\n\n  struct {\n    void *LoggedData;\n  } Scope1_PWORK;                      /* '<Root>/Scope1' */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_Analo;   /* synthesized block */\n\n  int32_T clockTickCounter;            /* '<Root>/Whisker Trig' */\n  int32_T clockTickCounter_n;          /* '<Root>/Npxls Trig' */\n  int32_T clockTickCounter_c;          /* '<Root>/Pupil Trig' */\n  int32_T sfEvent;                     /* '<S6>/MATLAB Function1' */\n  int32_T sfEvent_a;                   /* '<S5>/MATLAB Function1' */\n  int32_T sfEvent_b;                   /* '<Root>/MATLAB Function1' */\n  int32_T sfEvent_e;                   /* '<Root>/MATLAB Function' */\n  uint32_T method;                     /* '<Root>/MATLAB Function' */\n  uint32_T state;                      /* '<Root>/MATLAB Function' */\n  uint32_T state_p[2];                 /* '<Root>/MATLAB Function' */\n  uint32_T state_k[625];               /* '<Root>/MATLAB Function' */\n  int_T Analoginput_IWORK[2];          /* '<Root>/Analog input ' */\n  uint8_T is_active_c2_ATTN;           /* '<S6>/MATLAB Function1' */\n  uint8_T is_active_c5_ATTN;           /* '<S5>/MATLAB Function1' */\n  uint8_T is_active_c6_ATTN;           /* '<Root>/MATLAB Function1' */\n  uint8_T is_active_c1_ATTN;           /* '<Root>/MATLAB Function' */\n  boolean_T doneDoubleBufferReInit;    /* '<S6>/MATLAB Function1' */\n  boolean_T t0_not_empty;              /* '<S6>/MATLAB Function1' */\n  boolean_T doneDoubleBufferReInit_i;  /* '<S5>/MATLAB Function1' */\n  boolean_T t0_not_empty_p;            /* '<S5>/MATLAB Function1' */\n  boolean_T doneDoubleBufferReInit_j;  /* '<Root>/MATLAB Function1' */\n  boolean_T doneDoubleBufferReInit_e;  /* '<Root>/MATLAB Function' */\n  boolean_T method_not_empty;          /* '<Root>/MATLAB Function' */\n  boolean_T state_not_empty;           /* '<Root>/MATLAB Function' */\n  boolean_T state_not_empty_k;         /* '<Root>/MATLAB Function' */\n  boolean_T state_not_empty_d;         /* '<Root>/MATLAB Function' */\n  DW_MATLABFunction2_ATTN_T sf_MATLABFunction1_d;/* '<S4>/MATLAB Function1' */\n  DW_MATLABFunction2_ATTN_T sf_MATLABFunction2;/* '<S3>/MATLAB Function2' */\n};\n\n/* Real-time Model Data Structure */\nstruct tag_RTM_ATTN_T {\n  struct SimStruct_tag * *childSfunctions;\n  const char_T *errorStatus;\n  SS_SimMode simMode;\n  RTWSolverInfo solverInfo;\n  RTWSolverInfo *solverInfoPtr;\n  void *sfcnInfo;\n\n  /*\n   * NonInlinedSFcns:\n   * The following substructure contains information regarding\n   * non-inlined s-functions used in the model.\n   */\n  struct {\n    RTWSfcnInfo sfcnInfo;\n    time_T *taskTimePtrs[2];\n    SimStruct childSFunctions[5];\n    SimStruct *childSFunctionPtrs[5];\n    struct _ssBlkInfo2 blkInfo2[5];\n    struct _ssSFcnModelMethods2 methods2[5];\n    struct _ssSFcnModelMethods3 methods3[5];\n    struct _ssSFcnModelMethods4 methods4[5];\n    struct _ssStatesInfo2 statesInfo2[5];\n    ssPeriodicStatesInfo periodicStatesInfo[5];\n    struct _ssPortInfo2 inputOutputPortInfo2[5];\n    struct {\n      time_T sfcnPeriod[1];\n      time_T sfcnOffset[1];\n      int_T sfcnTsMap[1];\n      uint_T attribs[9];\n      mxArray *params[9];\n      struct _ssDWorkRecord dWork[2];\n      struct _ssDWorkAuxRecord dWorkAux[2];\n    } Sfcn0;\n\n    struct {\n      time_T sfcnPeriod[1];\n      time_T sfcnOffset[1];\n      int_T sfcnTsMap[1];\n      struct _ssPortOutputs outputPortInfo[2];\n      struct _ssOutPortUnit outputPortUnits[2];\n      struct _ssOutPortCoSimAttribute outputPortCoSimAttribute[2];\n      uint_T attribs[9];\n      mxArray *params[9];\n      struct _ssDWorkRecord dWork[2];\n      struct _ssDWorkAuxRecord dWorkAux[2];\n    } Sfcn1;\n\n    struct {\n      time_T sfcnPeriod[1];\n      time_T sfcnOffset[1];\n      int_T sfcnTsMap[1];\n      struct _ssPortInputs inputPortInfo[2];\n      struct _ssInPortUnit inputPortUnits[2];\n      struct _ssInPortCoSimAttribute inputPortCoSimAttribute[2];\n      uint_T attribs[7];\n      mxArray *params[7];\n      struct _ssDWorkRecord dWork[1];\n      struct _ssDWorkAuxRecord dWorkAux[1];\n    } Sfcn2;\n\n    struct {\n      time_T sfcnPeriod[1];\n      time_T sfcnOffset[1];\n      int_T sfcnTsMap[1];\n      struct _ssPortInputs inputPortInfo[15];\n      struct _ssInPortUnit inputPortUnits[15];\n      struct _ssInPortCoSimAttribute inputPortCoSimAttribute[15];\n      uint_T attribs[6];\n      mxArray *params[6];\n      struct _ssDWorkRecord dWork[1];\n      struct _ssDWorkAuxRecord dWorkAux[1];\n    } Sfcn3;\n\n    struct {\n      time_T sfcnPeriod[1];\n      time_T sfcnOffset[1];\n      int_T sfcnTsMap[1];\n      struct _ssPortOutputs outputPortInfo[1];\n      struct _ssOutPortUnit outputPortUnits[1];\n      struct _ssOutPortCoSimAttribute outputPortCoSimAttribute[1];\n      uint_T attribs[4];\n      mxArray *params[4];\n      struct _ssDWorkRecord dWork[1];\n      struct _ssDWorkAuxRecord dWorkAux[1];\n    } Sfcn4;\n  } NonInlinedSFcns;\n\n  boolean_T zCCacheNeedsReset;\n  boolean_T derivCacheNeedsReset;\n  boolean_T CTOutputIncnstWithState;\n\n  /*\n   * Sizes:\n   * The following substructure contains sizes information\n   * for many of the model attributes such as inputs, outputs,\n   * dwork, sample times, etc.\n   */\n  struct {\n    uint32_T options;\n    int_T numContStates;\n    int_T numU;\n    int_T numY;\n    int_T numSampTimes;\n    int_T numBlocks;\n    int_T numBlockIO;\n    int_T numBlockPrms;\n    int_T numDwork;\n    int_T numSFcnPrms;\n    int_T numSFcns;\n    int_T numIports;\n    int_T numOports;\n    int_T numNonSampZCs;\n    int_T sysDirFeedThru;\n    int_T rtwGenSfcn;\n  } Sizes;\n\n  /*\n   * Timing:\n   * The following substructure contains information regarding\n   * the timing information for the model.\n   */\n  struct {\n    time_T stepSize;\n    uint32_T clockTick0;\n    uint32_T clockTickH0;\n    time_T stepSize0;\n    uint32_T clockTick1;\n    uint32_T clockTickH1;\n    time_T stepSize1;\n    time_T tStart;\n    time_T tFinal;\n    time_T timeOfLastOutput;\n    SimTimeStep simTimeStep;\n    boolean_T stopRequestedFlag;\n    time_T *sampleTimes;\n    time_T *offsetTimes;\n    int_T *sampleTimeTaskIDPtr;\n    int_T *sampleHits;\n    int_T *perTaskSampleHits;\n    time_T *t;\n    time_T sampleTimesArray[2];\n    time_T offsetTimesArray[2];\n    int_T sampleTimeTaskIDArray[2];\n    int_T sampleHitArray[2];\n    int_T perTaskSampleHitsArray[4];\n    time_T tArray[2];\n  } Timing;\n};\n\n/* Block signals (default storage) */\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern struct B_ATTN_T ATTN_B;\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n/* Block states (default storage) */\nextern struct DW_ATTN_T ATTN_DW;\n\n/* External data declarations for dependent source files */\nextern const real_T ATTN_RGND;         /* real_T ground */\n\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  /* Model entry point functions */\n  extern void ATTN_initialize(void);\n  extern void ATTN_step(void);\n  extern void ATTN_terminate(void);\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n/* Real-time Model object */\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern RT_MODEL_ATTN_T *const ATTN_M;\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n/*-\n * The generated code includes comments that allow you to trace directly\n * back to the appropriate location in the model.  The basic format\n * is <system>/block_name, where system is the system number (uniquely\n * assigned by Simulink) and block_name is the name of the block.\n *\n * Use the MATLAB hilite_system command to trace the generated code back\n * to the model.  For example,\n *\n * hilite_system('<S3>')    - opens system 3\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\n *\n * Here is the system hierarchy for this model\n *\n * '<Root>' : 'ATTN'\n * '<S1>'   : 'ATTN/MATLAB Function'\n * '<S2>'   : 'ATTN/MATLAB Function1'\n * '<S3>'   : 'ATTN/PiezoDriver_1'\n * '<S4>'   : 'ATTN/PiezoDriver_2'\n * '<S5>'   : 'ATTN/RewardDriver'\n * '<S6>'   : 'ATTN/onsetToneDriver'\n * '<S7>'   : 'ATTN/PiezoDriver_1/MATLAB Function2'\n * '<S8>'   : 'ATTN/PiezoDriver_2/MATLAB Function1'\n * '<S9>'   : 'ATTN/RewardDriver/MATLAB Function1'\n * '<S10>'  : 'ATTN/onsetToneDriver/MATLAB Function1'\n */\n#endif                                 /* RTW_HEADER_ATTN_h_ */\n"},{"name":"ATTN_private.h","type":"header","group":"model","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * ATTN_private.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.455\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Fri Dec  1 09:35:43 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_ATTN_private_h_\n#define RTW_HEADER_ATTN_private_h_\n#include \"rtwtypes.h\"\n#include \"multiword_types.h\"\n#include \"ATTN.h\"\n#include \"ATTN_types.h\"\n\n/* Private macros used by the generated code to access rtModel */\n#ifndef rtmIsMajorTimeStep\n#define rtmIsMajorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MAJOR_TIME_STEP)\n#endif\n\n#ifndef rtmIsMinorTimeStep\n#define rtmIsMinorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MINOR_TIME_STEP)\n#endif\n\n#ifndef rtmSetTFinal\n#define rtmSetTFinal(rtm, val)         ((rtm)->Timing.tFinal = (val))\n#endif\n\n#ifndef rtmSetTPtr\n#define rtmSetTPtr(rtm, val)           ((rtm)->Timing.t = (val))\n#endif\n\nextern void* slrtRegisterSignalToLoggingService(uintptr_t sigAddr);\nextern \"C\" void sg_IO191_setup_s(SimStruct *rts);\nextern \"C\" void sg_IO191_ad_s(SimStruct *rts);\nextern \"C\" void sg_IO191_da_s(SimStruct *rts);\nextern \"C\" void sg_IO191_do_s(SimStruct *rts);\nextern \"C\" void sg_IO191_di_s(SimStruct *rts);\nextern void ATTN_MATLABFunction2_Init(DW_MATLABFunction2_ATTN_T *localDW);\nextern void ATTN_MATLABFunction2(real_T rtu_trigger, real_T rtu_duration, real_T\n  rtu_amp, real_T rtu_t, B_MATLABFunction2_ATTN_T *localB,\n  DW_MATLABFunction2_ATTN_T *localDW);\n\n#endif                                 /* RTW_HEADER_ATTN_private_h_ */\n"},{"name":"ATTN_types.h","type":"header","group":"model","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * ATTN_types.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.455\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Fri Dec  1 09:35:43 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_ATTN_types_h_\n#define RTW_HEADER_ATTN_types_h_\n\n/* Forward declaration for rtModel */\ntypedef struct tag_RTM_ATTN_T RT_MODEL_ATTN_T;\n\n#endif                                 /* RTW_HEADER_ATTN_types_h_ */\n"},{"name":"ATTN_cal.cpp","type":"source","group":"data","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Data files","code":"#include \"ATTN_cal.h\"\n#include \"ATTN.h\"\n\n/* Storage class 'PageSwitching' */\nATTN_cal_type ATTN_cal_impl = {\n  /* Variable: SampleTime\n   * Referenced by: '<Root>/SampleTime'\n   */\n  0.001,\n\n  /* Variable: T_npxls\n   * Referenced by: '<Root>/Npxls Trig'\n   */\n  4.0,\n\n  /* Variable: T_pupil\n   * Referenced by: '<Root>/Pupil Trig'\n   */\n  100.0,\n\n  /* Variable: T_whisk\n   * Referenced by: '<Root>/Whisker Trig'\n   */\n  20.0,\n\n  /* Variable: maxFrame\n   * Referenced by: '<Root>/Constant'\n   */\n  600000.0,\n\n  /* Variable: rewardDuration\n   * Referenced by: '<Root>/rewardDuration'\n   */\n  0.05,\n\n  /* Variable: targetSide\n   * Referenced by: '<Root>/targetSide'\n   */\n  0.0,\n\n  /* Variable: trainingStage\n   * Referenced by: '<Root>/trainingStage'\n   */\n  1.0,\n\n  /* Variable: triangleAmplitude\n   * Referenced by: '<Root>/triangleAmplitude'\n   */\n  10.0,\n\n  /* Variable: triangleDuration\n   * Referenced by: '<Root>/triangleDuration'\n   */\n  0.1,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Memory8'\n   */\n  0.0,\n\n  /* Expression: 1\n   * Referenced by: '<Root>/Memory2'\n   */\n  1.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Memory1'\n   */\n  0.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Memory'\n   */\n  0.0,\n\n  /* Computed Parameter: Setup_P1_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parPciSlot\n   * Referenced by: '<Root>/Setup '\n   */\n  -1.0,\n\n  /* Computed Parameter: Setup_P2_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parModuleId\n   * Referenced by: '<Root>/Setup '\n   */\n  1.0,\n\n  /* Computed Parameter: Setup_P3_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parTriggerSignal\n   * Referenced by: '<Root>/Setup '\n   */\n  1.0,\n\n  /* Computed Parameter: Setup_P4_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parAdcChannels\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 2.0 },\n\n  /* Computed Parameter: Setup_P5_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parAdcMode\n   * Referenced by: '<Root>/Setup '\n   */\n  2.0,\n\n  /* Computed Parameter: Setup_P6_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parAdcRanges\n   * Referenced by: '<Root>/Setup '\n   */\n  { 3.0, 3.0 },\n\n  /* Computed Parameter: Setup_P7_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parDacChannels\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 3.0 },\n\n  /* Computed Parameter: Setup_P8_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parDacRanges\n   * Referenced by: '<Root>/Setup '\n   */\n  { 4.0, 4.0 },\n\n  /* Computed Parameter: Setup_P9_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 8.0 },\n\n  /* Expression: parDioFirstControl\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 8.0, 9.0 },\n\n  /* Computed Parameter: Analoginput_P1_Size\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parModuleId\n   * Referenced by: '<Root>/Analog input '\n   */\n  1.0,\n\n  /* Computed Parameter: Analoginput_P2_Size\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parSampleTime\n   * Referenced by: '<Root>/Analog input '\n   */\n  -1.0,\n\n  /* Computed Parameter: Analoginput_P3_Size\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parPciSlot\n   * Referenced by: '<Root>/Analog input '\n   */\n  -1.0,\n\n  /* Computed Parameter: Analoginput_P4_Size\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parAdcChannels\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 2.0 },\n\n  /* Computed Parameter: Analoginput_P5_Size\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parAdcMode\n   * Referenced by: '<Root>/Analog input '\n   */\n  2.0,\n\n  /* Computed Parameter: Analoginput_P6_Size\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parAdcRate\n   * Referenced by: '<Root>/Analog input '\n   */\n  100000.0,\n\n  /* Computed Parameter: Analoginput_P7_Size\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parAdcRanges\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 3.0, 3.0 },\n\n  /* Computed Parameter: Analoginput_P8_Size\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parAdcInitValues\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 0.0, 0.0 },\n\n  /* Computed Parameter: Analoginput_P9_Size\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parAdcResets\n   * Referenced by: '<Root>/Analog input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: [1]\n   * Referenced by: '<Root>/Discrete Filter'\n   */\n  1.0,\n\n  /* Expression: [1 0.004]\n   * Referenced by: '<Root>/Discrete Filter'\n   */\n  { 1.0, 0.004 },\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Discrete Filter'\n   */\n  0.0,\n\n  /* Expression: 0.15\n   * Referenced by: '<Root>/Thrd'\n   */\n  0.15,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Memory11'\n   */\n  0.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Memory7'\n   */\n  0.0,\n\n  /* Expression: 1\n   * Referenced by: '<Root>/Memory3'\n   */\n  1.0,\n\n  /* Expression: 1\n   * Referenced by: '<Root>/Memory4'\n   */\n  1.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Memory9'\n   */\n  0.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Memory5'\n   */\n  0.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Memory6'\n   */\n  0.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Memory10'\n   */\n  0.0,\n\n  /* Computed Parameter: Analogoutput_P1_Size\n   * Referenced by: '<Root>/Analog output '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parModuleId\n   * Referenced by: '<Root>/Analog output '\n   */\n  1.0,\n\n  /* Computed Parameter: Analogoutput_P2_Size\n   * Referenced by: '<Root>/Analog output '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parSampleTime\n   * Referenced by: '<Root>/Analog output '\n   */\n  -1.0,\n\n  /* Computed Parameter: Analogoutput_P3_Size\n   * Referenced by: '<Root>/Analog output '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parPciSlot\n   * Referenced by: '<Root>/Analog output '\n   */\n  -1.0,\n\n  /* Computed Parameter: Analogoutput_P4_Size\n   * Referenced by: '<Root>/Analog output '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parDacChannels\n   * Referenced by: '<Root>/Analog output '\n   */\n  { 1.0, 3.0 },\n\n  /* Computed Parameter: Analogoutput_P5_Size\n   * Referenced by: '<Root>/Analog output '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parDacRanges\n   * Referenced by: '<Root>/Analog output '\n   */\n  { 4.0, 4.0 },\n\n  /* Computed Parameter: Analogoutput_P6_Size\n   * Referenced by: '<Root>/Analog output '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parDacInitValues\n   * Referenced by: '<Root>/Analog output '\n   */\n  { 0.0, 0.0 },\n\n  /* Computed Parameter: Analogoutput_P7_Size\n   * Referenced by: '<Root>/Analog output '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parDacResets\n   * Referenced by: '<Root>/Analog output '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: 1\n   * Referenced by: '<Root>/Whisker Trig'\n   */\n  1.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Whisker Trig'\n   */\n  0.0,\n\n  /* Expression: 2.5\n   * Referenced by: '<Root>/Npxls Trig'\n   */\n  2.5,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Npxls Trig'\n   */\n  0.0,\n\n  /* Expression: 1\n   * Referenced by: '<Root>/Pupil Trig'\n   */\n  1.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Pupil Trig'\n   */\n  0.0,\n\n  /* Expression: 1\n   * Referenced by: '<S5>/Constant4'\n   */\n  1.0,\n\n  /* Computed Parameter: Digitaloutput_P1_Size\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parModuleId\n   * Referenced by: '<Root>/Digital output '\n   */\n  1.0,\n\n  /* Computed Parameter: Digitaloutput_P2_Size\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parSampleTime\n   * Referenced by: '<Root>/Digital output '\n   */\n  0.001,\n\n  /* Computed Parameter: Digitaloutput_P3_Size\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parPciSlot\n   * Referenced by: '<Root>/Digital output '\n   */\n  -1.0,\n\n  /* Computed Parameter: Digitaloutput_P4_Size\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 15.0 },\n\n  /* Expression: parDoChannels\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 15.0,\n    16.0 },\n\n  /* Computed Parameter: Digitaloutput_P5_Size\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 15.0 },\n\n  /* Expression: parDoInitValues\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },\n\n  /* Computed Parameter: Digitaloutput_P6_Size\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 15.0 },\n\n  /* Expression: parDoResets\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },\n\n  /* Computed Parameter: Digitalinput_P1_Size\n   * Referenced by: '<Root>/Digital input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parModuleId\n   * Referenced by: '<Root>/Digital input '\n   */\n  1.0,\n\n  /* Computed Parameter: Digitalinput_P2_Size\n   * Referenced by: '<Root>/Digital input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parSampleTime\n   * Referenced by: '<Root>/Digital input '\n   */\n  0.001,\n\n  /* Computed Parameter: Digitalinput_P3_Size\n   * Referenced by: '<Root>/Digital input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parPciSlot\n   * Referenced by: '<Root>/Digital input '\n   */\n  -1.0,\n\n  /* Computed Parameter: Digitalinput_P4_Size\n   * Referenced by: '<Root>/Digital input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parDiChannels\n   * Referenced by: '<Root>/Digital input '\n   */\n  14.0\n};\n\nATTN_cal_type *ATTN_cal = &ATTN_cal_impl;\n"},{"name":"ATTN_cal.h","type":"header","group":"data","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Data files","code":"#ifndef RTW_HEADER_ATTN_cal_h_\n#define RTW_HEADER_ATTN_cal_h_\n#include \"rtwtypes.h\"\n\n/* Storage class 'PageSwitching', for system '<Root>' */\nstruct ATTN_cal_type {\n  real_T SampleTime;                   /* Variable: SampleTime\n                                        * Referenced by: '<Root>/SampleTime'\n                                        */\n  real_T T_npxls;                      /* Variable: T_npxls\n                                        * Referenced by: '<Root>/Npxls Trig'\n                                        */\n  real_T T_pupil;                      /* Variable: T_pupil\n                                        * Referenced by: '<Root>/Pupil Trig'\n                                        */\n  real_T T_whisk;                      /* Variable: T_whisk\n                                        * Referenced by: '<Root>/Whisker Trig'\n                                        */\n  real_T maxFrame;                     /* Variable: maxFrame\n                                        * Referenced by: '<Root>/Constant'\n                                        */\n  real_T rewardDuration;               /* Variable: rewardDuration\n                                        * Referenced by: '<Root>/rewardDuration'\n                                        */\n  real_T targetSide;                   /* Variable: targetSide\n                                        * Referenced by: '<Root>/targetSide'\n                                        */\n  real_T trainingStage;                /* Variable: trainingStage\n                                        * Referenced by: '<Root>/trainingStage'\n                                        */\n  real_T triangleAmplitude;            /* Variable: triangleAmplitude\n                                        * Referenced by: '<Root>/triangleAmplitude'\n                                        */\n  real_T triangleDuration;             /* Variable: triangleDuration\n                                        * Referenced by: '<Root>/triangleDuration'\n                                        */\n  real_T Memory8_InitialCondition;     /* Expression: 0\n                                        * Referenced by: '<Root>/Memory8'\n                                        */\n  real_T Memory2_InitialCondition;     /* Expression: 1\n                                        * Referenced by: '<Root>/Memory2'\n                                        */\n  real_T Memory1_InitialCondition;     /* Expression: 0\n                                        * Referenced by: '<Root>/Memory1'\n                                        */\n  real_T Memory_InitialCondition;      /* Expression: 0\n                                        * Referenced by: '<Root>/Memory'\n                                        */\n  real_T Setup_P1_Size[2];             /* Computed Parameter: Setup_P1_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P1;                     /* Expression: parPciSlot\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P2_Size[2];             /* Computed Parameter: Setup_P2_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P2;                     /* Expression: parModuleId\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P3_Size[2];             /* Computed Parameter: Setup_P3_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P3;                     /* Expression: parTriggerSignal\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P4_Size[2];             /* Computed Parameter: Setup_P4_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P4[2];                  /* Expression: parAdcChannels\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P5_Size[2];             /* Computed Parameter: Setup_P5_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P5;                     /* Expression: parAdcMode\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P6_Size[2];             /* Computed Parameter: Setup_P6_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P6[2];                  /* Expression: parAdcRanges\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P7_Size[2];             /* Computed Parameter: Setup_P7_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P7[2];                  /* Expression: parDacChannels\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P8_Size[2];             /* Computed Parameter: Setup_P8_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P8[2];                  /* Expression: parDacRanges\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P9_Size[2];             /* Computed Parameter: Setup_P9_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P9[8];                  /* Expression: parDioFirstControl\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Analoginput_P1_Size[2];      /* Computed Parameter: Analoginput_P1_Size\n                                       * Referenced by: '<Root>/Analog input '\n                                       */\n  real_T Analoginput_P1;               /* Expression: parModuleId\n                                        * Referenced by: '<Root>/Analog input '\n                                        */\n  real_T Analoginput_P2_Size[2];      /* Computed Parameter: Analoginput_P2_Size\n                                       * Referenced by: '<Root>/Analog input '\n                                       */\n  real_T Analoginput_P2;               /* Expression: parSampleTime\n                                        * Referenced by: '<Root>/Analog input '\n                                        */\n  real_T Analoginput_P3_Size[2];      /* Computed Parameter: Analoginput_P3_Size\n                                       * Referenced by: '<Root>/Analog input '\n                                       */\n  real_T Analoginput_P3;               /* Expression: parPciSlot\n                                        * Referenced by: '<Root>/Analog input '\n                                        */\n  real_T Analoginput_P4_Size[2];      /* Computed Parameter: Analoginput_P4_Size\n                                       * Referenced by: '<Root>/Analog input '\n                                       */\n  real_T Analoginput_P4[2];            /* Expression: parAdcChannels\n                                        * Referenced by: '<Root>/Analog input '\n                                        */\n  real_T Analoginput_P5_Size[2];      /* Computed Parameter: Analoginput_P5_Size\n                                       * Referenced by: '<Root>/Analog input '\n                                       */\n  real_T Analoginput_P5;               /* Expression: parAdcMode\n                                        * Referenced by: '<Root>/Analog input '\n                                        */\n  real_T Analoginput_P6_Size[2];      /* Computed Parameter: Analoginput_P6_Size\n                                       * Referenced by: '<Root>/Analog input '\n                                       */\n  real_T Analoginput_P6;               /* Expression: parAdcRate\n                                        * Referenced by: '<Root>/Analog input '\n                                        */\n  real_T Analoginput_P7_Size[2];      /* Computed Parameter: Analoginput_P7_Size\n                                       * Referenced by: '<Root>/Analog input '\n                                       */\n  real_T Analoginput_P7[2];            /* Expression: parAdcRanges\n                                        * Referenced by: '<Root>/Analog input '\n                                        */\n  real_T Analoginput_P8_Size[2];      /* Computed Parameter: Analoginput_P8_Size\n                                       * Referenced by: '<Root>/Analog input '\n                                       */\n  real_T Analoginput_P8[2];            /* Expression: parAdcInitValues\n                                        * Referenced by: '<Root>/Analog input '\n                                        */\n  real_T Analoginput_P9_Size[2];      /* Computed Parameter: Analoginput_P9_Size\n                                       * Referenced by: '<Root>/Analog input '\n                                       */\n  real_T Analoginput_P9[2];            /* Expression: parAdcResets\n                                        * Referenced by: '<Root>/Analog input '\n                                        */\n  real_T DiscreteFilter_NumCoef;       /* Expression: [1]\n                                        * Referenced by: '<Root>/Discrete Filter'\n                                        */\n  real_T DiscreteFilter_DenCoef[2];    /* Expression: [1 0.004]\n                                        * Referenced by: '<Root>/Discrete Filter'\n                                        */\n  real_T DiscreteFilter_InitialStates; /* Expression: 0\n                                        * Referenced by: '<Root>/Discrete Filter'\n                                        */\n  real_T Thrd_Value;                   /* Expression: 0.15\n                                        * Referenced by: '<Root>/Thrd'\n                                        */\n  real_T Memory11_InitialCondition;    /* Expression: 0\n                                        * Referenced by: '<Root>/Memory11'\n                                        */\n  real_T Memory7_InitialCondition;     /* Expression: 0\n                                        * Referenced by: '<Root>/Memory7'\n                                        */\n  real_T Memory3_InitialCondition;     /* Expression: 1\n                                        * Referenced by: '<Root>/Memory3'\n                                        */\n  real_T Memory4_InitialCondition;     /* Expression: 1\n                                        * Referenced by: '<Root>/Memory4'\n                                        */\n  real_T Memory9_InitialCondition;     /* Expression: 0\n                                        * Referenced by: '<Root>/Memory9'\n                                        */\n  real_T Memory5_InitialCondition;     /* Expression: 0\n                                        * Referenced by: '<Root>/Memory5'\n                                        */\n  real_T Memory6_InitialCondition;     /* Expression: 0\n                                        * Referenced by: '<Root>/Memory6'\n                                        */\n  real_T Memory10_InitialCondition;    /* Expression: 0\n                                        * Referenced by: '<Root>/Memory10'\n                                        */\n  real_T Analogoutput_P1_Size[2];    /* Computed Parameter: Analogoutput_P1_Size\n                                      * Referenced by: '<Root>/Analog output '\n                                      */\n  real_T Analogoutput_P1;              /* Expression: parModuleId\n                                        * Referenced by: '<Root>/Analog output '\n                                        */\n  real_T Analogoutput_P2_Size[2];    /* Computed Parameter: Analogoutput_P2_Size\n                                      * Referenced by: '<Root>/Analog output '\n                                      */\n  real_T Analogoutput_P2;              /* Expression: parSampleTime\n                                        * Referenced by: '<Root>/Analog output '\n                                        */\n  real_T Analogoutput_P3_Size[2];    /* Computed Parameter: Analogoutput_P3_Size\n                                      * Referenced by: '<Root>/Analog output '\n                                      */\n  real_T Analogoutput_P3;              /* Expression: parPciSlot\n                                        * Referenced by: '<Root>/Analog output '\n                                        */\n  real_T Analogoutput_P4_Size[2];    /* Computed Parameter: Analogoutput_P4_Size\n                                      * Referenced by: '<Root>/Analog output '\n                                      */\n  real_T Analogoutput_P4[2];           /* Expression: parDacChannels\n                                        * Referenced by: '<Root>/Analog output '\n                                        */\n  real_T Analogoutput_P5_Size[2];    /* Computed Parameter: Analogoutput_P5_Size\n                                      * Referenced by: '<Root>/Analog output '\n                                      */\n  real_T Analogoutput_P5[2];           /* Expression: parDacRanges\n                                        * Referenced by: '<Root>/Analog output '\n                                        */\n  real_T Analogoutput_P6_Size[2];    /* Computed Parameter: Analogoutput_P6_Size\n                                      * Referenced by: '<Root>/Analog output '\n                                      */\n  real_T Analogoutput_P6[2];           /* Expression: parDacInitValues\n                                        * Referenced by: '<Root>/Analog output '\n                                        */\n  real_T Analogoutput_P7_Size[2];    /* Computed Parameter: Analogoutput_P7_Size\n                                      * Referenced by: '<Root>/Analog output '\n                                      */\n  real_T Analogoutput_P7[2];           /* Expression: parDacResets\n                                        * Referenced by: '<Root>/Analog output '\n                                        */\n  real_T WhiskerTrig_Amp;              /* Expression: 1\n                                        * Referenced by: '<Root>/Whisker Trig'\n                                        */\n  real_T WhiskerTrig_PhaseDelay;       /* Expression: 0\n                                        * Referenced by: '<Root>/Whisker Trig'\n                                        */\n  real_T NpxlsTrig_Amp;                /* Expression: 2.5\n                                        * Referenced by: '<Root>/Npxls Trig'\n                                        */\n  real_T NpxlsTrig_PhaseDelay;         /* Expression: 0\n                                        * Referenced by: '<Root>/Npxls Trig'\n                                        */\n  real_T PupilTrig_Amp;                /* Expression: 1\n                                        * Referenced by: '<Root>/Pupil Trig'\n                                        */\n  real_T PupilTrig_PhaseDelay;         /* Expression: 0\n                                        * Referenced by: '<Root>/Pupil Trig'\n                                        */\n  real_T Constant4_Value;              /* Expression: 1\n                                        * Referenced by: '<S5>/Constant4'\n                                        */\n  real_T Digitaloutput_P1_Size[2];  /* Computed Parameter: Digitaloutput_P1_Size\n                                     * Referenced by: '<Root>/Digital output '\n                                     */\n  real_T Digitaloutput_P1;             /* Expression: parModuleId\n                                        * Referenced by: '<Root>/Digital output '\n                                        */\n  real_T Digitaloutput_P2_Size[2];  /* Computed Parameter: Digitaloutput_P2_Size\n                                     * Referenced by: '<Root>/Digital output '\n                                     */\n  real_T Digitaloutput_P2;             /* Expression: parSampleTime\n                                        * Referenced by: '<Root>/Digital output '\n                                        */\n  real_T Digitaloutput_P3_Size[2];  /* Computed Parameter: Digitaloutput_P3_Size\n                                     * Referenced by: '<Root>/Digital output '\n                                     */\n  real_T Digitaloutput_P3;             /* Expression: parPciSlot\n                                        * Referenced by: '<Root>/Digital output '\n                                        */\n  real_T Digitaloutput_P4_Size[2];  /* Computed Parameter: Digitaloutput_P4_Size\n                                     * Referenced by: '<Root>/Digital output '\n                                     */\n  real_T Digitaloutput_P4[15];         /* Expression: parDoChannels\n                                        * Referenced by: '<Root>/Digital output '\n                                        */\n  real_T Digitaloutput_P5_Size[2];  /* Computed Parameter: Digitaloutput_P5_Size\n                                     * Referenced by: '<Root>/Digital output '\n                                     */\n  real_T Digitaloutput_P5[15];         /* Expression: parDoInitValues\n                                        * Referenced by: '<Root>/Digital output '\n                                        */\n  real_T Digitaloutput_P6_Size[2];  /* Computed Parameter: Digitaloutput_P6_Size\n                                     * Referenced by: '<Root>/Digital output '\n                                     */\n  real_T Digitaloutput_P6[15];         /* Expression: parDoResets\n                                        * Referenced by: '<Root>/Digital output '\n                                        */\n  real_T Digitalinput_P1_Size[2];    /* Computed Parameter: Digitalinput_P1_Size\n                                      * Referenced by: '<Root>/Digital input '\n                                      */\n  real_T Digitalinput_P1;              /* Expression: parModuleId\n                                        * Referenced by: '<Root>/Digital input '\n                                        */\n  real_T Digitalinput_P2_Size[2];    /* Computed Parameter: Digitalinput_P2_Size\n                                      * Referenced by: '<Root>/Digital input '\n                                      */\n  real_T Digitalinput_P2;              /* Expression: parSampleTime\n                                        * Referenced by: '<Root>/Digital input '\n                                        */\n  real_T Digitalinput_P3_Size[2];    /* Computed Parameter: Digitalinput_P3_Size\n                                      * Referenced by: '<Root>/Digital input '\n                                      */\n  real_T Digitalinput_P3;              /* Expression: parPciSlot\n                                        * Referenced by: '<Root>/Digital input '\n                                        */\n  real_T Digitalinput_P4_Size[2];    /* Computed Parameter: Digitalinput_P4_Size\n                                      * Referenced by: '<Root>/Digital input '\n                                      */\n  real_T Digitalinput_P4;              /* Expression: parDiChannels\n                                        * Referenced by: '<Root>/Digital input '\n                                        */\n};\n\n/* Storage class 'PageSwitching' */\nextern ATTN_cal_type ATTN_cal_impl;\nextern ATTN_cal_type *ATTN_cal;\n\n#endif                                 /* RTW_HEADER_ATTN_cal_h_ */\n"},{"name":"multiword_types.h","type":"header","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * multiword_types.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.455\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Fri Dec  1 09:35:43 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef MULTIWORD_TYPES_H\n#define MULTIWORD_TYPES_H\n#include \"rtwtypes.h\"\n\n/*\n * Definitions supporting external data access\n */\ntypedef int64_T chunk_T;\ntypedef uint64_T uchunk_T;\n\n/*\n * MultiWord supporting definitions\n */\ntypedef long long longlong_T;\n\n/*\n * MultiWord types\n */\ntypedef struct {\n  uint64_T chunks[2];\n} int128m_T;\n\ntypedef struct {\n  int128m_T re;\n  int128m_T im;\n} cint128m_T;\n\ntypedef struct {\n  uint64_T chunks[2];\n} uint128m_T;\n\ntypedef struct {\n  uint128m_T re;\n  uint128m_T im;\n} cuint128m_T;\n\ntypedef struct {\n  uint64_T chunks[3];\n} int192m_T;\n\ntypedef struct {\n  int192m_T re;\n  int192m_T im;\n} cint192m_T;\n\ntypedef struct {\n  uint64_T chunks[3];\n} uint192m_T;\n\ntypedef struct {\n  uint192m_T re;\n  uint192m_T im;\n} cuint192m_T;\n\ntypedef struct {\n  uint64_T chunks[4];\n} int256m_T;\n\ntypedef struct {\n  int256m_T re;\n  int256m_T im;\n} cint256m_T;\n\ntypedef struct {\n  uint64_T chunks[4];\n} uint256m_T;\n\ntypedef struct {\n  uint256m_T re;\n  uint256m_T im;\n} cuint256m_T;\n\ntypedef struct {\n  uint64_T chunks[5];\n} int320m_T;\n\ntypedef struct {\n  int320m_T re;\n  int320m_T im;\n} cint320m_T;\n\ntypedef struct {\n  uint64_T chunks[5];\n} uint320m_T;\n\ntypedef struct {\n  uint320m_T re;\n  uint320m_T im;\n} cuint320m_T;\n\ntypedef struct {\n  uint64_T chunks[6];\n} int384m_T;\n\ntypedef struct {\n  int384m_T re;\n  int384m_T im;\n} cint384m_T;\n\ntypedef struct {\n  uint64_T chunks[6];\n} uint384m_T;\n\ntypedef struct {\n  uint384m_T re;\n  uint384m_T im;\n} cuint384m_T;\n\ntypedef struct {\n  uint64_T chunks[7];\n} int448m_T;\n\ntypedef struct {\n  int448m_T re;\n  int448m_T im;\n} cint448m_T;\n\ntypedef struct {\n  uint64_T chunks[7];\n} uint448m_T;\n\ntypedef struct {\n  uint448m_T re;\n  uint448m_T im;\n} cuint448m_T;\n\ntypedef struct {\n  uint64_T chunks[8];\n} int512m_T;\n\ntypedef struct {\n  int512m_T re;\n  int512m_T im;\n} cint512m_T;\n\ntypedef struct {\n  uint64_T chunks[8];\n} uint512m_T;\n\ntypedef struct {\n  uint512m_T re;\n  uint512m_T im;\n} cuint512m_T;\n\ntypedef struct {\n  uint64_T chunks[9];\n} int576m_T;\n\ntypedef struct {\n  int576m_T re;\n  int576m_T im;\n} cint576m_T;\n\ntypedef struct {\n  uint64_T chunks[9];\n} uint576m_T;\n\ntypedef struct {\n  uint576m_T re;\n  uint576m_T im;\n} cuint576m_T;\n\ntypedef struct {\n  uint64_T chunks[10];\n} int640m_T;\n\ntypedef struct {\n  int640m_T re;\n  int640m_T im;\n} cint640m_T;\n\ntypedef struct {\n  uint64_T chunks[10];\n} uint640m_T;\n\ntypedef struct {\n  uint640m_T re;\n  uint640m_T im;\n} cuint640m_T;\n\ntypedef struct {\n  uint64_T chunks[11];\n} int704m_T;\n\ntypedef struct {\n  int704m_T re;\n  int704m_T im;\n} cint704m_T;\n\ntypedef struct {\n  uint64_T chunks[11];\n} uint704m_T;\n\ntypedef struct {\n  uint704m_T re;\n  uint704m_T im;\n} cuint704m_T;\n\ntypedef struct {\n  uint64_T chunks[12];\n} int768m_T;\n\ntypedef struct {\n  int768m_T re;\n  int768m_T im;\n} cint768m_T;\n\ntypedef struct {\n  uint64_T chunks[12];\n} uint768m_T;\n\ntypedef struct {\n  uint768m_T re;\n  uint768m_T im;\n} cuint768m_T;\n\ntypedef struct {\n  uint64_T chunks[13];\n} int832m_T;\n\ntypedef struct {\n  int832m_T re;\n  int832m_T im;\n} cint832m_T;\n\ntypedef struct {\n  uint64_T chunks[13];\n} uint832m_T;\n\ntypedef struct {\n  uint832m_T re;\n  uint832m_T im;\n} cuint832m_T;\n\ntypedef struct {\n  uint64_T chunks[14];\n} int896m_T;\n\ntypedef struct {\n  int896m_T re;\n  int896m_T im;\n} cint896m_T;\n\ntypedef struct {\n  uint64_T chunks[14];\n} uint896m_T;\n\ntypedef struct {\n  uint896m_T re;\n  uint896m_T im;\n} cuint896m_T;\n\ntypedef struct {\n  uint64_T chunks[15];\n} int960m_T;\n\ntypedef struct {\n  int960m_T re;\n  int960m_T im;\n} cint960m_T;\n\ntypedef struct {\n  uint64_T chunks[15];\n} uint960m_T;\n\ntypedef struct {\n  uint960m_T re;\n  uint960m_T im;\n} cuint960m_T;\n\ntypedef struct {\n  uint64_T chunks[16];\n} int1024m_T;\n\ntypedef struct {\n  int1024m_T re;\n  int1024m_T im;\n} cint1024m_T;\n\ntypedef struct {\n  uint64_T chunks[16];\n} uint1024m_T;\n\ntypedef struct {\n  uint1024m_T re;\n  uint1024m_T im;\n} cuint1024m_T;\n\ntypedef struct {\n  uint64_T chunks[17];\n} int1088m_T;\n\ntypedef struct {\n  int1088m_T re;\n  int1088m_T im;\n} cint1088m_T;\n\ntypedef struct {\n  uint64_T chunks[17];\n} uint1088m_T;\n\ntypedef struct {\n  uint1088m_T re;\n  uint1088m_T im;\n} cuint1088m_T;\n\ntypedef struct {\n  uint64_T chunks[18];\n} int1152m_T;\n\ntypedef struct {\n  int1152m_T re;\n  int1152m_T im;\n} cint1152m_T;\n\ntypedef struct {\n  uint64_T chunks[18];\n} uint1152m_T;\n\ntypedef struct {\n  uint1152m_T re;\n  uint1152m_T im;\n} cuint1152m_T;\n\ntypedef struct {\n  uint64_T chunks[19];\n} int1216m_T;\n\ntypedef struct {\n  int1216m_T re;\n  int1216m_T im;\n} cint1216m_T;\n\ntypedef struct {\n  uint64_T chunks[19];\n} uint1216m_T;\n\ntypedef struct {\n  uint1216m_T re;\n  uint1216m_T im;\n} cuint1216m_T;\n\ntypedef struct {\n  uint64_T chunks[20];\n} int1280m_T;\n\ntypedef struct {\n  int1280m_T re;\n  int1280m_T im;\n} cint1280m_T;\n\ntypedef struct {\n  uint64_T chunks[20];\n} uint1280m_T;\n\ntypedef struct {\n  uint1280m_T re;\n  uint1280m_T im;\n} cuint1280m_T;\n\ntypedef struct {\n  uint64_T chunks[21];\n} int1344m_T;\n\ntypedef struct {\n  int1344m_T re;\n  int1344m_T im;\n} cint1344m_T;\n\ntypedef struct {\n  uint64_T chunks[21];\n} uint1344m_T;\n\ntypedef struct {\n  uint1344m_T re;\n  uint1344m_T im;\n} cuint1344m_T;\n\ntypedef struct {\n  uint64_T chunks[22];\n} int1408m_T;\n\ntypedef struct {\n  int1408m_T re;\n  int1408m_T im;\n} cint1408m_T;\n\ntypedef struct {\n  uint64_T chunks[22];\n} uint1408m_T;\n\ntypedef struct {\n  uint1408m_T re;\n  uint1408m_T im;\n} cuint1408m_T;\n\ntypedef struct {\n  uint64_T chunks[23];\n} int1472m_T;\n\ntypedef struct {\n  int1472m_T re;\n  int1472m_T im;\n} cint1472m_T;\n\ntypedef struct {\n  uint64_T chunks[23];\n} uint1472m_T;\n\ntypedef struct {\n  uint1472m_T re;\n  uint1472m_T im;\n} cuint1472m_T;\n\ntypedef struct {\n  uint64_T chunks[24];\n} int1536m_T;\n\ntypedef struct {\n  int1536m_T re;\n  int1536m_T im;\n} cint1536m_T;\n\ntypedef struct {\n  uint64_T chunks[24];\n} uint1536m_T;\n\ntypedef struct {\n  uint1536m_T re;\n  uint1536m_T im;\n} cuint1536m_T;\n\ntypedef struct {\n  uint64_T chunks[25];\n} int1600m_T;\n\ntypedef struct {\n  int1600m_T re;\n  int1600m_T im;\n} cint1600m_T;\n\ntypedef struct {\n  uint64_T chunks[25];\n} uint1600m_T;\n\ntypedef struct {\n  uint1600m_T re;\n  uint1600m_T im;\n} cuint1600m_T;\n\ntypedef struct {\n  uint64_T chunks[26];\n} int1664m_T;\n\ntypedef struct {\n  int1664m_T re;\n  int1664m_T im;\n} cint1664m_T;\n\ntypedef struct {\n  uint64_T chunks[26];\n} uint1664m_T;\n\ntypedef struct {\n  uint1664m_T re;\n  uint1664m_T im;\n} cuint1664m_T;\n\ntypedef struct {\n  uint64_T chunks[27];\n} int1728m_T;\n\ntypedef struct {\n  int1728m_T re;\n  int1728m_T im;\n} cint1728m_T;\n\ntypedef struct {\n  uint64_T chunks[27];\n} uint1728m_T;\n\ntypedef struct {\n  uint1728m_T re;\n  uint1728m_T im;\n} cuint1728m_T;\n\ntypedef struct {\n  uint64_T chunks[28];\n} int1792m_T;\n\ntypedef struct {\n  int1792m_T re;\n  int1792m_T im;\n} cint1792m_T;\n\ntypedef struct {\n  uint64_T chunks[28];\n} uint1792m_T;\n\ntypedef struct {\n  uint1792m_T re;\n  uint1792m_T im;\n} cuint1792m_T;\n\ntypedef struct {\n  uint64_T chunks[29];\n} int1856m_T;\n\ntypedef struct {\n  int1856m_T re;\n  int1856m_T im;\n} cint1856m_T;\n\ntypedef struct {\n  uint64_T chunks[29];\n} uint1856m_T;\n\ntypedef struct {\n  uint1856m_T re;\n  uint1856m_T im;\n} cuint1856m_T;\n\ntypedef struct {\n  uint64_T chunks[30];\n} int1920m_T;\n\ntypedef struct {\n  int1920m_T re;\n  int1920m_T im;\n} cint1920m_T;\n\ntypedef struct {\n  uint64_T chunks[30];\n} uint1920m_T;\n\ntypedef struct {\n  uint1920m_T re;\n  uint1920m_T im;\n} cuint1920m_T;\n\ntypedef struct {\n  uint64_T chunks[31];\n} int1984m_T;\n\ntypedef struct {\n  int1984m_T re;\n  int1984m_T im;\n} cint1984m_T;\n\ntypedef struct {\n  uint64_T chunks[31];\n} uint1984m_T;\n\ntypedef struct {\n  uint1984m_T re;\n  uint1984m_T im;\n} cuint1984m_T;\n\ntypedef struct {\n  uint64_T chunks[32];\n} int2048m_T;\n\ntypedef struct {\n  int2048m_T re;\n  int2048m_T im;\n} cint2048m_T;\n\ntypedef struct {\n  uint64_T chunks[32];\n} uint2048m_T;\n\ntypedef struct {\n  uint2048m_T re;\n  uint2048m_T im;\n} cuint2048m_T;\n\n#endif                                 /* MULTIWORD_TYPES_H */\n"},{"name":"rtGetInf.cpp","type":"source","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetInf.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.455\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Fri Dec  1 09:35:43 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"rtwtypes.h\"\n\nextern \"C\"\n{\n\n#include \"rtGetInf.h\"\n\n}\n\n#include <stddef.h>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#define NumBitsPerChar                 8U\n\nextern \"C\"\n{\n  /*\n   * Initialize rtInf needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real_T rtGetInf(void)\n  {\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n    real_T inf = 0.0;\n    if (bitsPerReal == 32U) {\n      inf = rtGetInfF();\n    } else {\n      uint16_T one = 1U;\n      enum {\n        LittleEndian,\n        BigEndian\n      } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\n      switch (machByteOrder) {\n       case LittleEndian:\n        {\n          union {\n            LittleEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0x7FF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          inf = tmpVal.fltVal;\n          break;\n        }\n\n       case BigEndian:\n        {\n          union {\n            BigEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0x7FF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          inf = tmpVal.fltVal;\n          break;\n        }\n      }\n    }\n\n    return inf;\n  }\n\n  /*\n   * Initialize rtInfF needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real32_T rtGetInfF(void)\n  {\n    IEEESingle infF;\n    infF.wordL.wordLuint = 0x7F800000U;\n    return infF.wordL.wordLreal;\n  }\n\n  /*\n   * Initialize rtMinusInf needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real_T rtGetMinusInf(void)\n  {\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n    real_T minf = 0.0;\n    if (bitsPerReal == 32U) {\n      minf = rtGetMinusInfF();\n    } else {\n      uint16_T one = 1U;\n      enum {\n        LittleEndian,\n        BigEndian\n      } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\n      switch (machByteOrder) {\n       case LittleEndian:\n        {\n          union {\n            LittleEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0xFFF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          minf = tmpVal.fltVal;\n          break;\n        }\n\n       case BigEndian:\n        {\n          union {\n            BigEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0xFFF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          minf = tmpVal.fltVal;\n          break;\n        }\n      }\n    }\n\n    return minf;\n  }\n\n  /*\n   * Initialize rtMinusInfF needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real32_T rtGetMinusInfF(void)\n  {\n    IEEESingle minfF;\n    minfF.wordL.wordLuint = 0xFF800000U;\n    return minfF.wordL.wordLreal;\n  }\n}\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetInf.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.455\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Fri Dec  1 09:35:43 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rtGetInf_h_\n#define RTW_HEADER_rtGetInf_h_\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#include \"rtwtypes.h\"\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern real_T rtGetInf(void);\n  extern real32_T rtGetInfF(void);\n  extern real_T rtGetMinusInf(void);\n  extern real32_T rtGetMinusInfF(void);\n\n#ifdef __cplusplus\n\n}                                      /* extern \"C\" */\n\n#endif\n#endif                                 /* RTW_HEADER_rtGetInf_h_ */\n"},{"name":"rtGetNaN.cpp","type":"source","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetNaN.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.455\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Fri Dec  1 09:35:43 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"rtwtypes.h\"\n\nextern \"C\"\n{\n\n#include \"rtGetNaN.h\"\n\n}\n\n#include <stddef.h>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#define NumBitsPerChar                 8U\n\nextern \"C\"\n{\n  /*\n   * Initialize rtNaN needed by the generated code.\n   * NaN is initialized as non-signaling. Assumes IEEE.\n   */\n  real_T rtGetNaN(void)\n  {\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n    real_T nan = 0.0;\n    if (bitsPerReal == 32U) {\n      nan = rtGetNaNF();\n    } else {\n      uint16_T one = 1U;\n      enum {\n        LittleEndian,\n        BigEndian\n      } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\n      switch (machByteOrder) {\n       case LittleEndian:\n        {\n          union {\n            LittleEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0xFFF80000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          nan = tmpVal.fltVal;\n          break;\n        }\n\n       case BigEndian:\n        {\n          union {\n            BigEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0x7FFFFFFFU;\n          tmpVal.bitVal.words.wordL = 0xFFFFFFFFU;\n          nan = tmpVal.fltVal;\n          break;\n        }\n      }\n    }\n\n    return nan;\n  }\n\n  /*\n   * Initialize rtNaNF needed by the generated code.\n   * NaN is initialized as non-signaling. Assumes IEEE.\n   */\n  real32_T rtGetNaNF(void)\n  {\n    IEEESingle nanF = { { 0.0F } };\n\n    uint16_T one = 1U;\n    enum {\n      LittleEndian,\n      BigEndian\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\n    switch (machByteOrder) {\n     case LittleEndian:\n      {\n        nanF.wordL.wordLuint = 0xFFC00000U;\n        break;\n      }\n\n     case BigEndian:\n      {\n        nanF.wordL.wordLuint = 0x7FFFFFFFU;\n        break;\n      }\n    }\n\n    return nanF.wordL.wordLreal;\n  }\n}\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetNaN.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.455\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Fri Dec  1 09:35:43 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rtGetNaN_h_\n#define RTW_HEADER_rtGetNaN_h_\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#include \"rtwtypes.h\"\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern real_T rtGetNaN(void);\n  extern real32_T rtGetNaNF(void);\n\n#ifdef __cplusplus\n\n}                                      /* extern \"C\" */\n\n#endif\n#endif                                 /* RTW_HEADER_rtGetNaN_h_ */\n"},{"name":"rt_nonfinite.cpp","type":"source","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rt_nonfinite.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.455\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Fri Dec  1 09:35:43 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\nextern \"C\"\n{\n\n#include \"rtGetNaN.h\"\n\n}\n\nextern \"C\"\n{\n\n#include \"rtGetInf.h\"\n\n}\n\n#include <stddef.h>\n#include \"rtwtypes.h\"\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#define NumBitsPerChar                 8U\n\nextern \"C\"\n{\n  real_T rtInf;\n  real_T rtMinusInf;\n  real_T rtNaN;\n  real32_T rtInfF;\n  real32_T rtMinusInfF;\n  real32_T rtNaNF;\n}\n\nextern \"C\"\n{\n  /*\n   * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\n   * generated code. NaN is initialized as non-signaling. Assumes IEEE.\n   */\n  void rt_InitInfAndNaN(size_t realSize)\n  {\n    (void) (realSize);\n    rtNaN = rtGetNaN();\n    rtNaNF = rtGetNaNF();\n    rtInf = rtGetInf();\n    rtInfF = rtGetInfF();\n    rtMinusInf = rtGetMinusInf();\n    rtMinusInfF = rtGetMinusInfF();\n  }\n\n  /* Test if value is infinite */\n  boolean_T rtIsInf(real_T value)\n  {\n    return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\n  }\n\n  /* Test if single-precision value is infinite */\n  boolean_T rtIsInfF(real32_T value)\n  {\n    return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\n  }\n\n  /* Test if value is not a number */\n  boolean_T rtIsNaN(real_T value)\n  {\n    boolean_T result = (boolean_T) 0;\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n    if (bitsPerReal == 32U) {\n      result = rtIsNaNF((real32_T)value);\n    } else {\n      union {\n        LittleEndianIEEEDouble bitVal;\n        real_T fltVal;\n      } tmpVal;\n\n      tmpVal.fltVal = value;\n      result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) ==\n                           0x7FF00000 &&\n                           ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\n                            (tmpVal.bitVal.words.wordL != 0) ));\n    }\n\n    return result;\n  }\n\n  /* Test if single-precision value is not a number */\n  boolean_T rtIsNaNF(real32_T value)\n  {\n    IEEESingle tmp;\n    tmp.wordL.wordLreal = value;\n    return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\n                       (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\n  }\n}\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rt_nonfinite.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.455\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Fri Dec  1 09:35:43 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rt_nonfinite_h_\n#define RTW_HEADER_rt_nonfinite_h_\n#include <stddef.h>\n#include \"rtwtypes.h\"\n#define NOT_USING_NONFINITE_LITERALS   1\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern real_T rtInf;\n  extern real_T rtMinusInf;\n  extern real_T rtNaN;\n  extern real32_T rtInfF;\n  extern real32_T rtMinusInfF;\n  extern real32_T rtNaNF;\n  extern void rt_InitInfAndNaN(size_t realSize);\n  extern boolean_T rtIsInf(real_T value);\n  extern boolean_T rtIsInfF(real32_T value);\n  extern boolean_T rtIsNaN(real_T value);\n  extern boolean_T rtIsNaNF(real32_T value);\n  struct BigEndianIEEEDouble {\n    struct {\n      uint32_T wordH;\n      uint32_T wordL;\n    } words;\n  };\n\n  struct LittleEndianIEEEDouble {\n    struct {\n      uint32_T wordL;\n      uint32_T wordH;\n    } words;\n  };\n\n  struct IEEESingle {\n    union {\n      real32_T wordLreal;\n      uint32_T wordLuint;\n    } wordL;\n  };\n\n#ifdef __cplusplus\n\n}                                      /* extern \"C\" */\n\n#endif\n#endif                                 /* RTW_HEADER_rt_nonfinite_h_ */\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtwtypes.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.455\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Fri Dec  1 09:35:43 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTWTYPES_H\n#define RTWTYPES_H\n#include \"tmwtypes.h\"\n#ifndef POINTER_T\n#define POINTER_T\n\ntypedef void * pointer_T;\n\n#endif\n\n/* Logical type definitions */\n#if (!defined(__cplusplus))\n#ifndef false\n#define false                          (0U)\n#endif\n\n#ifndef true\n#define true                           (1U)\n#endif\n#endif\n\n#ifndef INT64_T\n#define INT64_T\n\ntypedef long int64_T;\n\n#define MAX_int64_T                    ((int64_T)(9223372036854775807L))\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807L-1L))\n#endif\n\n#ifndef UINT64_T\n#define UINT64_T\n\ntypedef unsigned long uint64_T;\n\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFUL))\n#endif\n\n/*===========================================================================*\n * Additional complex number type definitions                                           *\n *===========================================================================*/\n#ifndef CINT64_T\n#define CINT64_T\n\ntypedef struct {\n  int64_T re;\n  int64_T im;\n} cint64_T;\n\n#endif\n\n#ifndef CUINT64_T\n#define CUINT64_T\n\ntypedef struct {\n  uint64_T re;\n  uint64_T im;\n} cuint64_T;\n\n#endif\n#endif                                 /* RTWTYPES_H */\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Interface files","code":"/*\n *  rtmodel.h:\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"ATTN\".\n *\n * Model version              : 1.455\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Fri Dec  1 09:35:43 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rtmodel_h_\n#define RTW_HEADER_rtmodel_h_\n#include \"ATTN.h\"\n#define GRTINTERFACE                   0\n#endif                                 /* RTW_HEADER_rtmodel_h_ */\n"},{"name":"sg_IO191_ad_s.c","type":"source","group":"interface","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw/../../../.speedgoat/speedgoatlib/R2023a/9.6.1.1_4/sg_blocks/analog","tag":"","groupDisplay":"Interface files","code":"// Copyright 2006-2023 Speedgoat GmbH\r\n\r\n#define S_FUNCTION_LEVEL    (0xd87+330-0xecf)\r\n#undef S_FUNCTION_NAME\r\n#define S_FUNCTION_NAME     sg_IO191_ad_s\r\n#include \"sg_IO191.h\"\r\n#ifndef MATLAB_MEX_FILE\r\n#include \"sg_printf.h\"\r\n#include \"sg_common.h\"\r\nvoid readPciBar(sg_PCIDevice*z7c46aa329e,int16_t bus,int16_t slot,int16_t z1e0fd5210f);\r\n#else\r\n#include \"mex.h\"\r\n#endif\r\n#include \"sg_callback.h\"\r\n#define ze13f49a01f           ssGetSFcnParam(S, (0x1421+4652-0x264d))\r\n#define z3832b85a32           ssGetSFcnParam(S, (0x82d+2280-0x1114))\r\n#define z702a26a5e9                ssGetSFcnParam(S, (0x141f+3266-0x20df))\r\n#define z3644586f49         ssGetSFcnParam(S, (0x6bc+3711-0x1538))\r\n#define z8d5c288b32         ssGetSFcnParam(S, (0x1a40+450-0x1bfe))\r\n#define zb66856d060         ssGetSFcnParam(S, (0x20ad+932-0x244c))\r\n#define z9876548c58         ssGetSFcnParam(S, (0x303+2144-0xb5d))\r\n#define zb093e77094      ssGetSFcnParam(S, (0x1650+3950-0x25b7))\r\n#define z2948f18e24        ssGetSFcnParam(S, (0x1310+1501-0x18e5))\r\n#define zdf24515981                           ((0x92c+2706-0x13b5))\r\n#define z7e2eeaa57c          ((0x1dfc+2294-0x26f2))\r\n#define zc0ced48ecf              ((0x770+2705-0x1200))\r\n#define z2e6483d505              ((0x110a+5601-0x26e9))\r\n#define zc5ce4cb81a              ((0x40d+302-0x53b))\r\n#define z0194338df7         ((0x21a0+274-0x22b2))\r\n#define z2b17e2ee3b              ((0x44b+4814-0x1718))\r\nstatic double zfc19727a48(uint32_t zf4d6a48e37);static char msg[z71934bf57c];static void mdlInitializeSizes(SimStruct*S){uint16_t i;ssSetNumSFcnParams(S,zdf24515981);if(ssGetNumSFcnParams(S)!=ssGetSFcnParamsCount(S)){sprintf(msg,\"\\x57\\x72\\x6f\\x6e\\x67\\x20\\x6e\\x75\\x6d\\x62\\x65\\x72\\x20\\x6f\\x66\\x20\\x69\\x6e\\x70\\x75\\x74\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x70\\x61\\x73\\x73\\x65\\x64\\x2e\" \"\\n\" \"\\x25\\x64\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x61\\x72\\x65\\x20\\x65\\x78\\x70\\x65\\x63\\x74\\x65\\x64\" \"\\n\",zdf24515981);ssSetErrorStatus(S,msg);return;}ssSetNumContStates(S,(0x49a+6035-0x1c2d));ssSetNumDiscStates(S,(0xbbd+3468-0x1949));if(!ssSetNumInputPorts(S,(0xebf+491-0x10aa)))return;if(!ssSetNumOutputPorts(S,(int)mxGetN(z3644586f49)))return;for(i=(0x26b+6461-0x1ba8);i<(int)mxGetN(z3644586f49);i++){ssSetOutputPortWidth(S,i,(0xdf5+2237-0x16b1));}ssSetNumSampleTimes(S,(0x5af+2164-0xe22));ssSetNumRWork(S,zc5ce4cb81a);ssSetNumIWork(S,z2e6483d505);ssSetNumPWork(S,z2b17e2ee3b);ssSetNumModes(S,(0x130+4427-0x127b));ssSetNumNonsampledZCs(S,(0x486+1293-0x993));for(i=(0x135a+368-0x14ca);i<zdf24515981;i++){ssSetSFcnParamTunable(S,i,(0x5eb+5912-0x1d03));}ssSetOptions(S,SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME|SS_OPTION_EXCEPTION_FREE_CODE|SS_OPTION_RUNTIME_EXCEPTION_FREE_CODE);}static void mdlInitializeSampleTimes(SimStruct*S){if(mxGetPr(z3832b85a32)[(0xbc9+611-0xe2c)]==-1.0){ssSetSampleTime(S,(0xf9d+3333-0x1ca2),INHERITED_SAMPLE_TIME);ssSetOffsetTime(S,(0xa0f+3396-0x1753),FIXED_IN_MINOR_STEP_OFFSET);}else{ssSetSampleTime(S,(0x2e3+889-0x65c),mxGetPr(z3832b85a32)[(0xb5d+6245-0x23c2)]);ssSetOffsetTime(S,(0xa80+96-0xae0),0.0);}ssSetModelReferenceSampleTimeDefaultInheritance(S);}\r\n#ifndef MATLAB_MEX_FILE\r\nstatic void sg_ModelLoad(SimStruct*S){}static void sg_ModelStart(SimStruct*S){sg_PCIDevice zeccbadd9b3;uint32_t bus,slot,za0d38ae598,ze5e89e1937,i;uint16_t z4e3026977c,zf91d71c6d9;volatile uint32_t*z27fd94ac66;if(mxGetN(z702a26a5e9)==(0x11b2+4500-0x2345)){bus=(0x8f8+5136-0x1d08);slot=(uint32_t)mxGetPr(z702a26a5e9)[(0xbc2+6909-0x26bf)];}else{bus=(uint32_t)mxGetPr(z702a26a5e9)[(0x730+109-0x79d)];slot=(uint32_t)mxGetPr(z702a26a5e9)[(0x17e1+1839-0x1f0f)];}za0d38ae598=((uint32_t)mxGetPr(ze13f49a01f)[(0x1cb2+361-0x1e1b)]);if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,za1afbacc4a,z78f5b4c5a6,z2bc00458b9,za0d38ae598,bus,slot)!=(0x3a8+8380-0x2464)){if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,zb765876dc5,z44a525e63d,za64fcbac7d,za0d38ae598,bus,slot)!=(0x83f+3255-0x14f6)){ssSetErrorStatus(S,pSgErrorStr);return;}}\r\n#ifdef _MSC_BUILD\r\nreadPciBar(&zeccbadd9b3,zeccbadd9b3.bus,zeccbadd9b3.slot,(0x6c4+3428-0x1428));\r\n#endif\r\nz27fd94ac66=(volatile uint32_t*)sg_mapMemory(&zeccbadd9b3,(0x168a+226-0x176a));zf91d71c6d9=(uint16_t)mxGetN(z3644586f49);ssSetPWorkValue(S,z0194338df7,(uint32_t*)z27fd94ac66);ssSetIWorkValue(S,z7e2eeaa57c,zf91d71c6d9);if(z27fd94ac66[REVISION]<zb5135f698e){sprintf(msg,\"\\x25\\x73\\x20\\x4d\\x6f\\x64\\x75\\x6c\\x65\\x20\\x49\\x44\\x20\\x25\\x64\\x20\\x46\\x69\\x72\\x6d\\x77\\x61\\x72\\x65\\x20\\x30\\x78\\x25\\x58\\x20\\x69\\x73\\x20\\x6f\\x75\\x74\\x64\\x61\\x74\\x65\\x64\\x2c\\x20\\x70\\x6c\\x65\\x61\\x73\\x65\\x20\\x63\\x6f\\x6e\\x74\\x61\\x63\\x74\\x20\\x53\\x70\\x65\\x65\\x64\\x67\\x6f\\x61\\x74\\x20\\x73\\x75\\x70\\x70\\x6f\\x72\\x74\\x2e\" \"\\n\",DEVNAME,za0d38ae598,z27fd94ac66[REVISION]);ssSetErrorStatus(S,msg);return;}z27fd94ac66[BRP]=((0x1ffa+403-0x218c)<<zbef81c3fd0);z27fd94ac66[z469883b65e]=(0x1175+2396-0x1ad1);z27fd94ac66[zfcd2c661f6]=(uint32_t)(z27fd94ac66[z24765e17f8]/z1a910f8330);SG_PRINTF_DEBUG(\"\\x41\\x44\\x43\\x5f\\x53\\x43\\x41\\x4e\\x5f\\x52\\x41\\x54\\x45\\x20\\x25\\x58\" \"\\n\",z27fd94ac66[zfcd2c661f6]);ze5e89e1937=(0x10f5+710-0x13bb);for(i=(0x7b8+7005-0x2315);i<zf91d71c6d9;i++){z4e3026977c=(uint16_t)mxGetPr(z3644586f49)[i]-(0x1eb+1714-0x89c);switch((uint16_t)mxGetPr(z9876548c58)[i]){case(0x7c7+6388-0x20ba):ze5e89e1937|=(z4eb3456176<<(z4e3026977c*(0x696+4149-0x16c7)));break;case(0x13bc+3824-0x22aa):ze5e89e1937|=(z7239c371e4<<(z4e3026977c*(0x95c+3508-0x170c)));break;case(0x7e9+429-0x993):ze5e89e1937|=(z65195ba21a<<(z4e3026977c*(0x10d6+3390-0x1e10)));break;case(0xb1b+1951-0x12b6):ze5e89e1937|=(z769e3cf99a<<(z4e3026977c*(0x10a3+377-0x1218)));break;case(0xd84+3455-0x1afe):ze5e89e1937|=(zad88ee04d7<<(z4e3026977c*(0x53d+7502-0x2287)));break;case(0x17d2+2662-0x2232):ze5e89e1937|=(z04726aa6f4<<(z4e3026977c*(0xb6f+4410-0x1ca5)));break;case(0x602+7248-0x224b):ze5e89e1937|=(zca8a2e109e<<(z4e3026977c*(0x9d4+6839-0x2487)));break;default:sprintf(msg,\"\\x41\\x6e\\x61\\x6c\\x6f\\x67\\x20\\x49\\x6e\\x70\\x75\\x74\\x73\\x20\\x75\\x6e\\x6b\\x6e\\x6f\\x77\\x6e\\x20\\x76\\x6f\\x6c\\x74\\x61\\x67\\x65\");ssSetErrorStatus(S,msg);break;}}z27fd94ac66[z3f2dd8a551]=ze5e89e1937;SG_PRINTF_DEBUG(\"\\x47\\x61\\x69\\x6e\\x20\\x72\\x65\\x67\\x69\\x73\\x74\\x65\\x72\\x3a\\x20\\x25\\x58\\x20\" \"\\n\",ze5e89e1937);ssSetIWorkValue(S,zc0ced48ecf,(0xfab+4387-0x20cd));}static void sg_ModelStep(SimStruct*S){uint16_t zf91d71c6d9=ssGetIWorkValue(S,z7e2eeaa57c);uint16_t z4d3816b14e=(uint16_t)mxGetPr(z3644586f49)[zf91d71c6d9-(0xd9+7701-0x1eed)]-(0x2211+510-0x240e);volatile uint32_t*z27fd94ac66=ssGetPWorkValue(S,z0194338df7);uint32_t ze77fa94a00=(uint32_t)mxGetPr(z8d5c288b32)[(0x8bb+460-0xa87)]-(0x1035+2325-0x1949);uint32_t i,z812c65ff2f,z297b36fb23,z41c8844f54;double*y;if((uint16_t)ssGetIWorkValue(S,zc0ced48ecf)==(0x2208+15-0x2216)){z27fd94ac66[z75b6a00559]=393322|((z4d3816b14e&(0x1666+1643-0x1cca))<<z690b1cd3dc)|(ze77fa94a00<<z0a8926012b)|((0xd23+2873-0x185b)<<z55588371ab);for(i=(0x19ec+199-0x1ab3);(z27fd94ac66[z75b6a00559]>>(0x29a+8557-0x23f7))>(0x46c+1030-0x86e);i++){if(i>1193000.0*1.0){sprintf(msg,\"\\x25\\x73\\x20\\x66\\x61\\x69\\x6c\\x65\\x64\\x20\\x74\\x6f\\x20\\x63\\x6f\\x6e\\x66\\x69\\x67\\x20\\x41\\x6e\\x61\\x6c\\x6f\\x67\\x20\\x69\\x6e\\x70\\x75\\x74\\x20\\x72\\x65\\x67\\x20\\x30\\x78\\x25\\x78\",DEVNAME,z27fd94ac66[z75b6a00559]>>(0x49a+8581-0x260f));ssSetErrorStatus(S,msg);return;}}ssSetIWorkValue(S,zc0ced48ecf,(0xf36+511-0x1135));}z41c8844f54=z27fd94ac66[zee1550bec3];for(i=(0x1c4+4708-0x1428);z41c8844f54<zf91d71c6d9;i++){if(i>1193000.0*2.0){sprintf(msg,\"\\x25\\x73\\x20\\x66\\x61\\x69\\x6c\\x65\\x64\\x20\\x74\\x6f\\x20\\x73\\x74\\x61\\x72\\x74\\x20\\x41\\x6e\\x61\\x6c\\x6f\\x67\\x20\\x69\\x6e\\x70\\x75\\x74\",DEVNAME);ssSetErrorStatus(S,msg);return;}z41c8844f54=z27fd94ac66[zee1550bec3];}for(i=(0x1db1+843-0x20fc);i<=z41c8844f54;i++){z297b36fb23=z27fd94ac66[zceb273b472];if(!(z297b36fb23&((0xbdf+1279-0x10dd)<<(0x256+8210-0x2249)))){for(z812c65ff2f=(0x18ba+2896-0x240a);z812c65ff2f<zf91d71c6d9;z812c65ff2f++){if(((uint16_t)mxGetPr(z3644586f49)[z812c65ff2f]-(0x854+693-0xb08))==(uint16_t)((z297b36fb23>>z09b806e22a)&(0x658+4661-0x1886))){y=ssGetOutputPortSignal(S,z812c65ff2f);y[(0x15ac+4118-0x25c2)]=zfc19727a48(z297b36fb23);break;}}}}z27fd94ac66[z75b6a00559]=393322|((z4d3816b14e&(0x3ea+1890-0xb45))<<z690b1cd3dc)|(ze77fa94a00<<z0a8926012b)|((0x303+95-0x361)<<\r\nz55588371ab);}static void sg_ModelStop(SimStruct*S){volatile uint32_t*z27fd94ac66=ssGetPWorkValue(S,z0194338df7);z27fd94ac66[BRP]=((0xb2b+1334-0x1060)<<zbef81c3fd0);}\r\n#endif  \r\nstatic double zfc19727a48(uint32_t zf4d6a48e37){double ze485f859ed;uint16_t z1044b54040=(zf4d6a48e37>>z2d5a35d68d)&(0x460+7091-0x200c);const double z3dec4d2bb3[(0xbf5+6672-0x25fd)]={24.576/32768,10.24/32768,5.12/32768,2.56/32768,1.28/32768,0.64/32768,65535,20.48/32768};if(((zf4d6a48e37>>z2858a50a43)&(0x1c5a+2555-0x2654))>(0x161d+1278-0x1b1b)){ze485f859ed=((((double)(zf4d6a48e37&65535))-z7935114df5)*z3dec4d2bb3[z1044b54040]);}else{ze485f859ed=(((double)(zf4d6a48e37&65535))*z3dec4d2bb3[z1044b54040]);}return ze485f859ed;}\r\n#include \"sg_sfcn_glue.h\"   \r\n\r\n"},{"name":"sg_IO191_da_s.c","type":"source","group":"interface","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw/../../../.speedgoat/speedgoatlib/R2023a/9.6.1.1_4/sg_blocks/analog","tag":"","groupDisplay":"Interface files","code":"// Copyright 2006-2023 Speedgoat GmbH\r\n\r\n#define S_FUNCTION_LEVEL    (0x115c+4425-0x22a3)\r\n#undef S_FUNCTION_NAME\r\n#define S_FUNCTION_NAME     sg_IO191_da_s\r\n#include \"sg_IO191.h\"\r\n#ifndef MATLAB_MEX_FILE\r\n#include \"sg_printf.h\"\r\n#include \"sg_common.h\"\r\nvoid readPciBar(sg_PCIDevice*z7c46aa329e,int16_t bus,int16_t slot,int16_t z1e0fd5210f);\r\n#else\r\n#include \"mex.h\"\r\n#endif\r\n#include \"sg_callback.h\"\r\n#define ze13f49a01f           ssGetSFcnParam(S, (0x1087+3465-0x1e10))\r\n#define z3832b85a32           ssGetSFcnParam(S, (0x1144+2969-0x1cdc))\r\n#define z702a26a5e9                ssGetSFcnParam(S, (0x660+1141-0xad3))\r\n#define zfa79626a1f        ssGetSFcnParam(S, (0x10ac+2040-0x18a1))\r\n#define z832477988f        ssGetSFcnParam(S, (0x1c80+1808-0x238c))\r\n#define ze4bd57db54     ssGetSFcnParam(S, (0x161b+2429-0x1f93))\r\n#define zc6e5e42eac       ssGetSFcnParam(S, (0xd37+1615-0x1380))\r\n#define zdf24515981                           ((0x1da7+1552-0x23b0))\r\n#define z2e6483d505              ((0x1151+3974-0x20d7))\r\n#define zc5ce4cb81a              ((0xbe1+209-0xcb2))\r\n#define z0194338df7         ((0x2103+180-0x21b7))\r\n#define z2b17e2ee3b              ((0x22+1846-0x757))\r\nstatic int32_t z58d7aabac0(uint32_t zc8abac822d,double z7e546ae0bf);static char msg[z71934bf57c];static void mdlInitializeSizes(SimStruct*S){uint16_t i;ssSetNumSFcnParams(S,zdf24515981);if(ssGetNumSFcnParams(S)!=ssGetSFcnParamsCount(S)){sprintf(msg,\"\\x57\\x72\\x6f\\x6e\\x67\\x20\\x6e\\x75\\x6d\\x62\\x65\\x72\\x20\\x6f\\x66\\x20\\x69\\x6e\\x70\\x75\\x74\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x70\\x61\\x73\\x73\\x65\\x64\\x2e\" \"\\n\" \"\\x25\\x64\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x61\\x72\\x65\\x20\\x65\\x78\\x70\\x65\\x63\\x74\\x65\\x64\" \"\\n\",zdf24515981);ssSetErrorStatus(S,msg);return;}ssSetNumContStates(S,(0x1b18+885-0x1e8d));ssSetNumDiscStates(S,(0x4d+3063-0xc44));if(!ssSetNumOutputPorts(S,(0x1f6+1692-0x892)))return;if(!ssSetNumInputPorts(S,(int)mxGetN(zfa79626a1f)))return;for(i=(0xa3f+2563-0x1442);i<(int)mxGetN(zfa79626a1f);i++){ssSetInputPortWidth(S,i,(0x1d1c+2074-0x2535));ssSetInputPortDirectFeedThrough(S,i,(0x496+6731-0x1ee0));ssSetInputPortRequiredContiguous(S,i,(0x205+938-0x5ae));}ssSetNumSampleTimes(S,(0x7c8+3155-0x141a));ssSetNumRWork(S,zc5ce4cb81a);ssSetNumIWork(S,z2e6483d505);ssSetNumPWork(S,z2b17e2ee3b);ssSetNumModes(S,(0xf24+2439-0x18ab));ssSetNumNonsampledZCs(S,(0x8e6+1662-0xf64));for(i=(0xdf9+3148-0x1a45);i<zdf24515981;i++){ssSetSFcnParamTunable(S,i,(0xfd7+1134-0x1445));}ssSetOptions(S,SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME|SS_OPTION_EXCEPTION_FREE_CODE|SS_OPTION_RUNTIME_EXCEPTION_FREE_CODE);}static void mdlInitializeSampleTimes(SimStruct*S){if(mxGetPr(z3832b85a32)[(0x13f3+1824-0x1b13)]==-1.0){ssSetSampleTime(S,(0x5bf+1780-0xcb3),INHERITED_SAMPLE_TIME);ssSetOffsetTime(S,(0x94c+4883-0x1c5f),FIXED_IN_MINOR_STEP_OFFSET);}else{ssSetSampleTime(S,(0xb6d+6577-0x251e),mxGetPr(z3832b85a32)[(0xccc+4368-0x1ddc)]);ssSetOffsetTime(S,(0x1f04+788-0x2218),0.0);}ssSetModelReferenceSampleTimeDefaultInheritance(S);}\r\n#ifndef MATLAB_MEX_FILE\r\nstatic void sg_ModelLoad(SimStruct*S){}static void sg_ModelStart(SimStruct*S){sg_PCIDevice zeccbadd9b3;uint32_t bus,slot,za0d38ae598;volatile uint32_t*z27fd94ac66;uint16_t z879ede9171=(uint16_t)mxGetN(zfa79626a1f);uint32_t z812c65ff2f,zc8abac822d,zc430a259a4;uint16_t i,z4e3026977c;int32_t z7711a772ed;double z7e546ae0bf;if(mxGetN(z702a26a5e9)==(0x11ca+257-0x12ca)){bus=(0xef0+5035-0x229b);slot=(uint32_t)mxGetPr(z702a26a5e9)[(0x8e9+5014-0x1c7f)];}else{bus=(uint32_t)mxGetPr(z702a26a5e9)[(0xffa+5633-0x25fb)];slot=(uint32_t)mxGetPr(z702a26a5e9)[(0x76+3457-0xdf6)];}za0d38ae598=((uint32_t)mxGetPr(ze13f49a01f)[(0x74f+3385-0x1488)]);if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,za1afbacc4a,z78f5b4c5a6,z2bc00458b9,za0d38ae598,bus,slot)!=(0x14cd+3154-0x211f)){if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,zb765876dc5,z44a525e63d,za64fcbac7d,za0d38ae598,bus,slot)!=(0x1d1+4045-0x119e)){ssSetErrorStatus(S,pSgErrorStr);return;}}\r\n#ifdef _MSC_BUILD\r\nreadPciBar(&zeccbadd9b3,zeccbadd9b3.bus,zeccbadd9b3.slot,(0x2c3+7285-0x1f38));\r\n#endif\r\nz27fd94ac66=(volatile uint32_t*)sg_mapMemory(&zeccbadd9b3,(0x12c2+3206-0x1f46));ssSetPWorkValue(S,z0194338df7,(uint32_t*)z27fd94ac66);for(i=(0x450+2145-0xcb1);i<z879ede9171;i++){zc430a259a4=(0xaea+2788-0x15ce);z4e3026977c=(uint16_t)mxGetPr(zfa79626a1f)[i]-(0x260+1861-0x9a4);zc8abac822d=(uint32_t)mxGetPr(z832477988f)[i]-(0xedc+3261-0x1b98);z7e546ae0bf=(double)mxGetPr(ze4bd57db54)[z4e3026977c];z7711a772ed=z58d7aabac0(zc8abac822d,z7e546ae0bf);zc430a259a4=(z7711a772ed&65535)|((z4e3026977c&(0x865+2053-0x105b))<<z18b319d394)|(zbec0ec695f<<z668ef58fc5);if(z27fd94ac66[REVISION]>=z5f130b7753){for(z812c65ff2f=(0x52+4871-0x1359);z27fd94ac66[zeeea544396]&((0x166d+167-0x1713)<<z579611d67f);z812c65ff2f++){if(z812c65ff2f>1193000.0*1.0){sprintf(msg,\"\\x25\\x73\\x20\\x41\\x6e\\x61\\x6c\\x6f\\x67\\x20\\x4f\\x75\\x74\\x70\\x75\\x74\\x20\\x53\\x50\\x49\\x20\\x69\\x73\\x20\\x62\\x75\\x73\\x79\",DEVNAME);ssSetErrorStatus(S,msg);return;}}z27fd94ac66[zeeea544396]=zc430a259a4;}else{z27fd94ac66[zeeea544396]=zc430a259a4;sg_wait_ns(z905251a4e4);}zc430a259a4=(zc8abac822d&65535)|((z4e3026977c&(0x155c+3961-0x24c6))<<z18b319d394)|(z4d4e3e315a<<z668ef58fc5);if(z27fd94ac66[REVISION]>=z5f130b7753){for(z812c65ff2f=(0x127c+2160-0x1aec);z27fd94ac66[zeeea544396]&((0x22e0+1009-0x26d0)<<z579611d67f);z812c65ff2f++){if(z812c65ff2f>1193000.0*1.0){sprintf(msg,\"\\x25\\x73\\x20\\x41\\x6e\\x61\\x6c\\x6f\\x67\\x20\\x4f\\x75\\x74\\x70\\x75\\x74\\x20\\x53\\x50\\x49\\x20\\x69\\x73\\x20\\x62\\x75\\x73\\x79\",DEVNAME);ssSetErrorStatus(S,msg);return;}}z27fd94ac66[zeeea544396]=zc430a259a4;}else{z27fd94ac66[zeeea544396]=zc430a259a4;sg_wait_ns(z905251a4e4);}}}static void sg_ModelStep(SimStruct*S){volatile uint32_t*z27fd94ac66=ssGetPWorkValue(S,z0194338df7);uint16_t zf91d71c6d9=(uint16_t)mxGetN(zfa79626a1f);uint32_t zc430a259a4,z26dbd73a5e,zc8abac822d;int32_t out;uint16_t i,z812c65ff2f,z4e3026977c,zd953a322a2,z2ce6e80f45;double*zc7fdaf6331;if(z27fd94ac66[REVISION]>=z5f130b7753){for(i=(0x1f7c+1906-0x26ee);i<zf91d71c6d9;i++){zc430a259a4=(0x9c6+1647-0x1035);z4e3026977c=(uint16_t)mxGetPr(zfa79626a1f)[i]-(0x6ea+700-0x9a5);zc7fdaf6331=(double*)ssGetInputPortRealSignal(S,i);zc8abac822d=(uint32_t)mxGetPr(z832477988f)[i]-(0x10b2+3359-0x1dd0);out=z58d7aabac0(zc8abac822d,zc7fdaf6331[(0xad3+5209-0x1f2c)]);zc430a259a4=(out&65535)|((z4e3026977c&(0xb3c+2889-0x1676))<<z18b319d394)|(zbec0ec695f<<z668ef58fc5);for(z26dbd73a5e=(0x2c3+5143-0x16da);z27fd94ac66[zeeea544396]&((0x1a70+2074-0x2289)<<z579611d67f);z26dbd73a5e++){if(z26dbd73a5e>1193000.0*1.0){sprintf(msg,\"\\x25\\x73\\x20\\x41\\x6e\\x61\\x6c\\x6f\\x67\\x20\\x4f\\x75\\x74\\x70\\x75\\x74\\x20\\x53\\x50\\x49\\x20\\x69\\x73\\x20\\x62\\x75\\x73\\x79\",DEVNAME);ssSetErrorStatus(S,msg);return;}}z27fd94ac66[zeeea544396]=zc430a259a4;}}else{if(zf91d71c6d9>(0x3c2+8185-0x23b9)){zd953a322a2=(0x59d+7459-0x22be);z2ce6e80f45=zf91d71c6d9;}else{zd953a322a2=zf91d71c6d9;z2ce6e80f45=(0x132+8860-0x23ce);}for(i=(0x2e5+2709-0xd7a);i<zd953a322a2;i++){zc430a259a4=(0x644+3281-0x1315);z4e3026977c=(uint16_t)mxGetPr(zfa79626a1f)[i]-(0x1334+4140-0x235f);zc7fdaf6331=(double*)ssGetInputPortRealSignal(S,i);zc8abac822d=(uint32_t)mxGetPr(z832477988f)[i]-(0x8ef+5876-0x1fe2);out=z58d7aabac0(zc8abac822d,zc7fdaf6331[(0x1e5b+1507-0x243e)]);zc430a259a4=(out&65535)|((z4e3026977c&(0x931+1765-0x1007))<<z18b319d394)|(zbec0ec695f<<z668ef58fc5);z27fd94ac66[zeeea544396]=zc430a259a4;sg_wait_ns(z7edc1a4c28);}sg_wait_ns(z7edc1a4c28);for(z812c65ff2f=i;z812c65ff2f<z2ce6e80f45;z812c65ff2f++){zc430a259a4=(0x2e8+7263-0x1f47);z4e3026977c=(uint16_t)mxGetPr(zfa79626a1f)[z812c65ff2f]-(0x109d+4671-0x22db);zc7fdaf6331=(double*)ssGetInputPortRealSignal(S,z812c65ff2f);zc8abac822d=(uint32_t)mxGetPr(z832477988f)[z812c65ff2f]-(0x6ec+3830-0x15e1);out=z58d7aabac0(zc8abac822d,zc7fdaf6331[(0x11+9277-0x244e)]);zc430a259a4=(out&65535)|((z4e3026977c&(0x5d3+5261-0x1a51))<<z18b319d394)|(zbec0ec695f<<z668ef58fc5);z27fd94ac66[zeeea544396]=zc430a259a4;sg_wait_ns(z905251a4e4);}}}static void sg_ModelStop(SimStruct*S){volatile uint32_t*z27fd94ac66=ssGetPWorkValue(S,z0194338df7);uint16_t z879ede9171=(uint16_t)mxGetN(zfa79626a1f);int32_t z7711a772ed;uint32_t z812c65ff2f,zc8abac822d,zc430a259a4;uint16_t i,\r\nz4e3026977c;double z7e546ae0bf;for(i=(0x22c+4901-0x1551);i<z879ede9171;i++){if((int)mxGetPr(zc6e5e42eac)[i]){zc430a259a4=(0x334+5769-0x19bd);z4e3026977c=(uint16_t)mxGetPr(zfa79626a1f)[i]-(0x14cc+4305-0x259c);zc8abac822d=(uint32_t)mxGetPr(z832477988f)[i]-(0xb94+6731-0x25de);z7e546ae0bf=(double)mxGetPr(ze4bd57db54)[z4e3026977c];z7711a772ed=z58d7aabac0(zc8abac822d,z7e546ae0bf);zc430a259a4=(z7711a772ed&65535)|((z4e3026977c&(0x1632+3041-0x2204))<<z18b319d394)|(zbec0ec695f<<z668ef58fc5);if(z27fd94ac66[REVISION]>=z5f130b7753){for(z812c65ff2f=(0xdc6+3965-0x1d43);z27fd94ac66[zeeea544396]&((0xf3f+5553-0x24ef)<<z579611d67f);z812c65ff2f++){if(z812c65ff2f>1193000.0*1.0){sprintf(msg,\"\\x25\\x73\\x20\\x41\\x6e\\x61\\x6c\\x6f\\x67\\x20\\x4f\\x75\\x74\\x70\\x75\\x74\\x20\\x53\\x50\\x49\\x20\\x69\\x73\\x20\\x62\\x75\\x73\\x79\",DEVNAME);ssSetErrorStatus(S,msg);return;}}z27fd94ac66[zeeea544396]=zc430a259a4;}else{z27fd94ac66[zeeea544396]=zc430a259a4;sg_wait_ns(z905251a4e4);}zc430a259a4=(zc8abac822d&65535)|((z4e3026977c&(0x302+3062-0xee9))<<z18b319d394)|(z4d4e3e315a<<z668ef58fc5);if(z27fd94ac66[REVISION]>=z5f130b7753){for(z812c65ff2f=(0x364+352-0x4c4);z27fd94ac66[zeeea544396]&((0xd3c+126-0xdb9)<<z579611d67f);z812c65ff2f++){if(z812c65ff2f>1193000.0*1.0){sprintf(msg,\"\\x25\\x73\\x20\\x41\\x6e\\x61\\x6c\\x6f\\x67\\x20\\x4f\\x75\\x74\\x70\\x75\\x74\\x20\\x53\\x50\\x49\\x20\\x69\\x73\\x20\\x62\\x75\\x73\\x79\",DEVNAME);ssSetErrorStatus(S,msg);return;}}z27fd94ac66[zeeea544396]=zc430a259a4;}else{z27fd94ac66[zeeea544396]=zc430a259a4;sg_wait_ns(z905251a4e4);}}}}\r\n#endif  \r\nstatic int32_t z58d7aabac0(uint32_t zc8abac822d,double z7e546ae0bf){double z2f029a8902=(0x4a4+220-0x580),ze9f1c9266b=(0x2aa+6656-0x1caa);int32_t out;switch(zc8abac822d){case(0x174b+2220-0x1ff7):z2f029a8902=13107.2;ze9f1c9266b=(0x3bc+8576-0x253c);break;case(0x15c0+1905-0x1d30):z2f029a8902=6553.6;ze9f1c9266b=(0x15dd+3376-0x230d);break;case(0x1653+3958-0x25c7):z2f029a8902=6553.6;ze9f1c9266b=32768;break;case(0xd84+4180-0x1dd5):z2f029a8902=3276.8;ze9f1c9266b=32768;break;case(0x7c3+3343-0x14ce):z2f029a8902=13107.2;ze9f1c9266b=32768;break;default:SG_PRINTF_INFO(\"\\x45\\x72\\x72\\x6f\\x72\\x3a\\x20\\x41\\x6e\\x61\\x6c\\x6f\\x67\\x20\\x4f\\x75\\x74\\x70\\x75\\x74\\x73\\x20\\x75\\x6e\\x6b\\x6e\\x6f\\x77\\x6e\\x20\\x76\\x6f\\x6c\\x74\\x61\\x67\\x65\");break;}out=(int32_t)((z7e546ae0bf*z2f029a8902)+ze9f1c9266b);if(out>z7935114df5){out=z7935114df5;}else if(out<(0x4f4+35-0x517)){out=(0x122b+4047-0x21fa);}return out;}\r\n#include \"sg_sfcn_glue.h\"   \r\n\r\n"},{"name":"sg_IO191_di_s.c","type":"source","group":"interface","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw/../../../.speedgoat/speedgoatlib/R2023a/9.6.1.1_4/sg_blocks/analog","tag":"","groupDisplay":"Interface files","code":"// Copyright 2006-2023 Speedgoat GmbH\r\n\r\n#define S_FUNCTION_LEVEL    (0x490+2482-0xe40)\r\n#undef S_FUNCTION_NAME\r\n#define S_FUNCTION_NAME     sg_IO191_di_s\r\n#include \"sg_IO191.h\"\r\n#ifndef MATLAB_MEX_FILE\r\n#include \"sg_printf.h\"\r\n#include \"sg_common.h\"\r\nvoid readPciBar(sg_PCIDevice*z7c46aa329e,int16_t bus,int16_t slot,int16_t z1e0fd5210f);\r\n#else\r\n#include \"mex.h\"\r\n#endif\r\n#include \"sg_callback.h\"\r\n#define ze13f49a01f           ssGetSFcnParam(S, (0x1759+2617-0x2192))\r\n#define z3832b85a32           ssGetSFcnParam(S, (0x5f8+3193-0x1270))\r\n#define z702a26a5e9                ssGetSFcnParam(S, (0x2c5+4208-0x1333))\r\n#define zb18e38a301           ssGetSFcnParam(S, (0xa61+4466-0x1bd0))\r\n#define zdf24515981                           ((0x16f8+3286-0x23ca))\r\n#define z2e6483d505              ((0x26a+8085-0x21ff))\r\n#define zc5ce4cb81a              ((0x11f5+4924-0x2531))\r\n#define z0194338df7         ((0x3c2+703-0x681))\r\n#define z2b17e2ee3b              ((0x147c+2948-0x1fff))\r\nstatic char msg[z71934bf57c];static void mdlInitializeSizes(SimStruct*S){uint16_t i;ssSetNumSFcnParams(S,zdf24515981);if(ssGetNumSFcnParams(S)!=ssGetSFcnParamsCount(S)){sprintf(msg,\"\\x57\\x72\\x6f\\x6e\\x67\\x20\\x6e\\x75\\x6d\\x62\\x65\\x72\\x20\\x6f\\x66\\x20\\x69\\x6e\\x70\\x75\\x74\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x70\\x61\\x73\\x73\\x65\\x64\\x2e\" \"\\n\" \"\\x25\\x64\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x61\\x72\\x65\\x20\\x65\\x78\\x70\\x65\\x63\\x74\\x65\\x64\" \"\\n\",zdf24515981);ssSetErrorStatus(S,msg);return;}ssSetNumContStates(S,(0xc7b+5592-0x2253));ssSetNumDiscStates(S,(0x1185+3229-0x1e22));if(!ssSetNumInputPorts(S,(0xb62+481-0xd43)))return;if(!ssSetNumOutputPorts(S,(int)mxGetN(zb18e38a301)))return;for(i=(0x1d13+145-0x1da4);i<(int)mxGetN(zb18e38a301);i++){ssSetOutputPortWidth(S,i,(0x486+5466-0x19df));ssSetOutputPortDataType(S,(0x56c+6929-0x207d),SS_DOUBLE);}ssSetNumSampleTimes(S,(0x1a08+2901-0x255c));ssSetNumRWork(S,zc5ce4cb81a);ssSetNumIWork(S,z2e6483d505);ssSetNumPWork(S,z2b17e2ee3b);ssSetNumModes(S,(0x1aad+2738-0x255f));ssSetNumNonsampledZCs(S,(0x1482+3272-0x214a));for(i=(0xd05+5164-0x2131);i<zdf24515981;i++){ssSetSFcnParamTunable(S,i,(0x12db+3246-0x1f89));}ssSetOptions(S,SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME|SS_OPTION_EXCEPTION_FREE_CODE|SS_OPTION_RUNTIME_EXCEPTION_FREE_CODE);}static void mdlInitializeSampleTimes(SimStruct*S){if(mxGetPr(z3832b85a32)[(0x2cd+619-0x538)]==-1.0){ssSetSampleTime(S,(0x136d+3208-0x1ff5),INHERITED_SAMPLE_TIME);ssSetOffsetTime(S,(0x19a0+2894-0x24ee),FIXED_IN_MINOR_STEP_OFFSET);}else{ssSetSampleTime(S,(0x574+6180-0x1d98),mxGetPr(z3832b85a32)[(0x662+3656-0x14aa)]);ssSetOffsetTime(S,(0xbd9+2070-0x13ef),0.0);}ssSetModelReferenceSampleTimeDefaultInheritance(S);}\r\n#ifndef MATLAB_MEX_FILE\r\nstatic void sg_ModelLoad(SimStruct*S){}static void sg_ModelStart(SimStruct*S){sg_PCIDevice zeccbadd9b3;uint32_t bus,slot,za0d38ae598;volatile uint32_t*z27fd94ac66;if(mxGetN(z702a26a5e9)==(0xb62+5554-0x2113)){bus=(0x10ed+5301-0x25a2);slot=(uint32_t)mxGetPr(z702a26a5e9)[(0x874+6135-0x206b)];}else{bus=(uint32_t)mxGetPr(z702a26a5e9)[(0xadd+5988-0x2241)];slot=(uint32_t)mxGetPr(z702a26a5e9)[(0x8cd+1253-0xdb1)];}za0d38ae598=((uint32_t)mxGetPr(ze13f49a01f)[(0x1749+1291-0x1c54)]);if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,za1afbacc4a,z78f5b4c5a6,z2bc00458b9,za0d38ae598,bus,slot)!=(0xf55+4351-0x2054)){if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,zb765876dc5,z44a525e63d,za64fcbac7d,za0d38ae598,bus,slot)!=(0x594+130-0x616)){ssSetErrorStatus(S,pSgErrorStr);return;}}\r\n#ifdef _MSC_BUILD\r\nreadPciBar(&zeccbadd9b3,zeccbadd9b3.bus,zeccbadd9b3.slot,(0x1252+4672-0x2492));\r\n#endif\r\nz27fd94ac66=(volatile uint32_t*)sg_mapMemory(&zeccbadd9b3,(0x189+4706-0x13e9));ssSetPWorkValue(S,z0194338df7,(uint32_t*)z27fd94ac66);}static void sg_ModelStep(SimStruct*S){volatile uint32_t*za42cf7dd4a=ssGetPWorkValue(S,z0194338df7);uint32_t i,input,z4e3026977c;double*y;input=za42cf7dd4a[z52eac5d033];for(i=(0x180b+74-0x1855);i<(uint32_t)mxGetN(zb18e38a301);i++){z4e3026977c=(uint32_t)mxGetPr(zb18e38a301)[i]-(0x2c4+612-0x527);y=ssGetOutputPortSignal(S,i);if(input&((0x2149+672-0x23e8)<<z4e3026977c)){y[(0x1c4c+1042-0x205e)]=(0x60f+1538-0xc10);}else{y[(0xcf3+2372-0x1637)]=(0xc11+4873-0x1f1a);}}}static void sg_ModelStop(SimStruct*S){}\r\n#endif  \r\n#include \"sg_sfcn_glue.h\"   \r\n\r\n"},{"name":"sg_IO191_do_s.c","type":"source","group":"interface","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw/../../../.speedgoat/speedgoatlib/R2023a/9.6.1.1_4/sg_blocks/analog","tag":"","groupDisplay":"Interface files","code":"// Copyright 2006-2023 Speedgoat GmbH\r\n\r\n#define S_FUNCTION_LEVEL    (0x5bf+2361-0xef6)\r\n#undef S_FUNCTION_NAME\r\n#define S_FUNCTION_NAME     sg_IO191_do_s\r\n#include \"sg_IO191.h\"\r\n#ifndef MATLAB_MEX_FILE\r\n#include \"sg_printf.h\"\r\n#include \"sg_common.h\"\r\nvoid readPciBar(sg_PCIDevice*z7c46aa329e,int16_t bus,int16_t slot,int16_t z1e0fd5210f);\r\n#else\r\n#include \"mex.h\"\r\n#endif\r\n#include \"sg_callback.h\"\r\n#define ze13f49a01f           ssGetSFcnParam(S, (0x13e0+4526-0x258e))\r\n#define z3832b85a32           ssGetSFcnParam(S, (0x182+5115-0x157c))\r\n#define z702a26a5e9                ssGetSFcnParam(S, (0xc01+464-0xdcf))\r\n#define z5bc3ce0d50           ssGetSFcnParam(S, (0x776+1601-0xdb4))\r\n#define z2d8f240c11           ssGetSFcnParam(S, (0x1772+625-0x19df))\r\n#define z1f9bebb47b             ssGetSFcnParam(S, (0x1683+2315-0x1f89))\r\n#define zdf24515981                           ((0xf52+4685-0x2199))\r\n#define z2e6483d505              ((0x9a8+3518-0x1766))\r\n#define zc5ce4cb81a              ((0x1263+4888-0x257b))\r\n#define z0194338df7         ((0x1786+2885-0x22cb))\r\n#define z2b17e2ee3b              ((0x17e9+3860-0x26fc))\r\n#define THRESHOLD               0.5\r\nstatic char msg[z71934bf57c];static void mdlInitializeSizes(SimStruct*S){uint16_t i;ssSetNumSFcnParams(S,zdf24515981);if(ssGetNumSFcnParams(S)!=ssGetSFcnParamsCount(S)){sprintf(msg,\"\\x57\\x72\\x6f\\x6e\\x67\\x20\\x6e\\x75\\x6d\\x62\\x65\\x72\\x20\\x6f\\x66\\x20\\x69\\x6e\\x70\\x75\\x74\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x70\\x61\\x73\\x73\\x65\\x64\\x2e\" \"\\n\" \"\\x25\\x64\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x61\\x72\\x65\\x20\\x65\\x78\\x70\\x65\\x63\\x74\\x65\\x64\" \"\\n\",zdf24515981);ssSetErrorStatus(S,msg);return;}ssSetNumContStates(S,(0x140a+1006-0x17f8));ssSetNumDiscStates(S,(0x1616+685-0x18c3));if(!ssSetNumOutputPorts(S,(0x13da+1201-0x188b)))return;if(!ssSetNumInputPorts(S,(int)mxGetN(z5bc3ce0d50)))return;for(i=(0x46b+7087-0x201a);i<(int)mxGetN(z5bc3ce0d50);i++){ssSetInputPortWidth(S,i,(0xe05+6052-0x25a8));ssSetInputPortDirectFeedThrough(S,i,(0xed2+5455-0x2420));ssSetInputPortRequiredContiguous(S,i,(0x12af+3337-0x1fb7));}ssSetNumSampleTimes(S,(0x1528+613-0x178c));ssSetNumRWork(S,zc5ce4cb81a);ssSetNumIWork(S,z2e6483d505);ssSetNumPWork(S,z2b17e2ee3b);ssSetNumModes(S,(0x4cd+6065-0x1c7e));ssSetNumNonsampledZCs(S,(0x117a+4372-0x228e));for(i=(0xf68+410-0x1102);i<zdf24515981;i++){ssSetSFcnParamTunable(S,i,(0x3d8+8140-0x23a4));}ssSetOptions(S,SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME|SS_OPTION_EXCEPTION_FREE_CODE|SS_OPTION_RUNTIME_EXCEPTION_FREE_CODE);}static void mdlInitializeSampleTimes(SimStruct*S){if(mxGetPr(z3832b85a32)[(0x9fa+5271-0x1e91)]==-1.0){ssSetSampleTime(S,(0x11bd+334-0x130b),INHERITED_SAMPLE_TIME);ssSetOffsetTime(S,(0x1899+3649-0x26da),FIXED_IN_MINOR_STEP_OFFSET);}else{ssSetSampleTime(S,(0x136d+1483-0x1938),mxGetPr(z3832b85a32)[(0xbe9+1888-0x1349)]);ssSetOffsetTime(S,(0x46+6698-0x1a70),0.0);}ssSetModelReferenceSampleTimeDefaultInheritance(S);}\r\n#ifndef MATLAB_MEX_FILE\r\nstatic void sg_ModelLoad(SimStruct*S){}static void sg_ModelStart(SimStruct*S){sg_PCIDevice zeccbadd9b3;uint32_t zf91d71c6d9=(uint32_t)mxGetN(z5bc3ce0d50);volatile uint32_t*z27fd94ac66;uint32_t bus,slot,za0d38ae598,zcb341ffb0e,i;if(mxGetN(z702a26a5e9)==(0x9d9+408-0xb70)){bus=(0x149+2546-0xb3b);slot=(uint32_t)mxGetPr(z702a26a5e9)[(0x140a+3821-0x22f7)];}else{bus=(uint32_t)mxGetPr(z702a26a5e9)[(0x7c+6885-0x1b61)];slot=(uint32_t)mxGetPr(z702a26a5e9)[(0x3d3+2043-0xbcd)];}za0d38ae598=((uint32_t)mxGetPr(ze13f49a01f)[(0x1799+3688-0x2601)]);if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,za1afbacc4a,z78f5b4c5a6,z2bc00458b9,za0d38ae598,bus,slot)!=(0x662+3015-0x1229)){if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,zb765876dc5,z44a525e63d,za64fcbac7d,za0d38ae598,bus,slot)!=(0x69c+69-0x6e1)){ssSetErrorStatus(S,pSgErrorStr);return;}}\r\n#ifdef _MSC_BUILD\r\nreadPciBar(&zeccbadd9b3,zeccbadd9b3.bus,zeccbadd9b3.slot,(0xe31+1798-0x1537));\r\n#endif\r\nz27fd94ac66=(volatile uint32_t*)sg_mapMemory(&zeccbadd9b3,(0xd58+5538-0x22f8));ssSetPWorkValue(S,z0194338df7,(uint32_t*)z27fd94ac66);zcb341ffb0e=z27fd94ac66[z52eac5d033];for(i=(0xb41+4562-0x1d13);i<zf91d71c6d9;i++){if((int)mxGetPr(z2d8f240c11)[i]>THRESHOLD){zcb341ffb0e|=((0xda2+5684-0x23d5)<<((uint32_t)mxGetPr(z5bc3ce0d50)[i]-(0x157d+4050-0x254e)));}else{zcb341ffb0e&=~((0x2d6+837-0x61a)<<((uint32_t)mxGetPr(z5bc3ce0d50)[i]-(0x153f+221-0x161b)));}}z27fd94ac66[z52eac5d033]=zcb341ffb0e;}static void sg_ModelStep(SimStruct*S){volatile uint32_t*z27fd94ac66=ssGetPWorkValue(S,z0194338df7);uint16_t z344fcf0ef3;uint32_t i,zcb341ffb0e;double output;double*zc7fdaf6331;z344fcf0ef3=(uint16_t)mxGetN(z5bc3ce0d50);zcb341ffb0e=(0x4fa+3413-0x124f);for(i=(0x36+8129-0x1ff7);i<z344fcf0ef3;i++){zc7fdaf6331=(double*)ssGetInputPortRealSignal(S,i);output=zc7fdaf6331[(0x19e1+2812-0x24dd)];if(output>THRESHOLD){zcb341ffb0e|=((0x671+3271-0x1337)<<((uint16_t)mxGetPr(z5bc3ce0d50)[i]-(0xab+1594-0x6e4)));}}z27fd94ac66[z52eac5d033]=zcb341ffb0e;}static void sg_ModelStop(SimStruct*S){volatile uint32_t*z27fd94ac66=ssGetPWorkValue(S,z0194338df7);uint32_t zf91d71c6d9=(uint32_t)mxGetN(z5bc3ce0d50);uint32_t i,zcb341ffb0e;zcb341ffb0e=z27fd94ac66[z52eac5d033];for(i=(0x651+2318-0xf5f);i<zf91d71c6d9;i++){if((int)mxGetPr(z1f9bebb47b)[i]==(0x127d+4999-0x2603)){if((int)mxGetPr(z2d8f240c11)[i]>THRESHOLD){zcb341ffb0e|=((0x11fa+1665-0x187a)<<((uint32_t)mxGetPr(z5bc3ce0d50)[i]-(0x996+7480-0x26cd)));}else{zcb341ffb0e&=~((0x1a70+576-0x1caf)<<((uint32_t)mxGetPr(z5bc3ce0d50)[i]-(0x85f+5265-0x1cef)));}}}z27fd94ac66[z52eac5d033]=zcb341ffb0e;}\r\n#endif  \r\n#include \"sg_sfcn_glue.h\"   \r\n\r\n"},{"name":"sg_IO191_setup_s.c","type":"source","group":"interface","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw/../../../.speedgoat/speedgoatlib/R2023a/9.6.1.1_4/sg_blocks/analog","tag":"","groupDisplay":"Interface files","code":"// Copyright 2006-2023 Speedgoat GmbH\r\n\r\n#define S_FUNCTION_LEVEL    (0x10cb+2737-0x1b7a)\r\n#undef S_FUNCTION_NAME\r\n#define S_FUNCTION_NAME     sg_IO191_setup_s\r\n#include \"sg_IO191.h\"\r\n#ifndef MATLAB_MEX_FILE\r\n#include \"sg_printf.h\"\r\n#include \"sg_common.h\"\r\nvoid readPciBar(sg_PCIDevice*z7c46aa329e,int16_t bus,int16_t slot,int16_t z1e0fd5210f);\r\n#else\r\n#include \"mex.h\"\r\n#endif\r\n#include \"sg_callback.h\"\r\n#define z702a26a5e9                ssGetSFcnParam(S, (0x154+6099-0x1927))\r\n#define ze13f49a01f           ssGetSFcnParam(S, (0xaa2+2017-0x1282))\r\n#define z1e0b67709d       ssGetSFcnParam(S, (0x7b7+749-0xaa2))\r\n#define z3644586f49         ssGetSFcnParam(S, (0x1a0c+2186-0x2293))\r\n#define z8d5c288b32         ssGetSFcnParam(S, (0x42b+217-0x500))\r\n#define z9876548c58         ssGetSFcnParam(S, (0xff7+3171-0x1c55))\r\n#define zfa79626a1f        ssGetSFcnParam(S, (0xb19+229-0xbf8))\r\n#define z832477988f        ssGetSFcnParam(S, (0xcbc+1663-0x1334))\r\n#define z4526a8632b         ssGetSFcnParam(S, (0xc27+2227-0x14d2))\r\n#define zdf24515981                           ((0xe83+6110-0x2658))\r\n#define z2e6483d505              ((0x1e94+1092-0x22d8))\r\n#define z8caad2a8e6              ((0x551+1754-0xc2b))\r\n#define z5bfe7a2613            ((0x1341+4557-0x250d))\r\n#define zc5ce4cb81a              ((0x1152+4077-0x213d))\r\n#define z0194338df7         ((0x841+6504-0x21a9))\r\n#define z2b17e2ee3b              ((0x1e5+7568-0x1f74))\r\nstatic char msg[z71934bf57c];static void mdlInitializeSizes(SimStruct*S){uint16_t i;ssSetNumSFcnParams(S,zdf24515981);if(ssGetNumSFcnParams(S)!=ssGetSFcnParamsCount(S)){sprintf(msg,\"\\x57\\x72\\x6f\\x6e\\x67\\x20\\x6e\\x75\\x6d\\x62\\x65\\x72\\x20\\x6f\\x66\\x20\\x69\\x6e\\x70\\x75\\x74\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x70\\x61\\x73\\x73\\x65\\x64\\x2e\" \"\\n\" \"\\x25\\x64\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x61\\x72\\x65\\x20\\x65\\x78\\x70\\x65\\x63\\x74\\x65\\x64\" \"\\n\",zdf24515981);ssSetErrorStatus(S,msg);return;}ssSetNumContStates(S,(0x2e0+9175-0x26b7));ssSetNumDiscStates(S,(0xa2b+4369-0x1b3c));if(!ssSetNumInputPorts(S,(0x2070+1166-0x24fe)))return;if(!ssSetNumOutputPorts(S,(0x46+573-0x283)))return;ssSetNumSampleTimes(S,(0x16a5+3548-0x2480));ssSetNumRWork(S,zc5ce4cb81a);ssSetNumIWork(S,z2e6483d505);ssSetNumPWork(S,z2b17e2ee3b);ssSetNumModes(S,(0xecd+231-0xfb4));ssSetNumNonsampledZCs(S,(0x147f+2175-0x1cfe));for(i=(0x8c2+6705-0x22f3);i<zdf24515981;i++){ssSetSFcnParamTunable(S,i,(0x72d+7595-0x24d8));}ssSetOptions(S,SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME|SS_OPTION_EXCEPTION_FREE_CODE|SS_OPTION_RUNTIME_EXCEPTION_FREE_CODE|SS_OPTION_PLACE_ASAP);}static void mdlInitializeSampleTimes(SimStruct*S){ssSetSampleTime(S,(0x21b6+431-0x2365),INHERITED_SAMPLE_TIME);ssSetOffsetTime(S,(0xc59+5933-0x2386),FIXED_IN_MINOR_STEP_OFFSET);ssSetModelReferenceSampleTimeDefaultInheritance(S);}\r\n#ifndef MATLAB_MEX_FILE\r\nstatic void sg_ModelLoad(SimStruct*S){}static void sg_ModelStart(SimStruct*S){sg_PCIDevice zeccbadd9b3;uint32_t bus,slot,za0d38ae598,i;uint16_t z4e3026977c,z0e26ef1137;volatile uint32_t*z27fd94ac66;if(mxGetN(z702a26a5e9)==(0x2413+265-0x251b)){bus=(0x1286+3641-0x20bf);slot=(uint32_t)mxGetPr(z702a26a5e9)[(0xb13+5593-0x20ec)];}else{bus=(uint32_t)mxGetPr(z702a26a5e9)[(0x1ea3+159-0x1f42)];slot=(uint32_t)mxGetPr(z702a26a5e9)[(0x9dd+2573-0x13e9)];}za0d38ae598=((uint32_t)mxGetPr(ze13f49a01f)[(0xba+8255-0x20f9)]);if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,za1afbacc4a,z78f5b4c5a6,z2bc00458b9,za0d38ae598,bus,slot)!=(0x1bed+1278-0x20eb)){if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,zb765876dc5,z44a525e63d,za64fcbac7d,za0d38ae598,bus,slot)!=(0x160+861-0x4bd)){ssSetErrorStatus(S,pSgErrorStr);return;}}\r\n#ifdef _MSC_BUILD\r\nreadPciBar(&zeccbadd9b3,zeccbadd9b3.bus,zeccbadd9b3.slot,(0x3bb+8030-0x2319));\r\n#endif\r\nz27fd94ac66=(volatile uint32_t*)sg_mapMemory(&zeccbadd9b3,(0x1017+4953-0x236e));ssSetPWorkValue(S,z0194338df7,(uint32_t*)z27fd94ac66);SG_PRINTF_DEBUG(\"\\x25\\x73\\x3a\\x20\\x46\\x50\\x47\\x41\\x20\\x72\\x65\\x76\\x20\\x30\\x78\\x25\\x58\" \"\\n\",DEVNAME,z27fd94ac66[REVISION]);z0e26ef1137=(0x3d2+7874-0x2294);for(i=(0xf05+2232-0x17bd);i<(uint32_t)mxGetN(z4526a8632b);i++){z4e3026977c=(uint32_t)mxGetPr(z4526a8632b)[i];if(z4e3026977c==(0xdb5+5768-0x243c)){z0e26ef1137=(0x21f3+336-0x2342);}else{z0e26ef1137|=((0xf52+2401-0x18b2)<<(z4e3026977c+(0x145c+4654-0x2684)));}}z27fd94ac66[zef0a03cb9f]=z0e26ef1137;}static void sg_ModelStep(SimStruct*S){}static void sg_ModelStop(SimStruct*S){}\r\n#endif  \r\n#include \"sg_sfcn_glue.h\"   \r\n\r\n"},{"name":"main.cpp","type":"source","group":"legacy","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Other files","code":"/* Main generated for Simulink Real-Time model ATTN */\n#include <ModelInfo.hpp>\n#include <utilities.hpp>\n#include \"ATTN.h\"\n#include \"rte_ATTN_parameters.h\"\n\n/* Task descriptors */\nslrealtime::TaskInfo task_1( 0u, std::bind(ATTN_step), slrealtime::TaskInfo::PERIODIC, 0.001, 0, 40);\n\n/* Executable base address for XCP */\n#ifdef __linux__\nextern char __executable_start;\nstatic uintptr_t const base_address = reinterpret_cast<uintptr_t>(&__executable_start);\n#else\n/* Set 0 as placeholder, to be parsed later from /proc filesystem */\nstatic uintptr_t const base_address = 0;\n#endif\n\n/* Model descriptor */\nslrealtime::ModelInfo ATTN_Info =\n{\n    \"ATTN\",\n    ATTN_initialize,\n    ATTN_terminate,\n    []()->char const*& { return ATTN_M->errorStatus; },\n    []()->unsigned char& { return ATTN_M->Timing.stopRequestedFlag; },\n    { task_1 },\n    slrealtime::getSegmentVector()\n};\n\nint main(int argc, char *argv[]) {\n    slrealtime::BaseAddress::set(base_address);\n    return slrealtime::runModel(argc, argv, ATTN_Info);\n}\n"},{"name":"rt_matrx.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2023a/rtw/c/src","tag":"","groupDisplay":"Other files","code":"/* File    : rt_matrx.c\n * Abstract:\n *      Implements stand alone matrix access and creation routines.\n *\tThere are two types of MATLAB objects which can be \"passed\" to\n *\tthe generated code, a 2D real matrix and a string. Strings are\n *\tpassed as 2D real matrices. The first two elements of an S-function\n *\tparameters are the row and column (m and n) dimensions respectively.\n *\tThese are followed by the matrix data.\n */\n\n\n\n/*\n * Copyright 1994-2022 The MathWorks, Inc.\n */\n\n/*==========*\n * Includes *\n *==========*/\n\n#if defined(MDL_REF_SIM_TGT)\n#undef MATLAB_MEX_FILE\n#endif\n\n#if defined(MATLAB_MEX_FILE)\n# error \"rt_matrix cannot be used within a mex file. It is for codegen only.\"\n#endif\n\n#include <string.h>    /* for strlen */\n#include \"rt_matrx.h\"\n\n#include <stddef.h> /* needed for size_t and NULL */\n#include <float.h>  /* needed for definition of eps */\n\n/*==========*\n * Typedefs *\n *==========*/\n\n#ifndef rt_typedefs_h\n#define rt_typedefs_h\n\n#if !defined(TYPEDEF_MX_ARRAY)\n# define TYPEDEF_MX_ARRAY\n  typedef real_T mxArray;\n#endif\n\ntypedef real_T mxChar;\n\n#if !defined(TMW_NAME_LENGTH_MAX)\n#define TMW_NAME_LENGTH_MAX 64\n#endif\n#define mxMAXNAM  TMW_NAME_LENGTH_MAX\t/* maximum name length */\n\ntypedef enum {\n    mxREAL,\n    mxCOMPLEX\n} mxComplexity;\n\n#endif /* rt_typedefs_h */\n\n/*==================*\n * Extern variables *\n *==================*/\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nextern real_T rtInf;\nextern real_T rtMinusInf;\nextern real_T rtNaN;\n\n#ifdef __cplusplus\n}\n#endif\n\n/*=======================================*\n * Defines for mx Routines and constants *\n *=======================================*/\n\n\n#define mxCalloc(n,size) \\\n        calloc(n,size)\n\n#define mxCreateCharArray(ndim, dims) \\\n        mxCreateNumericArray(ndim, dims, mxCHAR_CLASS);\n\n#define mxDestroyArray(pa) \\\n        if (pa) free(pa)\n\n/* NOTE: You cannot mxFree(mxGetPr(pa)) !!! */\n#define mxFree(ptr) \\\n        if(ptr)free(ptr)\n\n#define mxGetClassID(pa) \\\n        mxDOUBLE_CLASS\n\n/* NOTE: mxGetClassName(pa) returns \"double\" even on a character array */\n#define mxGetClassName(pa) \\\n        \"double\"\n\n#define mxGetData(pa) \\\n        ((void *)(&((pa)[2])))\n\n#define mxGetElementSize(pa) \\\n        (sizeof(real_T))\n\n#define mxGetInf() \\\n        rtInf\n\n#define mxGetM(pa) \\\n        ((size_t) ((pa)[0]))\n#define mxGetN(pa) \\\n        ((size_t) ((pa)[1]))\n\n#define mxGetNaN() \\\n        rtNaN\n\n#define mxGetNumberOfDimensions(pa) \\\n        (2)\n#define mxGetNumberOfElements(pa) \\\n        (mxGetM(pa)*mxGetN(pa))\n\n/* NOTE: mxGetPr() of an empty matrix does NOT return NULL */\n#define mxGetPr(pa) \\\n        ( &((pa)[2]) )\n\n/* NOTE: mxGetDoubles() of an empty matrix does NOT return NULL */\n#define mxGetDoubles(pa) \\\n        ( &((pa)[2]) )\n\n#define mxGetScalar(pa) \\\n        ((pa)[2])\n\n#define mxIsComplex(pa) \\\n        false\n\n#define mxIsDouble(pa) \\\n        true\n\n#define mxIsEmpty(pa) \\\n        (mxGetM(pa)==0 || mxGetN(pa)==0)\n\n#define mxIsFinite(r) \\\n        ((r)>rtMinusInf && (r)<rtInf)\n\n#define mxIsInf(r) \\\n        ((r)==rtInf || (r)==rtMinusInf)\n\n#define mxIsInt16(pa) \\\n        false\n\n#define mxIsInt32(pa) \\\n        false\n\n#define mxIsInt8(pa) \\\n        false\n\n#define mxIsLogical(pa) \\\n        false\n\n#define mxIsNumeric(pa) \\\n        true\n\n#define mxIsSingle(pa) \\\n        false\n\n#define mxIsSparse(pa) \\\n        false\n\n#define mxIsStruct(pa) \\\n        false\n\n#define mxIsUint16(pa) \\\n        false\n\n#define mxIsUint32(pa) \\\n        false\n\n#define mxIsUint8(pa) \\\n        false\n\n#define mxMalloc(n) \\\n        malloc(n)\n\n#define mxRealloc(p,n) \\\n        realloc(p,n)\n\n/*==============*\n * Local macros *\n *==============*/\n#define _mxSetM(pa,m) \\\n        (pa)[0] = ((int)(m))\n\n#define _mxSetN(pa,n) \\\n        (pa)[1] = ((int)(n))\n\n\n/*==========================*\n * Visible/extern functions *\n *=========================*/\n\n/* Function: mxCreateCharMatrixFromStrings ====================================\n * Abstract:\n *\tCreate a string array initialized to the strings in str.\n */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nmxArray *rt_mxCreateCharMatrixFromStrings(int_T m, const char_T **str)\n{\n    int_T nchars;\n    int_T i, n;\n    mxArray *pa;\n\n    n = 0;\n    for (i = 0; i < m; ++i) {\n\tnchars = (int_T)strlen(str[i]);\n\tif (nchars > n) {\n\t    n = nchars;\n\t}\n    }\n\n    pa = (mxArray *)malloc((m*n+2)*sizeof(real_T));\n    if(pa!=NULL) {\n\tmxChar *chars;\n\tint_T  j;\n\t_mxSetM(pa, m);\n\t_mxSetN(pa, n);\n\tchars = mxGetPr(pa);\n\tfor (j = 0; j < m; ++j) {\n\t    const char_T *src  = str[j];\n\t    mxChar *dest = chars + j;\n\n\t    nchars = (int_T)strlen(src);\n\t    i = nchars;\n\t    while (i--) {\n\t\t*dest = *src++;\n\t\t dest += m;\n\t    }\n\t    i = n - nchars;\n\t    while (i--) {\n\t\t*dest = 0.0;\n\t\tdest += m;\n\t    }\n\t}\n    }\n    return pa;\n} /* end mxCreateCharMatrixFromStrings */\n\n#ifdef __cplusplus\n}\n#endif\n\n/* Function: mxCreateString ===================================================\n * Abstract:\n *\tCreate a 1-by-n string array initialized to null terminated string\n *\twhere n is the length of the string.\n */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nmxArray *rt_mxCreateString(const char *str)\n{\n    int_T   len = (int_T)strlen(str);\n\n    mxArray *pa = (mxArray *)malloc((len+2)*sizeof(real_T));\n\n    if(pa!=NULL) {\n\treal_T *pr;\n\tconst unsigned char *ustr_ptr = (const unsigned char *) str;\n\n\t_mxSetM(pa, 1);\n\t_mxSetN(pa, len);\n\tpr = mxGetPr(pa);\n\twhile (len--) {\n            *pr++ = (real_T)*ustr_ptr++;\n        }\n    }\n    return(pa);\n\n} /* end mxCreateString */\n\n#ifdef __cplusplus\n}\n#endif\n\n/* Function: mxCreateDoubleMatrix =============================================\n * Abstract:\n *\tCreate a two-dimensional array to hold real_T data,\n *\tinitialize each data element to 0.\n */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nmxArray *rt_mxCreateDoubleMatrix(int m, int n, mxComplexity flag)\n{\n    if (flag == mxREAL) {\n        mxArray *pa = (mxArray *)calloc(m*n+2, sizeof(real_T));\n        if(pa!=NULL) {\n            _mxSetM(pa, m);\n            _mxSetN(pa, n);\n        }\n        return(pa);\n    } else {\n        return(NULL);\n    }\n\n} /* end mxCreateDoubleMatrix */\n\n#ifdef __cplusplus\n}\n#endif\n\n/* Function: mxCreateNumericArray =============================================\n * Abstract:\n *\tCreate a numeric array and initialize all its data elements to 0.\n */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nmxArray *rt_mxCreateNumericArray(int_T ndims, const mwSize *dims, \n                                        mxClassID classid, mxComplexity flag)\n{\n    if (ndims == 2 && classid==mxDOUBLE_CLASS) {\n        return(rt_mxCreateDoubleMatrix((int)(dims[0]), (int)(dims[1]), flag));\n    } else {\n        return(NULL);\n    }\n\n} /* end mxCreateNumericArray */\n\n#ifdef __cplusplus\n}\n#endif\n\n/* Function: mxDuplicateArray =================================================\n * Abstract:\n *\tMake a deep copy of an array, return a pointer to the copy.\n */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nmxArray *rt_mxDuplicateArray(const mxArray *pa)\n{\n\n    size_t   nbytes = (mxGetNumberOfElements(pa)+2)*mxGetElementSize(pa);\n    mxArray *pcopy = (mxArray *)malloc(nbytes);\n\n    if (pcopy!=NULL) {\n\t(void)memcpy(pcopy, pa, nbytes);\n    }\n    return(pcopy);\n\n} /* end mxDuplicateArray */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n/* Function: mxGetDimensions ==================================================\n * Abstract:\n *\tGet pointer to dimension array\n */\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nconst mwSize *rt_mxGetDimensions(const mxArray *pa)\n{\n    static mwSize dims[2];\n    dims[0] = mxGetM(pa);\n    dims[1] = mxGetN(pa);\n    return dims;\n} /* end mxGetDimensions */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n/* Function: mxGetEps =========================================================\n * Abstract:\n *\tReturn eps, the difference between 1.0 and the least value\n *\tgreater than 1.0 that is representable as a real_T.\n */\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nreal_T rt_mxGetEps(void)\n{\n    return (sizeof(double)==sizeof(real_T)) ? DBL_EPSILON : FLT_EPSILON;\n}\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n/* Function: mxGetString ======================================================\n * Abstract:\n *\tConverts a string array to a C-style string.\n */\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nint_T rt_mxGetString(const mxArray *pa, char_T *buf, int_T buflen)\n{\n    int_T        nchars;\n    const real_T *pr;\n    char_T       *pc;\n    int_T        truncate = 0;\n\n    nchars = (int_T)mxGetNumberOfElements(pa);\n    if (nchars >= buflen) {\n\t/* leave room for null byte */\n\tnchars = buflen - 1;\n\ttruncate = 1;\n    }\n    pc = buf;\n    pr = mxGetPr(pa);\n    while (nchars--) {\n\t*pc++ = (char) (*pr++ + .5);\n    }\n    *pc = '\\0';\n    return truncate;\n} /* end mxGetString */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n#define mxCreateCharMatrixFromStrings(m, str) \\\n        rt_mxCreateCharMatrixFromStrings(m, str)\n\n#define mxCreateString(str) \\\n        rt_mxCreateString(str) \n\n#define mxCreateDoubleMatrix(m, n, flag) \\\n        rt_mxCreateDoubleMatrix(m, n, flag)\n\n#define mxCreateNumericArray(ndims, dims, classid, flag) \\\n        rt_mxCreateNumericArray(ndims, dims, classid, flag)\n\n#define mxDuplicateArray(pa) \\\n        rt_mxDuplicateArray(pa)\n\n#define mxGetDimensions(pa) \\\n        rt_mxGetDimensions(pa)\n\n#define mxGetEps() \\\n        rt_mxGetEps()\n\n#define mxGetString(pa, buf, buflen) \\\n        rt_mxGetString(pa, buf, buflen)\n\n/*=========================*\n * Unsupported mx Routines *\n *=========================*/\n\n#define mxCalcSingleSubscript(pa,nsubs,subs) \\\n        mxCalcSingleSubscript_is_not_supported_in_Simulink_Coder\n\n#define mxCreateCellArray(ndim,dims) \\\n        mxCreateCellArray_is_not_supported_in_Simulink_Coder\n\n#define mxCreateCellMatrix(m,n) \\\n        mxCreateCellMatrix_is_not_supported_in_Simulink_Coder\n\n#define mxCreateSparse(pm,pn,pnzmax,pcmplx_flg) \\\n        mxCreateSparse_is_not_supported_in_Simulink_Coder\n\n#define mxCreateStructArray(ndim,dims,nfields,fieldnames) \\\n        mxCreateStructArray_is_not_supported_in_Simulink_Coder\n\n#define mxCreateStructMatrix(m,n,nfields,fieldnames) \\\n        mxCreateStructMatrix_is_not_supported_in_Simulink_Coder\n\n#define mxGetCell(pa,i) \\\n        mxGetCell_is_not_supported_in_Simulink_Coder\n\n#define mxGetField(pa,i,fieldname) \\\n        mxGetField_is_not_supported_in_Simulink_Coder\n\n#define mxGetFieldByNumber(s,i,fieldnum) \\\n        mxGetFieldByNumber_is_not_supported_in_Simulink_Coder\n\n#define mxGetFieldNameByNumber(pa,n) \\\n        mxGetFieldNameByNumber_is_not_supported_in_Simulink_Coder\n\n#define mxGetFieldNumber(pa,fieldname) \\\n        mxGetFieldNumber_is_not_supported_in_Simulink_Coder\n\n#define mxGetImagData(pa) \\\n        mxGetImagData_is_not_supported_in_Simulink_Coder\n\n#define mxGetIr(ppa) \\\n        mxGetIr_is_not_supported_in_Simulink_Coder\n\n#define mxGetJc(ppa) \\\n        mxGetJc_is_not_supported_in_Simulink_Coder\n\n#define mxGetNumberOfFields(pa) \\\n        mxGetNumberOfFields_is_not_supported_in_Simulink_Coder\n\n#define mxGetNzmax(pa) \\\n        mxGetNzmax_is_not_supported_in_Simulink_Coder\n\n#define mxGetPi(pa) \\\n        mxGetPi_is_not_supported_in_Simulink_Coder\n\n#define mxIsFromGlobalWS(pa) \\\n        mxIsFromGlobalWS_is_not_supported_in_Simulink_Coder\n\n#define mxIsNaN(r) \\\n        mxIsNaN_is_not_supported_in_Simulink_Coder\n\n#define mxIsChar(pa) \\\n        mxIsChar_is_not_supported_in_Simulink_Coder\n\n#define mxIsClass(pa,class) \\\n        mxIsClass_is_not_supported_in_Simulink_Coder\n\n#define mxIsCell(pa) \\\n        mxIsCell_is_not_supported_in_Simulink_Coder\n\n#define mxSetCell(pa,i,value) \\\n        mxSetCell_is_not_supported_in_Simulink_Coder\n\n#define mxSetClassName(pa,classname) \\\n        mxSetClassName_is_not_supported_in_Simulink_Coder\n\n#define mxSetData(pa,pr) \\\n        mxSetData_is_not_supported_in_Simulink_Coder\n\n#define mxSetDimensions(pa, size, ndims) \\\n        mxSetDimensions_is_not_supported_in_Simulink_Coder\n\n#define mxSetField(pa,i,fieldname,value) \\\n        mxSetField_is_not_supported_in_Simulink_Coder\n\n#define mxSetFieldByNumber(pa, index, fieldnum, value) \\\n        mxSetFieldByNumber_is_not_supported_in_Simulink_Coder\n\n#define mxSetFromGlobalWS(pa,global) \\\n        mxSetFromGlobalWS_is_not_supported_in_Simulink_Coder\n\n#define mxSetImagData(pa,pv) \\\n        mxSetImagData_is_not_supported_in_Simulink_Coder\n\n#define mxSetIr(ppa,ir) \\\n        mxSetIr_is_not_supported_in_Simulink_Coder\n\n#define mxSetJc(ppa,jc) \\\n        mxSetJc_is_not_supported_in_Simulink_Coder\n\n#define mxSetM(pa, m) \\\n        mxSetM_is_not_supported_in_Simulink_Coder\n\n#define mxSetN(pa, m) \\\n        mxSetN_is_not_supported_in_Simulink_Coder\n\n#define mxSetPr(pa,pr) \\\n        mxSetPr_is_not_supported_in_Simulink_Coder\n\n#define mxSetNzmax(pa,nzmax) \\\n        mxSetNzmax_is_not_supported_in_Simulink_Coder\n\n#define mxSetPi(pa,pv) \\\n        mxSetPi_is_not_supported_in_Simulink_Coder\n\n\n\n/*==========================*\n * Unsupported mex routines *\n *==========================*/\n\n#define mexPrintAssertion(test,fname,linenum,message) \\\n        mexPrintAssertion_is_not_supported_by_Simulink_Coder\n\n#define mexEvalString(str) \\\n        mexEvalString_is_not_supported_by_Simulink_Coder\n\n#define mexErrMsgTxt(str) \\\n        mexErrMsgTxt_is_not_supported_by_Simulink_Coder\n\n#define mexWarnMsgTxt(warning_msg) \\\n        mexWarnMsgTxt_is_not_supported_by_Simulink_Coder\n\n#define mexPrintf \\\n        mexPrintf_is_not_supported_by_Simulink_Coder\n\n#define mexMakeArrayPersistent(pa) \\\n        mexMakeArrayPersistent_is_not_supported_by_Simulink_Coder\n\n#define mexMakeMemoryPersistent(ptr) \\\n        mexMakeMemoryPersistent_is_not_supported_by_Simulink_Coder\n\n#define mexLock() \\\n        mexLock_is_not_supported_by_Simulink_Coder\n\n#define mexUnlock() \\\n        mexUnlock_is_not_supported_by_Simulink_Coder\n\n#define mexFunctionName() \\\n        mexFunctionName_is_not_supported_by_Simulink_Coder\n\n#define mexIsLocked() \\\n        mexIsLocked_is_not_supported_by_Simulink_Coder\n\n#define mexGetFunctionHandle() \\\n        mexGetFunctionHandle_is_not_supported_by_Simulink_Coder\n\n#define mexCallMATLABFunction() \\\n        mexCallMATLABFunction_is_not_supported_by_Simulink_Coder\n\n#define mexRegisterFunction() \\\n        mexRegisterFunction_is_not_supported_by_Simulink_Coder\n\n#define mexSet(handle,property,value) \\\n        mexSet_is_not_supported_by_Simulink_Coder\n\n#define mexGet(handle,property) \\\n        mexGet_is_not_supported_by_Simulink_Coder\n\n#define mexCallMATLAB(nlhs,plhs,nrhs,prhs,fcn) \\\n        mexCallMATLAB_is_not_supported_by_Simulink_Coder\n\n#define mexSetTrapFlag(flag) \\\n        mexSetTrapFlag_is_not_supported_by_Simulink_Coder\n\n#define mexUnlink(a) \\\n        mexUnlink_is_not_supported_by_Simulink_Coderw\n\n#define mexSubsAssign(plhs,sub,nsubs,prhs) \\\n        mexSubsAssign_is_not_supported_by_Simulink_Coder\n\n#define mexSubsReference(prhs,subs,nsubs) \\\n        mexSubsReference_is_not_supported_by_Simulink_Coder\n\n#define mexPrintAssertion(test,fname,linenum,message) \\\n        mexPrintAssertion_is_not_supported_by_Simulink_Coder\n\n#define mexAddFlops(count) \\\n        mexAddFlops_is_not_supported_by_Simulink_Coder\n\n#define mexIsGlobal(pa) \\\n        mexIsGlobal_is_not_supported_by_Simulink_Coder\n\n#define mexAtExit(fcn) \\\n        mexAtExit_is_not_supported_by_Simulink_Coder\n\n/* [EOF] rt_matrx.c */\n"},{"name":"rt_printf.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2023a/rtw/c/src","tag":"","groupDisplay":"Other files","code":"/* Copyright 1994-2015 The MathWorks, Inc.\n *\n * File: rt_printf.c\n *\n * Abstract:\n *      Stub I/O printf facility for systems which don't have stdio.\n *\n */\n\n\n\n/* Function: rtPrintfNoOp ======================================================\n * Abstract:\n *      Maps ssPrintf to rtPrintfNoOp if HAVESTDIO is not defined (see\n *      simstruct.h\n */\nint rtPrintfNoOp(const char *fmt, ...)\n{\n    /* do nothing */\n    return(fmt == (const char *)0); /* use fmt to quiet unused var warning */\n}\n\n\n/* [eof] rt_printf.c */\n"},{"name":"rte_ATTN_parameters.cpp","type":"source","group":"legacy","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Other files","code":"#include \"rte_ATTN_parameters.h\"\n#include \"ATTN.h\"\n#include \"ATTN_cal.h\"\n\nextern ATTN_cal_type ATTN_cal_impl;\nnamespace slrealtime\n{\n  /* Description of SEGMENTS */\n  SegmentVector segmentInfo {\n    { (void*)&ATTN_cal_impl, (void**)&ATTN_cal, sizeof(ATTN_cal_type), 2 }\n  };\n\n  SegmentVector &getSegmentVector(void)\n  {\n    return segmentInfo;\n  }\n}                                      // slrealtime\n"},{"name":"rte_ATTN_parameters.h","type":"header","group":"other","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef _RTE_ATTN_PARAMETERS_H\n#define _RTE_ATTN_PARAMETERS_H\n#include \"rtwtypes.h\"\n#include \"SegmentInfo.hpp\"\n\nnamespace slrealtime\n{\n  SegmentVector &getSegmentVector(void);\n}                                      // slrealtime\n\n#endif\n"},{"name":"slrealtime_datatype_ground.cpp","type":"source","group":"legacy","path":"/home/electro/Code_Repo/n-CORTEx/ATTN_slrealtime_rtw","tag":"","groupDisplay":"Other files","code":"#include \"slrtdatatypes.h\"\n\nconst serialfifoptr serialfifoground = { 0, 0, 0 };\n\nconst bcmsglist1553 bcmsg1553ground = { 0, 0, 0, 0 };\n\nconst bcstatus1553 bcstatground = { 0, 0, 0, 0, 0, 0 };\n\nconst bmmsglist1553 bmmsg1553ground = { 0, 0, 0, 0 };\n"}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true}};
>>>>>>> ATTN_integration
