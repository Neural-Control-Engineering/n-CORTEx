var dataJson = {"arch":{"ispc":false,"isunix":true,"ismac":false},"build":"nCORTEx","ref":false,"files":[{"name":"nCORTEx.cpp","type":"source","group":"model","path":"/home/electro/Code_Repo/n-CORTEx/nCORTEx_slrealtime_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * nCORTEx.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"nCORTEx\".\n *\n * Model version              : 1.119\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Oct 12 12:29:21 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"nCORTEx.h\"\n#include \"rtwtypes.h\"\n#include \"nCORTEx_cal.h\"\n#include \"nCORTEx_private.h\"\n#include <cstring>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n/* Named constants for MATLAB Function: '<Root>/MATLAB Function' */\nconst int32_T nCORTEx_CALL_EVENT = -1;\nconst real_T nCORTEx_RGND = 0.0;       /* real_T ground */\n\n/* Block signals (default storage) */\nB_nCORTEx_T nCORTEx_B;\n\n/* Block states (default storage) */\nDW_nCORTEx_T nCORTEx_DW;\n\n/* Real-time model */\nRT_MODEL_nCORTEx_T nCORTEx_M_ = RT_MODEL_nCORTEx_T();\nRT_MODEL_nCORTEx_T *const nCORTEx_M = &nCORTEx_M_;\n\n/* Model step function */\nvoid nCORTEx_step(void)\n{\n  real_T tmp;\n\n  /* DiscretePulseGenerator: '<Root>/Whisker Trig' */\n  tmp = nCORTEx_cal->T_whisk / 2.0;\n\n  /* DiscretePulseGenerator: '<Root>/Whisker Trig' */\n  nCORTEx_B.whiskCam_trig = (nCORTEx_DW.clockTickCounter < tmp) &&\n    (nCORTEx_DW.clockTickCounter >= 0) ? nCORTEx_cal->WhiskerTrig_Amp : 0.0;\n\n  /* DiscretePulseGenerator: '<Root>/Whisker Trig' */\n  if (nCORTEx_DW.clockTickCounter >= nCORTEx_cal->T_whisk - 1.0) {\n    nCORTEx_DW.clockTickCounter = 0;\n  } else {\n    nCORTEx_DW.clockTickCounter++;\n  }\n\n  /* DiscretePulseGenerator: '<Root>/Npxls Trig' */\n  tmp = nCORTEx_cal->T_npxls / 2.0;\n\n  /* DiscretePulseGenerator: '<Root>/Npxls Trig' */\n  nCORTEx_B.npxls_trig = (nCORTEx_DW.clockTickCounter_n < tmp) &&\n    (nCORTEx_DW.clockTickCounter_n >= 0) ? nCORTEx_cal->NpxlsTrig_Amp : 0.0;\n\n  /* DiscretePulseGenerator: '<Root>/Npxls Trig' */\n  if (nCORTEx_DW.clockTickCounter_n >= nCORTEx_cal->T_npxls - 1.0) {\n    nCORTEx_DW.clockTickCounter_n = 0;\n  } else {\n    nCORTEx_DW.clockTickCounter_n++;\n  }\n\n  /* DiscretePulseGenerator: '<Root>/Pupil Trig' */\n  tmp = nCORTEx_cal->T_pupil / 2.0;\n\n  /* DiscretePulseGenerator: '<Root>/Pupil Trig' */\n  nCORTEx_B.pupilCam_trig = (nCORTEx_DW.clockTickCounter_c < tmp) &&\n    (nCORTEx_DW.clockTickCounter_c >= 0) ? nCORTEx_cal->PupilTrig_Amp : 0.0;\n\n  /* DiscretePulseGenerator: '<Root>/Pupil Trig' */\n  if (nCORTEx_DW.clockTickCounter_c >= nCORTEx_cal->T_pupil - 1.0) {\n    nCORTEx_DW.clockTickCounter_c = 0;\n  } else {\n    nCORTEx_DW.clockTickCounter_c++;\n  }\n\n  /* Memory: '<Root>/Memory2' */\n  nCORTEx_B.Memory2 = nCORTEx_DW.Memory2_PreviousInput;\n\n  /* Memory: '<Root>/Memory1' */\n  nCORTEx_B.Memory1 = nCORTEx_DW.Memory1_PreviousInput;\n\n  /* Memory: '<Root>/Memory' */\n  nCORTEx_B.Memory = nCORTEx_DW.Memory_PreviousInput;\n\n  /* Memory: '<Root>/Memory3' */\n  nCORTEx_B.Memory3 = nCORTEx_DW.Memory3_PreviousInput;\n\n  /* Memory: '<Root>/Memory4' */\n  nCORTEx_B.Memory4 = nCORTEx_DW.Memory4_PreviousInput;\n\n  /* MATLAB Function: '<Root>/MATLAB Function' incorporates:\n   *  Constant: '<Root>/Constant1'\n   *  Constant: '<Root>/Constant2'\n   */\n  nCORTEx_DW.sfEvent_e = nCORTEx_CALL_EVENT;\n  switch (static_cast<int32_T>(nCORTEx_B.Memory2)) {\n   case 1:\n    nCORTEx_B.npxlsAcq_out = 2.5;\n    nCORTEx_B.onsetTone_trig = 1.0;\n    nCORTEx_B.state_out = 2.0;\n    nCORTEx_B.localTime_out = 1.0;\n    nCORTEx_B.trialNum_out = 1.0;\n    break;\n\n   case 2:\n    nCORTEx_B.onsetTone_trig = 0.0;\n    nCORTEx_B.state_out = nCORTEx_B.Memory2;\n    nCORTEx_B.localTime_out = nCORTEx_B.Memory1 + 1.0;\n    nCORTEx_B.trialNum_out = nCORTEx_B.Memory + 1.0;\n    nCORTEx_B.npxlsAcq_out = nCORTEx_B.Memory3;\n    break;\n\n   default:\n    nCORTEx_B.onsetTone_trig = 0.0;\n    nCORTEx_B.state_out = nCORTEx_B.Memory2;\n    nCORTEx_B.localTime_out = nCORTEx_B.Memory1;\n    nCORTEx_B.trialNum_out = nCORTEx_B.Memory;\n    nCORTEx_B.npxlsAcq_out = nCORTEx_B.Memory3;\n    break;\n  }\n\n  if (nCORTEx_B.Memory4 + 1.0 == nCORTEx_cal->tStop * nCORTEx_cal->SampleTime) {\n    nCORTEx_B.npxlsAcq_out = 0.0;\n  }\n\n  nCORTEx_B.counter_out = nCORTEx_B.Memory4 + 1.0;\n\n  /* End of MATLAB Function: '<Root>/MATLAB Function' */\n\n  /* Clock: '<S2>/Clock' */\n  nCORTEx_B.Clock = nCORTEx_M->Timing.t[0];\n\n  /* MATLAB Function: '<S2>/MATLAB Function1' */\n  nCORTEx_DW.sfEvent = nCORTEx_CALL_EVENT;\n  if (nCORTEx_B.onsetTone_trig != 0.0) {\n    nCORTEx_B.tonePulse = 1.0;\n    nCORTEx_DW.t0 = nCORTEx_B.Clock;\n    nCORTEx_DW.t0_not_empty = true;\n  } else if (nCORTEx_DW.t0_not_empty) {\n    nCORTEx_B.tonePulse = (nCORTEx_B.Clock - nCORTEx_DW.t0 < 1.5);\n  } else {\n    nCORTEx_B.tonePulse = 0.0;\n  }\n\n  /* End of MATLAB Function: '<S2>/MATLAB Function1' */\n\n  /* S-Function (sg_IO191_setup_s): '<Root>/Setup ' */\n\n  /* Level2 S-Function Block: '<Root>/Setup ' (sg_IO191_setup_s) */\n  {\n    SimStruct *rts = nCORTEx_M->childSfunctions[0];\n    sfcnOutputs(rts,0);\n  }\n\n  /* S-Function (sg_IO191_do_s): '<Root>/Digital output ' */\n\n  /* Level2 S-Function Block: '<Root>/Digital output ' (sg_IO191_do_s) */\n  {\n    SimStruct *rts = nCORTEx_M->childSfunctions[1];\n    sfcnOutputs(rts,0);\n  }\n\n  /* S-Function (sg_IO191_di_s): '<Root>/Digital input ' */\n\n  /* Level2 S-Function Block: '<Root>/Digital input ' (sg_IO191_di_s) */\n  {\n    SimStruct *rts = nCORTEx_M->childSfunctions[2];\n    sfcnOutputs(rts,0);\n  }\n\n  /* RateTransition generated from: '<Root>/Digital input ' */\n  nCORTEx_B.HiddenRateTransitionForToWks_In = nCORTEx_B.PulseGen1Hz;\n\n  /* RelationalOperator: '<Root>/Relational Operator' incorporates:\n   *  Constant: '<Root>/Constant'\n   */\n  nCORTEx_B.RelationalOperator = (nCORTEx_B.counter_out >=\n    nCORTEx_cal->maxFrames);\n\n  /* Stop: '<Root>/Stop Simulation' */\n  if (nCORTEx_B.RelationalOperator) {\n    rtmSetStopRequested(nCORTEx_M, 1);\n  }\n\n  /* End of Stop: '<Root>/Stop Simulation' */\n\n  /* Update for Memory: '<Root>/Memory2' */\n  nCORTEx_DW.Memory2_PreviousInput = nCORTEx_B.state_out;\n\n  /* Update for Memory: '<Root>/Memory1' */\n  nCORTEx_DW.Memory1_PreviousInput = nCORTEx_B.localTime_out;\n\n  /* Update for Memory: '<Root>/Memory' */\n  nCORTEx_DW.Memory_PreviousInput = nCORTEx_B.trialNum_out;\n\n  /* Update for Memory: '<Root>/Memory3' */\n  nCORTEx_DW.Memory3_PreviousInput = nCORTEx_B.npxlsAcq_out;\n\n  /* Update for Memory: '<Root>/Memory4' */\n  nCORTEx_DW.Memory4_PreviousInput = nCORTEx_B.counter_out;\n\n  /* Update absolute time for base rate */\n  /* The \"clockTick0\" counts the number of times the code of this task has\n   * been executed. The absolute time is the multiplication of \"clockTick0\"\n   * and \"Timing.stepSize0\". Size of \"clockTick0\" ensures timer will not\n   * overflow during the application lifespan selected.\n   * Timer of this task consists of two 32 bit unsigned integers.\n   * The two integers represent the low bits Timing.clockTick0 and the high bits\n   * Timing.clockTickH0. When the low bit overflows to 0, the high bits increment.\n   */\n  if (!(++nCORTEx_M->Timing.clockTick0)) {\n    ++nCORTEx_M->Timing.clockTickH0;\n  }\n\n  nCORTEx_M->Timing.t[0] = nCORTEx_M->Timing.clockTick0 *\n    nCORTEx_M->Timing.stepSize0 + nCORTEx_M->Timing.clockTickH0 *\n    nCORTEx_M->Timing.stepSize0 * 4294967296.0;\n\n  {\n    /* Update absolute timer for sample time: [0.001s, 0.0s] */\n    /* The \"clockTick1\" counts the number of times the code of this task has\n     * been executed. The absolute time is the multiplication of \"clockTick1\"\n     * and \"Timing.stepSize1\". Size of \"clockTick1\" ensures timer will not\n     * overflow during the application lifespan selected.\n     * Timer of this task consists of two 32 bit unsigned integers.\n     * The two integers represent the low bits Timing.clockTick1 and the high bits\n     * Timing.clockTickH1. When the low bit overflows to 0, the high bits increment.\n     */\n    if (!(++nCORTEx_M->Timing.clockTick1)) {\n      ++nCORTEx_M->Timing.clockTickH1;\n    }\n\n    nCORTEx_M->Timing.t[1] = nCORTEx_M->Timing.clockTick1 *\n      nCORTEx_M->Timing.stepSize1 + nCORTEx_M->Timing.clockTickH1 *\n      nCORTEx_M->Timing.stepSize1 * 4294967296.0;\n  }\n}\n\n/* Model initialize function */\nvoid nCORTEx_initialize(void)\n{\n  /* Registration code */\n\n  /* initialize non-finites */\n  rt_InitInfAndNaN(sizeof(real_T));\n\n  {\n    /* Setup solver object */\n    rtsiSetSimTimeStepPtr(&nCORTEx_M->solverInfo, &nCORTEx_M->Timing.simTimeStep);\n    rtsiSetTPtr(&nCORTEx_M->solverInfo, &rtmGetTPtr(nCORTEx_M));\n    rtsiSetStepSizePtr(&nCORTEx_M->solverInfo, &nCORTEx_M->Timing.stepSize0);\n    rtsiSetErrorStatusPtr(&nCORTEx_M->solverInfo, (&rtmGetErrorStatus(nCORTEx_M)));\n    rtsiSetRTModelPtr(&nCORTEx_M->solverInfo, nCORTEx_M);\n  }\n\n  rtsiSetSimTimeStep(&nCORTEx_M->solverInfo, MAJOR_TIME_STEP);\n  rtsiSetSolverName(&nCORTEx_M->solverInfo,\"FixedStepDiscrete\");\n  nCORTEx_M->solverInfoPtr = (&nCORTEx_M->solverInfo);\n\n  /* Initialize timing info */\n  {\n    int_T *mdlTsMap = nCORTEx_M->Timing.sampleTimeTaskIDArray;\n    mdlTsMap[0] = 0;\n    mdlTsMap[1] = 1;\n\n    /* polyspace +2 MISRA2012:D4.1 [Justified:Low] \"nCORTEx_M points to\n       static memory which is guaranteed to be non-NULL\" */\n    nCORTEx_M->Timing.sampleTimeTaskIDPtr = (&mdlTsMap[0]);\n    nCORTEx_M->Timing.sampleTimes = (&nCORTEx_M->Timing.sampleTimesArray[0]);\n    nCORTEx_M->Timing.offsetTimes = (&nCORTEx_M->Timing.offsetTimesArray[0]);\n\n    /* task periods */\n    nCORTEx_M->Timing.sampleTimes[0] = (0.0);\n    nCORTEx_M->Timing.sampleTimes[1] = (0.001);\n\n    /* task offsets */\n    nCORTEx_M->Timing.offsetTimes[0] = (0.0);\n    nCORTEx_M->Timing.offsetTimes[1] = (0.0);\n  }\n\n  rtmSetTPtr(nCORTEx_M, &nCORTEx_M->Timing.tArray[0]);\n\n  {\n    int_T *mdlSampleHits = nCORTEx_M->Timing.sampleHitArray;\n    mdlSampleHits[0] = 1;\n    mdlSampleHits[1] = 1;\n    nCORTEx_M->Timing.sampleHits = (&mdlSampleHits[0]);\n  }\n\n  rtmSetTFinal(nCORTEx_M, -1);\n  nCORTEx_M->Timing.stepSize0 = 0.001;\n  nCORTEx_M->Timing.stepSize1 = 0.001;\n  nCORTEx_M->solverInfoPtr = (&nCORTEx_M->solverInfo);\n  nCORTEx_M->Timing.stepSize = (0.001);\n  rtsiSetFixedStepSize(&nCORTEx_M->solverInfo, 0.001);\n  rtsiSetSolverMode(&nCORTEx_M->solverInfo, SOLVER_MODE_SINGLETASKING);\n\n  /* block I/O */\n  (void) std::memset((static_cast<void *>(&nCORTEx_B)), 0,\n                     sizeof(B_nCORTEx_T));\n\n  /* states (dwork) */\n  (void) std::memset(static_cast<void *>(&nCORTEx_DW), 0,\n                     sizeof(DW_nCORTEx_T));\n\n  /* child S-Function registration */\n  {\n    RTWSfcnInfo *sfcnInfo = &nCORTEx_M->NonInlinedSFcns.sfcnInfo;\n    nCORTEx_M->sfcnInfo = (sfcnInfo);\n    rtssSetErrorStatusPtr(sfcnInfo, (&rtmGetErrorStatus(nCORTEx_M)));\n    nCORTEx_M->Sizes.numSampTimes = (2);\n    rtssSetNumRootSampTimesPtr(sfcnInfo, &nCORTEx_M->Sizes.numSampTimes);\n    nCORTEx_M->NonInlinedSFcns.taskTimePtrs[0] = (&rtmGetTPtr(nCORTEx_M)[0]);\n    nCORTEx_M->NonInlinedSFcns.taskTimePtrs[1] = (&rtmGetTPtr(nCORTEx_M)[1]);\n    rtssSetTPtrPtr(sfcnInfo,nCORTEx_M->NonInlinedSFcns.taskTimePtrs);\n    rtssSetTStartPtr(sfcnInfo, &rtmGetTStart(nCORTEx_M));\n    rtssSetTFinalPtr(sfcnInfo, &rtmGetTFinal(nCORTEx_M));\n    rtssSetTimeOfLastOutputPtr(sfcnInfo, &rtmGetTimeOfLastOutput(nCORTEx_M));\n    rtssSetStepSizePtr(sfcnInfo, &nCORTEx_M->Timing.stepSize);\n    rtssSetStopRequestedPtr(sfcnInfo, &rtmGetStopRequested(nCORTEx_M));\n    rtssSetDerivCacheNeedsResetPtr(sfcnInfo, &nCORTEx_M->derivCacheNeedsReset);\n    rtssSetZCCacheNeedsResetPtr(sfcnInfo, &nCORTEx_M->zCCacheNeedsReset);\n    rtssSetContTimeOutputInconsistentWithStateAtMajorStepPtr(sfcnInfo,\n      &nCORTEx_M->CTOutputIncnstWithState);\n    rtssSetSampleHitsPtr(sfcnInfo, &nCORTEx_M->Timing.sampleHits);\n    rtssSetPerTaskSampleHitsPtr(sfcnInfo, &nCORTEx_M->Timing.perTaskSampleHits);\n    rtssSetSimModePtr(sfcnInfo, &nCORTEx_M->simMode);\n    rtssSetSolverInfoPtr(sfcnInfo, &nCORTEx_M->solverInfoPtr);\n  }\n\n  nCORTEx_M->Sizes.numSFcns = (3);\n\n  /* register each child */\n  {\n    (void) std::memset(static_cast<void *>\n                       (&nCORTEx_M->NonInlinedSFcns.childSFunctions[0]), 0,\n                       3*sizeof(SimStruct));\n    nCORTEx_M->childSfunctions = (&nCORTEx_M->\n      NonInlinedSFcns.childSFunctionPtrs[0]);\n    nCORTEx_M->childSfunctions[0] = (&nCORTEx_M->\n      NonInlinedSFcns.childSFunctions[0]);\n    nCORTEx_M->childSfunctions[1] = (&nCORTEx_M->\n      NonInlinedSFcns.childSFunctions[1]);\n    nCORTEx_M->childSfunctions[2] = (&nCORTEx_M->\n      NonInlinedSFcns.childSFunctions[2]);\n\n    /* Level2 S-Function Block: nCORTEx/<Root>/Setup  (sg_IO191_setup_s) */\n    {\n      SimStruct *rts = nCORTEx_M->childSfunctions[0];\n\n      /* timing info */\n      time_T *sfcnPeriod = nCORTEx_M->NonInlinedSFcns.Sfcn0.sfcnPeriod;\n      time_T *sfcnOffset = nCORTEx_M->NonInlinedSFcns.Sfcn0.sfcnOffset;\n      int_T *sfcnTsMap = nCORTEx_M->NonInlinedSFcns.Sfcn0.sfcnTsMap;\n      (void) std::memset(static_cast<void*>(sfcnPeriod), 0,\n                         sizeof(time_T)*1);\n      (void) std::memset(static_cast<void*>(sfcnOffset), 0,\n                         sizeof(time_T)*1);\n      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);\n      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);\n      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);\n\n      {\n        ssSetBlkInfo2Ptr(rts, &nCORTEx_M->NonInlinedSFcns.blkInfo2[0]);\n      }\n\n      _ssSetBlkInfo2PortInfo2Ptr(rts,\n        &nCORTEx_M->NonInlinedSFcns.inputOutputPortInfo2[0]);\n\n      /* Set up the mdlInfo pointer */\n      ssSetRTWSfcnInfo(rts, nCORTEx_M->sfcnInfo);\n\n      /* Allocate memory of model methods 2 */\n      {\n        ssSetModelMethods2(rts, &nCORTEx_M->NonInlinedSFcns.methods2[0]);\n      }\n\n      /* Allocate memory of model methods 3 */\n      {\n        ssSetModelMethods3(rts, &nCORTEx_M->NonInlinedSFcns.methods3[0]);\n      }\n\n      /* Allocate memory of model methods 4 */\n      {\n        ssSetModelMethods4(rts, &nCORTEx_M->NonInlinedSFcns.methods4[0]);\n      }\n\n      /* Allocate memory for states auxilliary information */\n      {\n        ssSetStatesInfo2(rts, &nCORTEx_M->NonInlinedSFcns.statesInfo2[0]);\n        ssSetPeriodicStatesInfo(rts,\n          &nCORTEx_M->NonInlinedSFcns.periodicStatesInfo[0]);\n      }\n\n      /* path info */\n      ssSetModelName(rts, \"Setup \");\n      ssSetPath(rts, \"nCORTEx/Setup \");\n      ssSetRTModel(rts,nCORTEx_M);\n      ssSetParentSS(rts, (NULL));\n      ssSetRootSS(rts, rts);\n      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);\n\n      /* parameters */\n      {\n        mxArray **sfcnParams = (mxArray **)\n          &nCORTEx_M->NonInlinedSFcns.Sfcn0.params;\n        ssSetSFcnParamsCount(rts, 9);\n        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);\n        ssSetSFcnParam(rts, 0, (mxArray*)nCORTEx_cal->Setup_P1_Size);\n        ssSetSFcnParam(rts, 1, (mxArray*)nCORTEx_cal->Setup_P2_Size);\n        ssSetSFcnParam(rts, 2, (mxArray*)nCORTEx_cal->Setup_P3_Size);\n        ssSetSFcnParam(rts, 3, (mxArray*)nCORTEx_cal->Setup_P4_Size);\n        ssSetSFcnParam(rts, 4, (mxArray*)nCORTEx_cal->Setup_P5_Size);\n        ssSetSFcnParam(rts, 5, (mxArray*)nCORTEx_cal->Setup_P6_Size);\n        ssSetSFcnParam(rts, 6, (mxArray*)nCORTEx_cal->Setup_P7_Size);\n        ssSetSFcnParam(rts, 7, (mxArray*)nCORTEx_cal->Setup_P8_Size);\n        ssSetSFcnParam(rts, 8, (mxArray*)nCORTEx_cal->Setup_P9_Size);\n      }\n\n      /* work vectors */\n      ssSetRWork(rts, (real_T *) &nCORTEx_DW.Setup_RWORK[0]);\n      ssSetPWork(rts, (void **) &nCORTEx_DW.Setup_PWORK);\n\n      {\n        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)\n          &nCORTEx_M->NonInlinedSFcns.Sfcn0.dWork;\n        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)\n          &nCORTEx_M->NonInlinedSFcns.Sfcn0.dWorkAux;\n        ssSetSFcnDWork(rts, dWorkRecord);\n        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);\n        ssSetNumDWorkAsInt(rts, 2);\n\n        /* RWORK */\n        ssSetDWorkWidthAsInt(rts, 0, 2);\n        ssSetDWorkDataType(rts, 0,SS_DOUBLE);\n        ssSetDWorkComplexSignal(rts, 0, 0);\n        ssSetDWork(rts, 0, &nCORTEx_DW.Setup_RWORK[0]);\n\n        /* PWORK */\n        ssSetDWorkWidthAsInt(rts, 1, 1);\n        ssSetDWorkDataType(rts, 1,SS_POINTER);\n        ssSetDWorkComplexSignal(rts, 1, 0);\n        ssSetDWork(rts, 1, &nCORTEx_DW.Setup_PWORK);\n      }\n\n      /* registration */\n      sg_IO191_setup_s(rts);\n      sfcnInitializeSizes(rts);\n      sfcnInitializeSampleTimes(rts);\n\n      /* adjust sample time */\n      ssSetSampleTime(rts, 0, 0.001);\n      ssSetOffsetTime(rts, 0, 0.0);\n      sfcnTsMap[0] = 1;\n\n      /* set compiled values of dynamic vector attributes */\n      ssSetNumNonsampledZCsAsInt(rts, 0);\n\n      /* Update connectivity flags for each port */\n      /* Update the BufferDstPort flags for each input port */\n    }\n\n    /* Level2 S-Function Block: nCORTEx/<Root>/Digital output  (sg_IO191_do_s) */\n    {\n      SimStruct *rts = nCORTEx_M->childSfunctions[1];\n\n      /* timing info */\n      time_T *sfcnPeriod = nCORTEx_M->NonInlinedSFcns.Sfcn1.sfcnPeriod;\n      time_T *sfcnOffset = nCORTEx_M->NonInlinedSFcns.Sfcn1.sfcnOffset;\n      int_T *sfcnTsMap = nCORTEx_M->NonInlinedSFcns.Sfcn1.sfcnTsMap;\n      (void) std::memset(static_cast<void*>(sfcnPeriod), 0,\n                         sizeof(time_T)*1);\n      (void) std::memset(static_cast<void*>(sfcnOffset), 0,\n                         sizeof(time_T)*1);\n      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);\n      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);\n      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);\n\n      {\n        ssSetBlkInfo2Ptr(rts, &nCORTEx_M->NonInlinedSFcns.blkInfo2[1]);\n      }\n\n      _ssSetBlkInfo2PortInfo2Ptr(rts,\n        &nCORTEx_M->NonInlinedSFcns.inputOutputPortInfo2[1]);\n\n      /* Set up the mdlInfo pointer */\n      ssSetRTWSfcnInfo(rts, nCORTEx_M->sfcnInfo);\n\n      /* Allocate memory of model methods 2 */\n      {\n        ssSetModelMethods2(rts, &nCORTEx_M->NonInlinedSFcns.methods2[1]);\n      }\n\n      /* Allocate memory of model methods 3 */\n      {\n        ssSetModelMethods3(rts, &nCORTEx_M->NonInlinedSFcns.methods3[1]);\n      }\n\n      /* Allocate memory of model methods 4 */\n      {\n        ssSetModelMethods4(rts, &nCORTEx_M->NonInlinedSFcns.methods4[1]);\n      }\n\n      /* Allocate memory for states auxilliary information */\n      {\n        ssSetStatesInfo2(rts, &nCORTEx_M->NonInlinedSFcns.statesInfo2[1]);\n        ssSetPeriodicStatesInfo(rts,\n          &nCORTEx_M->NonInlinedSFcns.periodicStatesInfo[1]);\n      }\n\n      /* inputs */\n      {\n        _ssSetNumInputPorts(rts, 15);\n        ssSetPortInfoForInputs(rts,\n          &nCORTEx_M->NonInlinedSFcns.Sfcn1.inputPortInfo[0]);\n        ssSetPortInfoForInputs(rts,\n          &nCORTEx_M->NonInlinedSFcns.Sfcn1.inputPortInfo[0]);\n        _ssSetPortInfo2ForInputUnits(rts,\n          &nCORTEx_M->NonInlinedSFcns.Sfcn1.inputPortUnits[0]);\n        ssSetInputPortUnit(rts, 0, 0);\n        ssSetInputPortUnit(rts, 1, 0);\n        ssSetInputPortUnit(rts, 2, 0);\n        ssSetInputPortUnit(rts, 3, 0);\n        ssSetInputPortUnit(rts, 4, 0);\n        ssSetInputPortUnit(rts, 5, 0);\n        ssSetInputPortUnit(rts, 6, 0);\n        ssSetInputPortUnit(rts, 7, 0);\n        ssSetInputPortUnit(rts, 8, 0);\n        ssSetInputPortUnit(rts, 9, 0);\n        ssSetInputPortUnit(rts, 10, 0);\n        ssSetInputPortUnit(rts, 11, 0);\n        ssSetInputPortUnit(rts, 12, 0);\n        ssSetInputPortUnit(rts, 13, 0);\n        ssSetInputPortUnit(rts, 14, 0);\n        _ssSetPortInfo2ForInputCoSimAttribute(rts,\n          &nCORTEx_M->NonInlinedSFcns.Sfcn1.inputPortCoSimAttribute[0]);\n        ssSetInputPortIsContinuousQuantity(rts, 0, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 1, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 2, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 3, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 4, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 5, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 6, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 7, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 8, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 9, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 10, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 11, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 12, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 13, 0);\n        ssSetInputPortIsContinuousQuantity(rts, 14, 0);\n\n        /* port 0 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 0, 1);\n          ssSetInputPortSignal(rts, 0, &nCORTEx_B.whiskCam_trig);\n          _ssSetInputPortNumDimensions(rts, 0, 1);\n          ssSetInputPortWidthAsInt(rts, 0, 1);\n        }\n\n        /* port 1 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 1, 1);\n          ssSetInputPortSignal(rts, 1, &nCORTEx_B.npxls_trig);\n          _ssSetInputPortNumDimensions(rts, 1, 1);\n          ssSetInputPortWidthAsInt(rts, 1, 1);\n        }\n\n        /* port 2 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 2, 1);\n          ssSetInputPortSignal(rts, 2, &nCORTEx_B.pupilCam_trig);\n          _ssSetInputPortNumDimensions(rts, 2, 1);\n          ssSetInputPortWidthAsInt(rts, 2, 1);\n        }\n\n        /* port 3 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 3, 1);\n          ssSetInputPortSignal(rts, 3, &nCORTEx_B.npxlsAcq_out);\n          _ssSetInputPortNumDimensions(rts, 3, 1);\n          ssSetInputPortWidthAsInt(rts, 3, 1);\n        }\n\n        /* port 4 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 4, 1);\n          ssSetInputPortSignal(rts, 4, (const_cast<real_T*>(&nCORTEx_RGND)));\n          _ssSetInputPortNumDimensions(rts, 4, 1);\n          ssSetInputPortWidthAsInt(rts, 4, 1);\n        }\n\n        /* port 5 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 5, 1);\n          ssSetInputPortSignal(rts, 5, (const_cast<real_T*>(&nCORTEx_RGND)));\n          _ssSetInputPortNumDimensions(rts, 5, 1);\n          ssSetInputPortWidthAsInt(rts, 5, 1);\n        }\n\n        /* port 6 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 6, 1);\n          ssSetInputPortSignal(rts, 6, (const_cast<real_T*>(&nCORTEx_RGND)));\n          _ssSetInputPortNumDimensions(rts, 6, 1);\n          ssSetInputPortWidthAsInt(rts, 6, 1);\n        }\n\n        /* port 7 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 7, 1);\n          ssSetInputPortSignal(rts, 7, (const_cast<real_T*>(&nCORTEx_RGND)));\n          _ssSetInputPortNumDimensions(rts, 7, 1);\n          ssSetInputPortWidthAsInt(rts, 7, 1);\n        }\n\n        /* port 8 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 8, 1);\n          ssSetInputPortSignal(rts, 8, (const_cast<real_T*>(&nCORTEx_RGND)));\n          _ssSetInputPortNumDimensions(rts, 8, 1);\n          ssSetInputPortWidthAsInt(rts, 8, 1);\n        }\n\n        /* port 9 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 9, 1);\n          ssSetInputPortSignal(rts, 9, (const_cast<real_T*>(&nCORTEx_RGND)));\n          _ssSetInputPortNumDimensions(rts, 9, 1);\n          ssSetInputPortWidthAsInt(rts, 9, 1);\n        }\n\n        /* port 10 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 10, 1);\n          ssSetInputPortSignal(rts, 10, (const_cast<real_T*>(&nCORTEx_RGND)));\n          _ssSetInputPortNumDimensions(rts, 10, 1);\n          ssSetInputPortWidthAsInt(rts, 10, 1);\n        }\n\n        /* port 11 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 11, 1);\n          ssSetInputPortSignal(rts, 11, (const_cast<real_T*>(&nCORTEx_RGND)));\n          _ssSetInputPortNumDimensions(rts, 11, 1);\n          ssSetInputPortWidthAsInt(rts, 11, 1);\n        }\n\n        /* port 12 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 12, 1);\n          ssSetInputPortSignal(rts, 12, (const_cast<real_T*>(&nCORTEx_RGND)));\n          _ssSetInputPortNumDimensions(rts, 12, 1);\n          ssSetInputPortWidthAsInt(rts, 12, 1);\n        }\n\n        /* port 13 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 13, 1);\n          ssSetInputPortSignal(rts, 13, (const_cast<real_T*>(&nCORTEx_RGND)));\n          _ssSetInputPortNumDimensions(rts, 13, 1);\n          ssSetInputPortWidthAsInt(rts, 13, 1);\n        }\n\n        /* port 14 */\n        {\n          ssSetInputPortRequiredContiguous(rts, 14, 1);\n          ssSetInputPortSignal(rts, 14, &nCORTEx_B.tonePulse);\n          _ssSetInputPortNumDimensions(rts, 14, 1);\n          ssSetInputPortWidthAsInt(rts, 14, 1);\n        }\n      }\n\n      /* path info */\n      ssSetModelName(rts, \"Digital output \");\n      ssSetPath(rts, \"nCORTEx/Digital output \");\n      ssSetRTModel(rts,nCORTEx_M);\n      ssSetParentSS(rts, (NULL));\n      ssSetRootSS(rts, rts);\n      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);\n\n      /* parameters */\n      {\n        mxArray **sfcnParams = (mxArray **)\n          &nCORTEx_M->NonInlinedSFcns.Sfcn1.params;\n        ssSetSFcnParamsCount(rts, 6);\n        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);\n        ssSetSFcnParam(rts, 0, (mxArray*)nCORTEx_cal->Digitaloutput_P1_Size);\n        ssSetSFcnParam(rts, 1, (mxArray*)nCORTEx_cal->Digitaloutput_P2_Size);\n        ssSetSFcnParam(rts, 2, (mxArray*)nCORTEx_cal->Digitaloutput_P3_Size);\n        ssSetSFcnParam(rts, 3, (mxArray*)nCORTEx_cal->Digitaloutput_P4_Size);\n        ssSetSFcnParam(rts, 4, (mxArray*)nCORTEx_cal->Digitaloutput_P5_Size);\n        ssSetSFcnParam(rts, 5, (mxArray*)nCORTEx_cal->Digitaloutput_P6_Size);\n      }\n\n      /* work vectors */\n      ssSetPWork(rts, (void **) &nCORTEx_DW.Digitaloutput_PWORK);\n\n      {\n        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)\n          &nCORTEx_M->NonInlinedSFcns.Sfcn1.dWork;\n        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)\n          &nCORTEx_M->NonInlinedSFcns.Sfcn1.dWorkAux;\n        ssSetSFcnDWork(rts, dWorkRecord);\n        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);\n        ssSetNumDWorkAsInt(rts, 1);\n\n        /* PWORK */\n        ssSetDWorkWidthAsInt(rts, 0, 1);\n        ssSetDWorkDataType(rts, 0,SS_POINTER);\n        ssSetDWorkComplexSignal(rts, 0, 0);\n        ssSetDWork(rts, 0, &nCORTEx_DW.Digitaloutput_PWORK);\n      }\n\n      /* registration */\n      sg_IO191_do_s(rts);\n      sfcnInitializeSizes(rts);\n      sfcnInitializeSampleTimes(rts);\n\n      /* adjust sample time */\n      ssSetSampleTime(rts, 0, 0.001);\n      ssSetOffsetTime(rts, 0, 0.0);\n      sfcnTsMap[0] = 1;\n\n      /* set compiled values of dynamic vector attributes */\n      ssSetNumNonsampledZCsAsInt(rts, 0);\n\n      /* Update connectivity flags for each port */\n      _ssSetInputPortConnected(rts, 0, 1);\n      _ssSetInputPortConnected(rts, 1, 1);\n      _ssSetInputPortConnected(rts, 2, 1);\n      _ssSetInputPortConnected(rts, 3, 1);\n      _ssSetInputPortConnected(rts, 4, 0);\n      _ssSetInputPortConnected(rts, 5, 0);\n      _ssSetInputPortConnected(rts, 6, 0);\n      _ssSetInputPortConnected(rts, 7, 0);\n      _ssSetInputPortConnected(rts, 8, 0);\n      _ssSetInputPortConnected(rts, 9, 0);\n      _ssSetInputPortConnected(rts, 10, 0);\n      _ssSetInputPortConnected(rts, 11, 0);\n      _ssSetInputPortConnected(rts, 12, 0);\n      _ssSetInputPortConnected(rts, 13, 0);\n      _ssSetInputPortConnected(rts, 14, 1);\n\n      /* Update the BufferDstPort flags for each input port */\n      ssSetInputPortBufferDstPort(rts, 0, -1);\n      ssSetInputPortBufferDstPort(rts, 1, -1);\n      ssSetInputPortBufferDstPort(rts, 2, -1);\n      ssSetInputPortBufferDstPort(rts, 3, -1);\n      ssSetInputPortBufferDstPort(rts, 4, -1);\n      ssSetInputPortBufferDstPort(rts, 5, -1);\n      ssSetInputPortBufferDstPort(rts, 6, -1);\n      ssSetInputPortBufferDstPort(rts, 7, -1);\n      ssSetInputPortBufferDstPort(rts, 8, -1);\n      ssSetInputPortBufferDstPort(rts, 9, -1);\n      ssSetInputPortBufferDstPort(rts, 10, -1);\n      ssSetInputPortBufferDstPort(rts, 11, -1);\n      ssSetInputPortBufferDstPort(rts, 12, -1);\n      ssSetInputPortBufferDstPort(rts, 13, -1);\n      ssSetInputPortBufferDstPort(rts, 14, -1);\n    }\n\n    /* Level2 S-Function Block: nCORTEx/<Root>/Digital input  (sg_IO191_di_s) */\n    {\n      SimStruct *rts = nCORTEx_M->childSfunctions[2];\n\n      /* timing info */\n      time_T *sfcnPeriod = nCORTEx_M->NonInlinedSFcns.Sfcn2.sfcnPeriod;\n      time_T *sfcnOffset = nCORTEx_M->NonInlinedSFcns.Sfcn2.sfcnOffset;\n      int_T *sfcnTsMap = nCORTEx_M->NonInlinedSFcns.Sfcn2.sfcnTsMap;\n      (void) std::memset(static_cast<void*>(sfcnPeriod), 0,\n                         sizeof(time_T)*1);\n      (void) std::memset(static_cast<void*>(sfcnOffset), 0,\n                         sizeof(time_T)*1);\n      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);\n      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);\n      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);\n\n      {\n        ssSetBlkInfo2Ptr(rts, &nCORTEx_M->NonInlinedSFcns.blkInfo2[2]);\n      }\n\n      _ssSetBlkInfo2PortInfo2Ptr(rts,\n        &nCORTEx_M->NonInlinedSFcns.inputOutputPortInfo2[2]);\n\n      /* Set up the mdlInfo pointer */\n      ssSetRTWSfcnInfo(rts, nCORTEx_M->sfcnInfo);\n\n      /* Allocate memory of model methods 2 */\n      {\n        ssSetModelMethods2(rts, &nCORTEx_M->NonInlinedSFcns.methods2[2]);\n      }\n\n      /* Allocate memory of model methods 3 */\n      {\n        ssSetModelMethods3(rts, &nCORTEx_M->NonInlinedSFcns.methods3[2]);\n      }\n\n      /* Allocate memory of model methods 4 */\n      {\n        ssSetModelMethods4(rts, &nCORTEx_M->NonInlinedSFcns.methods4[2]);\n      }\n\n      /* Allocate memory for states auxilliary information */\n      {\n        ssSetStatesInfo2(rts, &nCORTEx_M->NonInlinedSFcns.statesInfo2[2]);\n        ssSetPeriodicStatesInfo(rts,\n          &nCORTEx_M->NonInlinedSFcns.periodicStatesInfo[2]);\n      }\n\n      /* outputs */\n      {\n        ssSetPortInfoForOutputs(rts,\n          &nCORTEx_M->NonInlinedSFcns.Sfcn2.outputPortInfo[0]);\n        ssSetPortInfoForOutputs(rts,\n          &nCORTEx_M->NonInlinedSFcns.Sfcn2.outputPortInfo[0]);\n        _ssSetNumOutputPorts(rts, 1);\n        _ssSetPortInfo2ForOutputUnits(rts,\n          &nCORTEx_M->NonInlinedSFcns.Sfcn2.outputPortUnits[0]);\n        ssSetOutputPortUnit(rts, 0, 0);\n        _ssSetPortInfo2ForOutputCoSimAttribute(rts,\n          &nCORTEx_M->NonInlinedSFcns.Sfcn2.outputPortCoSimAttribute[0]);\n        ssSetOutputPortIsContinuousQuantity(rts, 0, 0);\n\n        /* port 0 */\n        {\n          _ssSetOutputPortNumDimensions(rts, 0, 1);\n          ssSetOutputPortWidthAsInt(rts, 0, 1);\n          ssSetOutputPortSignal(rts, 0, ((real_T *) &nCORTEx_B.PulseGen1Hz));\n        }\n      }\n\n      /* path info */\n      ssSetModelName(rts, \"Digital input \");\n      ssSetPath(rts, \"nCORTEx/Digital input \");\n      ssSetRTModel(rts,nCORTEx_M);\n      ssSetParentSS(rts, (NULL));\n      ssSetRootSS(rts, rts);\n      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);\n\n      /* parameters */\n      {\n        mxArray **sfcnParams = (mxArray **)\n          &nCORTEx_M->NonInlinedSFcns.Sfcn2.params;\n        ssSetSFcnParamsCount(rts, 4);\n        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);\n        ssSetSFcnParam(rts, 0, (mxArray*)nCORTEx_cal->Digitalinput_P1_Size);\n        ssSetSFcnParam(rts, 1, (mxArray*)nCORTEx_cal->Digitalinput_P2_Size);\n        ssSetSFcnParam(rts, 2, (mxArray*)nCORTEx_cal->Digitalinput_P3_Size);\n        ssSetSFcnParam(rts, 3, (mxArray*)nCORTEx_cal->Digitalinput_P4_Size);\n      }\n\n      /* work vectors */\n      ssSetPWork(rts, (void **) &nCORTEx_DW.Digitalinput_PWORK);\n\n      {\n        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)\n          &nCORTEx_M->NonInlinedSFcns.Sfcn2.dWork;\n        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)\n          &nCORTEx_M->NonInlinedSFcns.Sfcn2.dWorkAux;\n        ssSetSFcnDWork(rts, dWorkRecord);\n        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);\n        ssSetNumDWorkAsInt(rts, 1);\n\n        /* PWORK */\n        ssSetDWorkWidthAsInt(rts, 0, 1);\n        ssSetDWorkDataType(rts, 0,SS_POINTER);\n        ssSetDWorkComplexSignal(rts, 0, 0);\n        ssSetDWork(rts, 0, &nCORTEx_DW.Digitalinput_PWORK);\n      }\n\n      /* registration */\n      sg_IO191_di_s(rts);\n      sfcnInitializeSizes(rts);\n      sfcnInitializeSampleTimes(rts);\n\n      /* adjust sample time */\n      ssSetSampleTime(rts, 0, 0.001);\n      ssSetOffsetTime(rts, 0, 0.0);\n      sfcnTsMap[0] = 1;\n\n      /* set compiled values of dynamic vector attributes */\n      ssSetNumNonsampledZCsAsInt(rts, 0);\n\n      /* Update connectivity flags for each port */\n      _ssSetOutputPortConnected(rts, 0, 1);\n      _ssSetOutputPortBeingMerged(rts, 0, 0);\n\n      /* Update the BufferDstPort flags for each input port */\n    }\n  }\n\n  /* Start for S-Function (sg_IO191_setup_s): '<Root>/Setup ' */\n  /* Level2 S-Function Block: '<Root>/Setup ' (sg_IO191_setup_s) */\n  {\n    SimStruct *rts = nCORTEx_M->childSfunctions[0];\n    sfcnStart(rts);\n    if (ssGetErrorStatus(rts) != (NULL))\n      return;\n  }\n\n  /* Start for S-Function (sg_IO191_do_s): '<Root>/Digital output ' */\n  /* Level2 S-Function Block: '<Root>/Digital output ' (sg_IO191_do_s) */\n  {\n    SimStruct *rts = nCORTEx_M->childSfunctions[1];\n    sfcnStart(rts);\n    if (ssGetErrorStatus(rts) != (NULL))\n      return;\n  }\n\n  /* Start for S-Function (sg_IO191_di_s): '<Root>/Digital input ' */\n  /* Level2 S-Function Block: '<Root>/Digital input ' (sg_IO191_di_s) */\n  {\n    SimStruct *rts = nCORTEx_M->childSfunctions[2];\n    sfcnStart(rts);\n    if (ssGetErrorStatus(rts) != (NULL))\n      return;\n  }\n\n  /* InitializeConditions for DiscretePulseGenerator: '<Root>/Whisker Trig' */\n  nCORTEx_DW.clockTickCounter = 0;\n\n  /* InitializeConditions for DiscretePulseGenerator: '<Root>/Npxls Trig' */\n  nCORTEx_DW.clockTickCounter_n = 0;\n\n  /* InitializeConditions for DiscretePulseGenerator: '<Root>/Pupil Trig' */\n  nCORTEx_DW.clockTickCounter_c = 0;\n\n  /* InitializeConditions for Memory: '<Root>/Memory2' */\n  nCORTEx_DW.Memory2_PreviousInput = nCORTEx_cal->Memory2_InitialCondition;\n\n  /* InitializeConditions for Memory: '<Root>/Memory1' */\n  nCORTEx_DW.Memory1_PreviousInput = nCORTEx_cal->Memory1_InitialCondition;\n\n  /* InitializeConditions for Memory: '<Root>/Memory' */\n  nCORTEx_DW.Memory_PreviousInput = nCORTEx_cal->Memory_InitialCondition;\n\n  /* InitializeConditions for Memory: '<Root>/Memory3' */\n  nCORTEx_DW.Memory3_PreviousInput = nCORTEx_cal->Memory3_InitialCondition;\n\n  /* InitializeConditions for Memory: '<Root>/Memory4' */\n  nCORTEx_DW.Memory4_PreviousInput = nCORTEx_cal->Memory4_InitialCondition;\n\n  /* SystemInitialize for MATLAB Function: '<Root>/MATLAB Function' */\n  nCORTEx_DW.sfEvent_e = nCORTEx_CALL_EVENT;\n  nCORTEx_DW.is_active_c1_nCORTEx = 0U;\n\n  /* SystemInitialize for MATLAB Function: '<S2>/MATLAB Function1' */\n  nCORTEx_DW.sfEvent = nCORTEx_CALL_EVENT;\n  nCORTEx_DW.t0_not_empty = false;\n  nCORTEx_DW.is_active_c2_nCORTEx = 0U;\n}\n\n/* Model terminate function */\nvoid nCORTEx_terminate(void)\n{\n  /* Terminate for S-Function (sg_IO191_setup_s): '<Root>/Setup ' */\n  /* Level2 S-Function Block: '<Root>/Setup ' (sg_IO191_setup_s) */\n  {\n    SimStruct *rts = nCORTEx_M->childSfunctions[0];\n    sfcnTerminate(rts);\n  }\n\n  /* Terminate for S-Function (sg_IO191_do_s): '<Root>/Digital output ' */\n  /* Level2 S-Function Block: '<Root>/Digital output ' (sg_IO191_do_s) */\n  {\n    SimStruct *rts = nCORTEx_M->childSfunctions[1];\n    sfcnTerminate(rts);\n  }\n\n  /* Terminate for S-Function (sg_IO191_di_s): '<Root>/Digital input ' */\n  /* Level2 S-Function Block: '<Root>/Digital input ' (sg_IO191_di_s) */\n  {\n    SimStruct *rts = nCORTEx_M->childSfunctions[2];\n    sfcnTerminate(rts);\n  }\n}\n"},{"name":"nCORTEx.h","type":"header","group":"model","path":"/home/electro/Code_Repo/n-CORTEx/nCORTEx_slrealtime_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * nCORTEx.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"nCORTEx\".\n *\n * Model version              : 1.119\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Oct 12 12:29:21 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_nCORTEx_h_\n#define RTW_HEADER_nCORTEx_h_\n#include <logsrv.h>\n#include \"rtwtypes.h\"\n#include \"simstruc.h\"\n#include \"fixedpoint.h\"\n#include \"verify/verifyIntrf.h\"\n#include \"nCORTEx_types.h\"\n#include <stddef.h>\n#include <cstring>\n#include \"nCORTEx_cal.h\"\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n/* Macros for accessing real-time model data structure */\n#ifndef rtmGetContTimeOutputInconsistentWithStateAtMajorStepFlag\n#define rtmGetContTimeOutputInconsistentWithStateAtMajorStepFlag(rtm) ((rtm)->CTOutputIncnstWithState)\n#endif\n\n#ifndef rtmSetContTimeOutputInconsistentWithStateAtMajorStepFlag\n#define rtmSetContTimeOutputInconsistentWithStateAtMajorStepFlag(rtm, val) ((rtm)->CTOutputIncnstWithState = (val))\n#endif\n\n#ifndef rtmGetDerivCacheNeedsReset\n#define rtmGetDerivCacheNeedsReset(rtm) ((rtm)->derivCacheNeedsReset)\n#endif\n\n#ifndef rtmSetDerivCacheNeedsReset\n#define rtmSetDerivCacheNeedsReset(rtm, val) ((rtm)->derivCacheNeedsReset = (val))\n#endif\n\n#ifndef rtmGetFinalTime\n#define rtmGetFinalTime(rtm)           ((rtm)->Timing.tFinal)\n#endif\n\n#ifndef rtmGetSampleHitArray\n#define rtmGetSampleHitArray(rtm)      ((rtm)->Timing.sampleHitArray)\n#endif\n\n#ifndef rtmGetStepSize\n#define rtmGetStepSize(rtm)            ((rtm)->Timing.stepSize)\n#endif\n\n#ifndef rtmGetZCCacheNeedsReset\n#define rtmGetZCCacheNeedsReset(rtm)   ((rtm)->zCCacheNeedsReset)\n#endif\n\n#ifndef rtmSetZCCacheNeedsReset\n#define rtmSetZCCacheNeedsReset(rtm, val) ((rtm)->zCCacheNeedsReset = (val))\n#endif\n\n#ifndef rtmGet_TimeOfLastOutput\n#define rtmGet_TimeOfLastOutput(rtm)   ((rtm)->Timing.timeOfLastOutput)\n#endif\n\n#ifndef rtmGetErrorStatus\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\n#endif\n\n#ifndef rtmSetErrorStatus\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\n#endif\n\n#ifndef rtmGetStopRequested\n#define rtmGetStopRequested(rtm)       ((rtm)->Timing.stopRequestedFlag)\n#endif\n\n#ifndef rtmSetStopRequested\n#define rtmSetStopRequested(rtm, val)  ((rtm)->Timing.stopRequestedFlag = (val))\n#endif\n\n#ifndef rtmGetStopRequestedPtr\n#define rtmGetStopRequestedPtr(rtm)    (&((rtm)->Timing.stopRequestedFlag))\n#endif\n\n#ifndef rtmGetT\n#define rtmGetT(rtm)                   (rtmGetTPtr((rtm))[0])\n#endif\n\n#ifndef rtmGetTFinal\n#define rtmGetTFinal(rtm)              ((rtm)->Timing.tFinal)\n#endif\n\n#ifndef rtmGetTPtr\n#define rtmGetTPtr(rtm)                ((rtm)->Timing.t)\n#endif\n\n#ifndef rtmGetTStart\n#define rtmGetTStart(rtm)              ((rtm)->Timing.tStart)\n#endif\n\n#ifndef rtmGetTimeOfLastOutput\n#define rtmGetTimeOfLastOutput(rtm)    ((rtm)->Timing.timeOfLastOutput)\n#endif\n\n/* Block signals (default storage) */\nstruct B_nCORTEx_T {\n  real_T whiskCam_trig;                /* '<Root>/Whisker Trig' */\n  real_T npxls_trig;                   /* '<Root>/Npxls Trig' */\n  real_T pupilCam_trig;                /* '<Root>/Pupil Trig' */\n  real_T Memory2;                      /* '<Root>/Memory2' */\n  real_T Memory1;                      /* '<Root>/Memory1' */\n  real_T Memory;                       /* '<Root>/Memory' */\n  real_T Memory3;                      /* '<Root>/Memory3' */\n  real_T Memory4;                      /* '<Root>/Memory4' */\n  real_T Clock;                        /* '<S2>/Clock' */\n  real_T PulseGen1Hz;                  /* '<Root>/Digital input ' */\n  real_T HiddenRateTransitionForToWks_In;\n  /* '<Root>/HiddenRateTransitionForToWks_InsertedFor_TAQSigLogging_InsertedFor_Digital input _at_outport_0_at_inport_0' */\n  real_T tonePulse;                    /* '<S2>/MATLAB Function1' */\n  real_T state_out;                    /* '<Root>/MATLAB Function' */\n  real_T localTime_out;                /* '<Root>/MATLAB Function' */\n  real_T trialNum_out;                 /* '<Root>/MATLAB Function' */\n  real_T onsetTone_trig;               /* '<Root>/MATLAB Function' */\n  real_T npxlsAcq_out;                 /* '<Root>/MATLAB Function' */\n  real_T counter_out;                  /* '<Root>/MATLAB Function' */\n  boolean_T RelationalOperator;        /* '<Root>/Relational Operator' */\n};\n\n/* Block states (default storage) for system '<Root>' */\nstruct DW_nCORTEx_T {\n  real_T Memory2_PreviousInput;        /* '<Root>/Memory2' */\n  real_T Memory1_PreviousInput;        /* '<Root>/Memory1' */\n  real_T Memory_PreviousInput;         /* '<Root>/Memory' */\n  real_T Memory3_PreviousInput;        /* '<Root>/Memory3' */\n  real_T Memory4_PreviousInput;        /* '<Root>/Memory4' */\n  real_T t0;                           /* '<S2>/MATLAB Function1' */\n  real_T Setup_RWORK[2];               /* '<Root>/Setup ' */\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_Whisk;   /* synthesized block */\n\n  void *Setup_PWORK;                   /* '<Root>/Setup ' */\n  void *Digitaloutput_PWORK;           /* '<Root>/Digital output ' */\n  void *Digitalinput_PWORK;            /* '<Root>/Digital input ' */\n  struct {\n    void *LoggedData[5];\n  } Scope_PWORK;                       /* '<Root>/Scope' */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_Digit;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_toneP;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_Pupil;   /* synthesized block */\n\n  struct {\n    void *AQHandles;\n  } TAQSigLogging_InsertedFor_Npxls;   /* synthesized block */\n\n  int32_T clockTickCounter;            /* '<Root>/Whisker Trig' */\n  int32_T clockTickCounter_n;          /* '<Root>/Npxls Trig' */\n  int32_T clockTickCounter_c;          /* '<Root>/Pupil Trig' */\n  int32_T sfEvent;                     /* '<S2>/MATLAB Function1' */\n  int32_T sfEvent_e;                   /* '<Root>/MATLAB Function' */\n  uint8_T is_active_c2_nCORTEx;        /* '<S2>/MATLAB Function1' */\n  uint8_T is_active_c1_nCORTEx;        /* '<Root>/MATLAB Function' */\n  boolean_T doneDoubleBufferReInit;    /* '<S2>/MATLAB Function1' */\n  boolean_T t0_not_empty;              /* '<S2>/MATLAB Function1' */\n  boolean_T doneDoubleBufferReInit_e;  /* '<Root>/MATLAB Function' */\n};\n\n/* Real-time Model Data Structure */\nstruct tag_RTM_nCORTEx_T {\n  struct SimStruct_tag * *childSfunctions;\n  const char_T *errorStatus;\n  SS_SimMode simMode;\n  RTWSolverInfo solverInfo;\n  RTWSolverInfo *solverInfoPtr;\n  void *sfcnInfo;\n\n  /*\n   * NonInlinedSFcns:\n   * The following substructure contains information regarding\n   * non-inlined s-functions used in the model.\n   */\n  struct {\n    RTWSfcnInfo sfcnInfo;\n    time_T *taskTimePtrs[2];\n    SimStruct childSFunctions[3];\n    SimStruct *childSFunctionPtrs[3];\n    struct _ssBlkInfo2 blkInfo2[3];\n    struct _ssSFcnModelMethods2 methods2[3];\n    struct _ssSFcnModelMethods3 methods3[3];\n    struct _ssSFcnModelMethods4 methods4[3];\n    struct _ssStatesInfo2 statesInfo2[3];\n    ssPeriodicStatesInfo periodicStatesInfo[3];\n    struct _ssPortInfo2 inputOutputPortInfo2[3];\n    struct {\n      time_T sfcnPeriod[1];\n      time_T sfcnOffset[1];\n      int_T sfcnTsMap[1];\n      uint_T attribs[9];\n      mxArray *params[9];\n      struct _ssDWorkRecord dWork[2];\n      struct _ssDWorkAuxRecord dWorkAux[2];\n    } Sfcn0;\n\n    struct {\n      time_T sfcnPeriod[1];\n      time_T sfcnOffset[1];\n      int_T sfcnTsMap[1];\n      struct _ssPortInputs inputPortInfo[15];\n      struct _ssInPortUnit inputPortUnits[15];\n      struct _ssInPortCoSimAttribute inputPortCoSimAttribute[15];\n      uint_T attribs[6];\n      mxArray *params[6];\n      struct _ssDWorkRecord dWork[1];\n      struct _ssDWorkAuxRecord dWorkAux[1];\n    } Sfcn1;\n\n    struct {\n      time_T sfcnPeriod[1];\n      time_T sfcnOffset[1];\n      int_T sfcnTsMap[1];\n      struct _ssPortOutputs outputPortInfo[1];\n      struct _ssOutPortUnit outputPortUnits[1];\n      struct _ssOutPortCoSimAttribute outputPortCoSimAttribute[1];\n      uint_T attribs[4];\n      mxArray *params[4];\n      struct _ssDWorkRecord dWork[1];\n      struct _ssDWorkAuxRecord dWorkAux[1];\n    } Sfcn2;\n  } NonInlinedSFcns;\n\n  boolean_T zCCacheNeedsReset;\n  boolean_T derivCacheNeedsReset;\n  boolean_T CTOutputIncnstWithState;\n\n  /*\n   * Sizes:\n   * The following substructure contains sizes information\n   * for many of the model attributes such as inputs, outputs,\n   * dwork, sample times, etc.\n   */\n  struct {\n    uint32_T options;\n    int_T numContStates;\n    int_T numU;\n    int_T numY;\n    int_T numSampTimes;\n    int_T numBlocks;\n    int_T numBlockIO;\n    int_T numBlockPrms;\n    int_T numDwork;\n    int_T numSFcnPrms;\n    int_T numSFcns;\n    int_T numIports;\n    int_T numOports;\n    int_T numNonSampZCs;\n    int_T sysDirFeedThru;\n    int_T rtwGenSfcn;\n  } Sizes;\n\n  /*\n   * Timing:\n   * The following substructure contains information regarding\n   * the timing information for the model.\n   */\n  struct {\n    time_T stepSize;\n    uint32_T clockTick0;\n    uint32_T clockTickH0;\n    time_T stepSize0;\n    uint32_T clockTick1;\n    uint32_T clockTickH1;\n    time_T stepSize1;\n    time_T tStart;\n    time_T tFinal;\n    time_T timeOfLastOutput;\n    SimTimeStep simTimeStep;\n    boolean_T stopRequestedFlag;\n    time_T *sampleTimes;\n    time_T *offsetTimes;\n    int_T *sampleTimeTaskIDPtr;\n    int_T *sampleHits;\n    int_T *perTaskSampleHits;\n    time_T *t;\n    time_T sampleTimesArray[2];\n    time_T offsetTimesArray[2];\n    int_T sampleTimeTaskIDArray[2];\n    int_T sampleHitArray[2];\n    int_T perTaskSampleHitsArray[4];\n    time_T tArray[2];\n  } Timing;\n};\n\n/* Block signals (default storage) */\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern struct B_nCORTEx_T nCORTEx_B;\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n/* Block states (default storage) */\nextern struct DW_nCORTEx_T nCORTEx_DW;\n\n/* External data declarations for dependent source files */\nextern const real_T nCORTEx_RGND;      /* real_T ground */\n\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  /* Model entry point functions */\n  extern void nCORTEx_initialize(void);\n  extern void nCORTEx_step(void);\n  extern void nCORTEx_terminate(void);\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n/* Real-time Model object */\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern RT_MODEL_nCORTEx_T *const nCORTEx_M;\n\n#ifdef __cplusplus\n\n}\n\n#endif\n\n/*-\n * The generated code includes comments that allow you to trace directly\n * back to the appropriate location in the model.  The basic format\n * is <system>/block_name, where system is the system number (uniquely\n * assigned by Simulink) and block_name is the name of the block.\n *\n * Use the MATLAB hilite_system command to trace the generated code back\n * to the model.  For example,\n *\n * hilite_system('<S3>')    - opens system 3\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\n *\n * Here is the system hierarchy for this model\n *\n * '<Root>' : 'nCORTEx'\n * '<S1>'   : 'nCORTEx/MATLAB Function'\n * '<S2>'   : 'nCORTEx/tonePulse'\n * '<S3>'   : 'nCORTEx/tonePulse/MATLAB Function1'\n */\n#endif                                 /* RTW_HEADER_nCORTEx_h_ */\n"},{"name":"nCORTEx_private.h","type":"header","group":"model","path":"/home/electro/Code_Repo/n-CORTEx/nCORTEx_slrealtime_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * nCORTEx_private.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"nCORTEx\".\n *\n * Model version              : 1.119\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Oct 12 12:29:21 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_nCORTEx_private_h_\n#define RTW_HEADER_nCORTEx_private_h_\n#include \"rtwtypes.h\"\n#include \"multiword_types.h\"\n#include \"nCORTEx_types.h\"\n#include \"nCORTEx.h\"\n\n/* Private macros used by the generated code to access rtModel */\n#ifndef rtmIsMajorTimeStep\n#define rtmIsMajorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MAJOR_TIME_STEP)\n#endif\n\n#ifndef rtmIsMinorTimeStep\n#define rtmIsMinorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MINOR_TIME_STEP)\n#endif\n\n#ifndef rtmSetTFinal\n#define rtmSetTFinal(rtm, val)         ((rtm)->Timing.tFinal = (val))\n#endif\n\n#ifndef rtmSetTPtr\n#define rtmSetTPtr(rtm, val)           ((rtm)->Timing.t = (val))\n#endif\n\nextern void* slrtRegisterSignalToLoggingService(uintptr_t sigAddr);\nextern \"C\" void sg_IO191_setup_s(SimStruct *rts);\nextern \"C\" void sg_IO191_do_s(SimStruct *rts);\nextern \"C\" void sg_IO191_di_s(SimStruct *rts);\n\n#endif                                 /* RTW_HEADER_nCORTEx_private_h_ */\n"},{"name":"nCORTEx_types.h","type":"header","group":"model","path":"/home/electro/Code_Repo/n-CORTEx/nCORTEx_slrealtime_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * nCORTEx_types.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"nCORTEx\".\n *\n * Model version              : 1.119\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Oct 12 12:29:21 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_nCORTEx_types_h_\n#define RTW_HEADER_nCORTEx_types_h_\n\n/* Forward declaration for rtModel */\ntypedef struct tag_RTM_nCORTEx_T RT_MODEL_nCORTEx_T;\n\n#endif                                 /* RTW_HEADER_nCORTEx_types_h_ */\n"},{"name":"nCORTEx_cal.cpp","type":"source","group":"data","path":"/home/electro/Code_Repo/n-CORTEx/nCORTEx_slrealtime_rtw","tag":"","groupDisplay":"Data files","code":"#include \"nCORTEx_cal.h\"\n#include \"nCORTEx.h\"\n\n/* Storage class 'PageSwitching' */\nnCORTEx_cal_type nCORTEx_cal_impl = {\n  /* Variable: SampleTime\n   * Referenced by: '<Root>/Constant1'\n   */\n  0.001,\n\n  /* Variable: T_npxls\n   * Referenced by: '<Root>/Npxls Trig'\n   */\n  4.0,\n\n  /* Variable: T_pupil\n   * Referenced by: '<Root>/Pupil Trig'\n   */\n  100.0,\n\n  /* Variable: T_whisk\n   * Referenced by: '<Root>/Whisker Trig'\n   */\n  20.0,\n\n  /* Variable: maxFrames\n   * Referenced by: '<Root>/Constant'\n   */\n  60000.0,\n\n  /* Variable: tStop\n   * Referenced by: '<Root>/Constant2'\n   */\n  60.0,\n\n  /* Expression: 1\n   * Referenced by: '<Root>/Whisker Trig'\n   */\n  1.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Whisker Trig'\n   */\n  0.0,\n\n  /* Expression: 2.5\n   * Referenced by: '<Root>/Npxls Trig'\n   */\n  2.5,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Npxls Trig'\n   */\n  0.0,\n\n  /* Expression: 1\n   * Referenced by: '<Root>/Pupil Trig'\n   */\n  1.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Pupil Trig'\n   */\n  0.0,\n\n  /* Expression: 1\n   * Referenced by: '<Root>/Memory2'\n   */\n  1.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Memory1'\n   */\n  0.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Memory'\n   */\n  0.0,\n\n  /* Expression: 1\n   * Referenced by: '<Root>/Memory3'\n   */\n  1.0,\n\n  /* Expression: 1\n   * Referenced by: '<Root>/Memory4'\n   */\n  1.0,\n\n  /* Computed Parameter: Setup_P1_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parPciSlot\n   * Referenced by: '<Root>/Setup '\n   */\n  -1.0,\n\n  /* Computed Parameter: Setup_P2_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parModuleId\n   * Referenced by: '<Root>/Setup '\n   */\n  1.0,\n\n  /* Computed Parameter: Setup_P3_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parTriggerSignal\n   * Referenced by: '<Root>/Setup '\n   */\n  1.0,\n\n  /* Computed Parameter: Setup_P4_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parAdcChannels\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 2.0 },\n\n  /* Computed Parameter: Setup_P5_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parAdcMode\n   * Referenced by: '<Root>/Setup '\n   */\n  2.0,\n\n  /* Computed Parameter: Setup_P6_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parAdcRanges\n   * Referenced by: '<Root>/Setup '\n   */\n  { 3.0, 3.0 },\n\n  /* Computed Parameter: Setup_P7_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parDacChannels\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 2.0 },\n\n  /* Computed Parameter: Setup_P8_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 2.0 },\n\n  /* Expression: parDacRanges\n   * Referenced by: '<Root>/Setup '\n   */\n  { 4.0, 4.0 },\n\n  /* Computed Parameter: Setup_P9_Size\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 8.0 },\n\n  /* Expression: parDioFirstControl\n   * Referenced by: '<Root>/Setup '\n   */\n  { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 8.0, 9.0 },\n\n  /* Computed Parameter: Digitaloutput_P1_Size\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parModuleId\n   * Referenced by: '<Root>/Digital output '\n   */\n  1.0,\n\n  /* Computed Parameter: Digitaloutput_P2_Size\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parSampleTime\n   * Referenced by: '<Root>/Digital output '\n   */\n  0.001,\n\n  /* Computed Parameter: Digitaloutput_P3_Size\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parPciSlot\n   * Referenced by: '<Root>/Digital output '\n   */\n  -1.0,\n\n  /* Computed Parameter: Digitaloutput_P4_Size\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 15.0 },\n\n  /* Expression: parDoChannels\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 15.0,\n    16.0 },\n\n  /* Computed Parameter: Digitaloutput_P5_Size\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 15.0 },\n\n  /* Expression: parDoInitValues\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },\n\n  /* Computed Parameter: Digitaloutput_P6_Size\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 15.0 },\n\n  /* Expression: parDoResets\n   * Referenced by: '<Root>/Digital output '\n   */\n  { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },\n\n  /* Computed Parameter: Digitalinput_P1_Size\n   * Referenced by: '<Root>/Digital input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parModuleId\n   * Referenced by: '<Root>/Digital input '\n   */\n  1.0,\n\n  /* Computed Parameter: Digitalinput_P2_Size\n   * Referenced by: '<Root>/Digital input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parSampleTime\n   * Referenced by: '<Root>/Digital input '\n   */\n  0.001,\n\n  /* Computed Parameter: Digitalinput_P3_Size\n   * Referenced by: '<Root>/Digital input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parPciSlot\n   * Referenced by: '<Root>/Digital input '\n   */\n  -1.0,\n\n  /* Computed Parameter: Digitalinput_P4_Size\n   * Referenced by: '<Root>/Digital input '\n   */\n  { 1.0, 1.0 },\n\n  /* Expression: parDiChannels\n   * Referenced by: '<Root>/Digital input '\n   */\n  14.0\n};\n\nnCORTEx_cal_type *nCORTEx_cal = &nCORTEx_cal_impl;\n"},{"name":"nCORTEx_cal.h","type":"header","group":"data","path":"/home/electro/Code_Repo/n-CORTEx/nCORTEx_slrealtime_rtw","tag":"","groupDisplay":"Data files","code":"#ifndef RTW_HEADER_nCORTEx_cal_h_\n#define RTW_HEADER_nCORTEx_cal_h_\n#include \"rtwtypes.h\"\n\n/* Storage class 'PageSwitching', for system '<Root>' */\nstruct nCORTEx_cal_type {\n  real_T SampleTime;                   /* Variable: SampleTime\n                                        * Referenced by: '<Root>/Constant1'\n                                        */\n  real_T T_npxls;                      /* Variable: T_npxls\n                                        * Referenced by: '<Root>/Npxls Trig'\n                                        */\n  real_T T_pupil;                      /* Variable: T_pupil\n                                        * Referenced by: '<Root>/Pupil Trig'\n                                        */\n  real_T T_whisk;                      /* Variable: T_whisk\n                                        * Referenced by: '<Root>/Whisker Trig'\n                                        */\n  real_T maxFrames;                    /* Variable: maxFrames\n                                        * Referenced by: '<Root>/Constant'\n                                        */\n  real_T tStop;                        /* Variable: tStop\n                                        * Referenced by: '<Root>/Constant2'\n                                        */\n  real_T WhiskerTrig_Amp;              /* Expression: 1\n                                        * Referenced by: '<Root>/Whisker Trig'\n                                        */\n  real_T WhiskerTrig_PhaseDelay;       /* Expression: 0\n                                        * Referenced by: '<Root>/Whisker Trig'\n                                        */\n  real_T NpxlsTrig_Amp;                /* Expression: 2.5\n                                        * Referenced by: '<Root>/Npxls Trig'\n                                        */\n  real_T NpxlsTrig_PhaseDelay;         /* Expression: 0\n                                        * Referenced by: '<Root>/Npxls Trig'\n                                        */\n  real_T PupilTrig_Amp;                /* Expression: 1\n                                        * Referenced by: '<Root>/Pupil Trig'\n                                        */\n  real_T PupilTrig_PhaseDelay;         /* Expression: 0\n                                        * Referenced by: '<Root>/Pupil Trig'\n                                        */\n  real_T Memory2_InitialCondition;     /* Expression: 1\n                                        * Referenced by: '<Root>/Memory2'\n                                        */\n  real_T Memory1_InitialCondition;     /* Expression: 0\n                                        * Referenced by: '<Root>/Memory1'\n                                        */\n  real_T Memory_InitialCondition;      /* Expression: 0\n                                        * Referenced by: '<Root>/Memory'\n                                        */\n  real_T Memory3_InitialCondition;     /* Expression: 1\n                                        * Referenced by: '<Root>/Memory3'\n                                        */\n  real_T Memory4_InitialCondition;     /* Expression: 1\n                                        * Referenced by: '<Root>/Memory4'\n                                        */\n  real_T Setup_P1_Size[2];             /* Computed Parameter: Setup_P1_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P1;                     /* Expression: parPciSlot\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P2_Size[2];             /* Computed Parameter: Setup_P2_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P2;                     /* Expression: parModuleId\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P3_Size[2];             /* Computed Parameter: Setup_P3_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P3;                     /* Expression: parTriggerSignal\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P4_Size[2];             /* Computed Parameter: Setup_P4_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P4[2];                  /* Expression: parAdcChannels\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P5_Size[2];             /* Computed Parameter: Setup_P5_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P5;                     /* Expression: parAdcMode\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P6_Size[2];             /* Computed Parameter: Setup_P6_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P6[2];                  /* Expression: parAdcRanges\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P7_Size[2];             /* Computed Parameter: Setup_P7_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P7[2];                  /* Expression: parDacChannels\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P8_Size[2];             /* Computed Parameter: Setup_P8_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P8[2];                  /* Expression: parDacRanges\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P9_Size[2];             /* Computed Parameter: Setup_P9_Size\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Setup_P9[8];                  /* Expression: parDioFirstControl\n                                        * Referenced by: '<Root>/Setup '\n                                        */\n  real_T Digitaloutput_P1_Size[2];  /* Computed Parameter: Digitaloutput_P1_Size\n                                     * Referenced by: '<Root>/Digital output '\n                                     */\n  real_T Digitaloutput_P1;             /* Expression: parModuleId\n                                        * Referenced by: '<Root>/Digital output '\n                                        */\n  real_T Digitaloutput_P2_Size[2];  /* Computed Parameter: Digitaloutput_P2_Size\n                                     * Referenced by: '<Root>/Digital output '\n                                     */\n  real_T Digitaloutput_P2;             /* Expression: parSampleTime\n                                        * Referenced by: '<Root>/Digital output '\n                                        */\n  real_T Digitaloutput_P3_Size[2];  /* Computed Parameter: Digitaloutput_P3_Size\n                                     * Referenced by: '<Root>/Digital output '\n                                     */\n  real_T Digitaloutput_P3;             /* Expression: parPciSlot\n                                        * Referenced by: '<Root>/Digital output '\n                                        */\n  real_T Digitaloutput_P4_Size[2];  /* Computed Parameter: Digitaloutput_P4_Size\n                                     * Referenced by: '<Root>/Digital output '\n                                     */\n  real_T Digitaloutput_P4[15];         /* Expression: parDoChannels\n                                        * Referenced by: '<Root>/Digital output '\n                                        */\n  real_T Digitaloutput_P5_Size[2];  /* Computed Parameter: Digitaloutput_P5_Size\n                                     * Referenced by: '<Root>/Digital output '\n                                     */\n  real_T Digitaloutput_P5[15];         /* Expression: parDoInitValues\n                                        * Referenced by: '<Root>/Digital output '\n                                        */\n  real_T Digitaloutput_P6_Size[2];  /* Computed Parameter: Digitaloutput_P6_Size\n                                     * Referenced by: '<Root>/Digital output '\n                                     */\n  real_T Digitaloutput_P6[15];         /* Expression: parDoResets\n                                        * Referenced by: '<Root>/Digital output '\n                                        */\n  real_T Digitalinput_P1_Size[2];    /* Computed Parameter: Digitalinput_P1_Size\n                                      * Referenced by: '<Root>/Digital input '\n                                      */\n  real_T Digitalinput_P1;              /* Expression: parModuleId\n                                        * Referenced by: '<Root>/Digital input '\n                                        */\n  real_T Digitalinput_P2_Size[2];    /* Computed Parameter: Digitalinput_P2_Size\n                                      * Referenced by: '<Root>/Digital input '\n                                      */\n  real_T Digitalinput_P2;              /* Expression: parSampleTime\n                                        * Referenced by: '<Root>/Digital input '\n                                        */\n  real_T Digitalinput_P3_Size[2];    /* Computed Parameter: Digitalinput_P3_Size\n                                      * Referenced by: '<Root>/Digital input '\n                                      */\n  real_T Digitalinput_P3;              /* Expression: parPciSlot\n                                        * Referenced by: '<Root>/Digital input '\n                                        */\n  real_T Digitalinput_P4_Size[2];    /* Computed Parameter: Digitalinput_P4_Size\n                                      * Referenced by: '<Root>/Digital input '\n                                      */\n  real_T Digitalinput_P4;              /* Expression: parDiChannels\n                                        * Referenced by: '<Root>/Digital input '\n                                        */\n};\n\n/* Storage class 'PageSwitching' */\nextern nCORTEx_cal_type nCORTEx_cal_impl;\nextern nCORTEx_cal_type *nCORTEx_cal;\n\n#endif                                 /* RTW_HEADER_nCORTEx_cal_h_ */\n"},{"name":"multiword_types.h","type":"header","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/nCORTEx_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * multiword_types.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"nCORTEx\".\n *\n * Model version              : 1.119\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Oct 12 12:29:21 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef MULTIWORD_TYPES_H\n#define MULTIWORD_TYPES_H\n#include \"rtwtypes.h\"\n\n/*\n * Definitions supporting external data access\n */\ntypedef int64_T chunk_T;\ntypedef uint64_T uchunk_T;\n\n/*\n * MultiWord supporting definitions\n */\ntypedef long long longlong_T;\n\n/*\n * MultiWord types\n */\ntypedef struct {\n  uint64_T chunks[2];\n} int128m_T;\n\ntypedef struct {\n  int128m_T re;\n  int128m_T im;\n} cint128m_T;\n\ntypedef struct {\n  uint64_T chunks[2];\n} uint128m_T;\n\ntypedef struct {\n  uint128m_T re;\n  uint128m_T im;\n} cuint128m_T;\n\ntypedef struct {\n  uint64_T chunks[3];\n} int192m_T;\n\ntypedef struct {\n  int192m_T re;\n  int192m_T im;\n} cint192m_T;\n\ntypedef struct {\n  uint64_T chunks[3];\n} uint192m_T;\n\ntypedef struct {\n  uint192m_T re;\n  uint192m_T im;\n} cuint192m_T;\n\ntypedef struct {\n  uint64_T chunks[4];\n} int256m_T;\n\ntypedef struct {\n  int256m_T re;\n  int256m_T im;\n} cint256m_T;\n\ntypedef struct {\n  uint64_T chunks[4];\n} uint256m_T;\n\ntypedef struct {\n  uint256m_T re;\n  uint256m_T im;\n} cuint256m_T;\n\ntypedef struct {\n  uint64_T chunks[5];\n} int320m_T;\n\ntypedef struct {\n  int320m_T re;\n  int320m_T im;\n} cint320m_T;\n\ntypedef struct {\n  uint64_T chunks[5];\n} uint320m_T;\n\ntypedef struct {\n  uint320m_T re;\n  uint320m_T im;\n} cuint320m_T;\n\ntypedef struct {\n  uint64_T chunks[6];\n} int384m_T;\n\ntypedef struct {\n  int384m_T re;\n  int384m_T im;\n} cint384m_T;\n\ntypedef struct {\n  uint64_T chunks[6];\n} uint384m_T;\n\ntypedef struct {\n  uint384m_T re;\n  uint384m_T im;\n} cuint384m_T;\n\ntypedef struct {\n  uint64_T chunks[7];\n} int448m_T;\n\ntypedef struct {\n  int448m_T re;\n  int448m_T im;\n} cint448m_T;\n\ntypedef struct {\n  uint64_T chunks[7];\n} uint448m_T;\n\ntypedef struct {\n  uint448m_T re;\n  uint448m_T im;\n} cuint448m_T;\n\ntypedef struct {\n  uint64_T chunks[8];\n} int512m_T;\n\ntypedef struct {\n  int512m_T re;\n  int512m_T im;\n} cint512m_T;\n\ntypedef struct {\n  uint64_T chunks[8];\n} uint512m_T;\n\ntypedef struct {\n  uint512m_T re;\n  uint512m_T im;\n} cuint512m_T;\n\ntypedef struct {\n  uint64_T chunks[9];\n} int576m_T;\n\ntypedef struct {\n  int576m_T re;\n  int576m_T im;\n} cint576m_T;\n\ntypedef struct {\n  uint64_T chunks[9];\n} uint576m_T;\n\ntypedef struct {\n  uint576m_T re;\n  uint576m_T im;\n} cuint576m_T;\n\ntypedef struct {\n  uint64_T chunks[10];\n} int640m_T;\n\ntypedef struct {\n  int640m_T re;\n  int640m_T im;\n} cint640m_T;\n\ntypedef struct {\n  uint64_T chunks[10];\n} uint640m_T;\n\ntypedef struct {\n  uint640m_T re;\n  uint640m_T im;\n} cuint640m_T;\n\ntypedef struct {\n  uint64_T chunks[11];\n} int704m_T;\n\ntypedef struct {\n  int704m_T re;\n  int704m_T im;\n} cint704m_T;\n\ntypedef struct {\n  uint64_T chunks[11];\n} uint704m_T;\n\ntypedef struct {\n  uint704m_T re;\n  uint704m_T im;\n} cuint704m_T;\n\ntypedef struct {\n  uint64_T chunks[12];\n} int768m_T;\n\ntypedef struct {\n  int768m_T re;\n  int768m_T im;\n} cint768m_T;\n\ntypedef struct {\n  uint64_T chunks[12];\n} uint768m_T;\n\ntypedef struct {\n  uint768m_T re;\n  uint768m_T im;\n} cuint768m_T;\n\ntypedef struct {\n  uint64_T chunks[13];\n} int832m_T;\n\ntypedef struct {\n  int832m_T re;\n  int832m_T im;\n} cint832m_T;\n\ntypedef struct {\n  uint64_T chunks[13];\n} uint832m_T;\n\ntypedef struct {\n  uint832m_T re;\n  uint832m_T im;\n} cuint832m_T;\n\ntypedef struct {\n  uint64_T chunks[14];\n} int896m_T;\n\ntypedef struct {\n  int896m_T re;\n  int896m_T im;\n} cint896m_T;\n\ntypedef struct {\n  uint64_T chunks[14];\n} uint896m_T;\n\ntypedef struct {\n  uint896m_T re;\n  uint896m_T im;\n} cuint896m_T;\n\ntypedef struct {\n  uint64_T chunks[15];\n} int960m_T;\n\ntypedef struct {\n  int960m_T re;\n  int960m_T im;\n} cint960m_T;\n\ntypedef struct {\n  uint64_T chunks[15];\n} uint960m_T;\n\ntypedef struct {\n  uint960m_T re;\n  uint960m_T im;\n} cuint960m_T;\n\ntypedef struct {\n  uint64_T chunks[16];\n} int1024m_T;\n\ntypedef struct {\n  int1024m_T re;\n  int1024m_T im;\n} cint1024m_T;\n\ntypedef struct {\n  uint64_T chunks[16];\n} uint1024m_T;\n\ntypedef struct {\n  uint1024m_T re;\n  uint1024m_T im;\n} cuint1024m_T;\n\ntypedef struct {\n  uint64_T chunks[17];\n} int1088m_T;\n\ntypedef struct {\n  int1088m_T re;\n  int1088m_T im;\n} cint1088m_T;\n\ntypedef struct {\n  uint64_T chunks[17];\n} uint1088m_T;\n\ntypedef struct {\n  uint1088m_T re;\n  uint1088m_T im;\n} cuint1088m_T;\n\ntypedef struct {\n  uint64_T chunks[18];\n} int1152m_T;\n\ntypedef struct {\n  int1152m_T re;\n  int1152m_T im;\n} cint1152m_T;\n\ntypedef struct {\n  uint64_T chunks[18];\n} uint1152m_T;\n\ntypedef struct {\n  uint1152m_T re;\n  uint1152m_T im;\n} cuint1152m_T;\n\ntypedef struct {\n  uint64_T chunks[19];\n} int1216m_T;\n\ntypedef struct {\n  int1216m_T re;\n  int1216m_T im;\n} cint1216m_T;\n\ntypedef struct {\n  uint64_T chunks[19];\n} uint1216m_T;\n\ntypedef struct {\n  uint1216m_T re;\n  uint1216m_T im;\n} cuint1216m_T;\n\ntypedef struct {\n  uint64_T chunks[20];\n} int1280m_T;\n\ntypedef struct {\n  int1280m_T re;\n  int1280m_T im;\n} cint1280m_T;\n\ntypedef struct {\n  uint64_T chunks[20];\n} uint1280m_T;\n\ntypedef struct {\n  uint1280m_T re;\n  uint1280m_T im;\n} cuint1280m_T;\n\ntypedef struct {\n  uint64_T chunks[21];\n} int1344m_T;\n\ntypedef struct {\n  int1344m_T re;\n  int1344m_T im;\n} cint1344m_T;\n\ntypedef struct {\n  uint64_T chunks[21];\n} uint1344m_T;\n\ntypedef struct {\n  uint1344m_T re;\n  uint1344m_T im;\n} cuint1344m_T;\n\ntypedef struct {\n  uint64_T chunks[22];\n} int1408m_T;\n\ntypedef struct {\n  int1408m_T re;\n  int1408m_T im;\n} cint1408m_T;\n\ntypedef struct {\n  uint64_T chunks[22];\n} uint1408m_T;\n\ntypedef struct {\n  uint1408m_T re;\n  uint1408m_T im;\n} cuint1408m_T;\n\ntypedef struct {\n  uint64_T chunks[23];\n} int1472m_T;\n\ntypedef struct {\n  int1472m_T re;\n  int1472m_T im;\n} cint1472m_T;\n\ntypedef struct {\n  uint64_T chunks[23];\n} uint1472m_T;\n\ntypedef struct {\n  uint1472m_T re;\n  uint1472m_T im;\n} cuint1472m_T;\n\ntypedef struct {\n  uint64_T chunks[24];\n} int1536m_T;\n\ntypedef struct {\n  int1536m_T re;\n  int1536m_T im;\n} cint1536m_T;\n\ntypedef struct {\n  uint64_T chunks[24];\n} uint1536m_T;\n\ntypedef struct {\n  uint1536m_T re;\n  uint1536m_T im;\n} cuint1536m_T;\n\ntypedef struct {\n  uint64_T chunks[25];\n} int1600m_T;\n\ntypedef struct {\n  int1600m_T re;\n  int1600m_T im;\n} cint1600m_T;\n\ntypedef struct {\n  uint64_T chunks[25];\n} uint1600m_T;\n\ntypedef struct {\n  uint1600m_T re;\n  uint1600m_T im;\n} cuint1600m_T;\n\ntypedef struct {\n  uint64_T chunks[26];\n} int1664m_T;\n\ntypedef struct {\n  int1664m_T re;\n  int1664m_T im;\n} cint1664m_T;\n\ntypedef struct {\n  uint64_T chunks[26];\n} uint1664m_T;\n\ntypedef struct {\n  uint1664m_T re;\n  uint1664m_T im;\n} cuint1664m_T;\n\ntypedef struct {\n  uint64_T chunks[27];\n} int1728m_T;\n\ntypedef struct {\n  int1728m_T re;\n  int1728m_T im;\n} cint1728m_T;\n\ntypedef struct {\n  uint64_T chunks[27];\n} uint1728m_T;\n\ntypedef struct {\n  uint1728m_T re;\n  uint1728m_T im;\n} cuint1728m_T;\n\ntypedef struct {\n  uint64_T chunks[28];\n} int1792m_T;\n\ntypedef struct {\n  int1792m_T re;\n  int1792m_T im;\n} cint1792m_T;\n\ntypedef struct {\n  uint64_T chunks[28];\n} uint1792m_T;\n\ntypedef struct {\n  uint1792m_T re;\n  uint1792m_T im;\n} cuint1792m_T;\n\ntypedef struct {\n  uint64_T chunks[29];\n} int1856m_T;\n\ntypedef struct {\n  int1856m_T re;\n  int1856m_T im;\n} cint1856m_T;\n\ntypedef struct {\n  uint64_T chunks[29];\n} uint1856m_T;\n\ntypedef struct {\n  uint1856m_T re;\n  uint1856m_T im;\n} cuint1856m_T;\n\ntypedef struct {\n  uint64_T chunks[30];\n} int1920m_T;\n\ntypedef struct {\n  int1920m_T re;\n  int1920m_T im;\n} cint1920m_T;\n\ntypedef struct {\n  uint64_T chunks[30];\n} uint1920m_T;\n\ntypedef struct {\n  uint1920m_T re;\n  uint1920m_T im;\n} cuint1920m_T;\n\ntypedef struct {\n  uint64_T chunks[31];\n} int1984m_T;\n\ntypedef struct {\n  int1984m_T re;\n  int1984m_T im;\n} cint1984m_T;\n\ntypedef struct {\n  uint64_T chunks[31];\n} uint1984m_T;\n\ntypedef struct {\n  uint1984m_T re;\n  uint1984m_T im;\n} cuint1984m_T;\n\ntypedef struct {\n  uint64_T chunks[32];\n} int2048m_T;\n\ntypedef struct {\n  int2048m_T re;\n  int2048m_T im;\n} cint2048m_T;\n\ntypedef struct {\n  uint64_T chunks[32];\n} uint2048m_T;\n\ntypedef struct {\n  uint2048m_T re;\n  uint2048m_T im;\n} cuint2048m_T;\n\n#endif                                 /* MULTIWORD_TYPES_H */\n"},{"name":"rtGetInf.cpp","type":"source","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/nCORTEx_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetInf.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"nCORTEx\".\n *\n * Model version              : 1.119\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Oct 12 12:29:21 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"rtwtypes.h\"\n\nextern \"C\"\n{\n\n#include \"rtGetInf.h\"\n\n}\n\n#include <stddef.h>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#define NumBitsPerChar                 8U\n\nextern \"C\"\n{\n  /*\n   * Initialize rtInf needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real_T rtGetInf(void)\n  {\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n    real_T inf = 0.0;\n    if (bitsPerReal == 32U) {\n      inf = rtGetInfF();\n    } else {\n      uint16_T one = 1U;\n      enum {\n        LittleEndian,\n        BigEndian\n      } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\n      switch (machByteOrder) {\n       case LittleEndian:\n        {\n          union {\n            LittleEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0x7FF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          inf = tmpVal.fltVal;\n          break;\n        }\n\n       case BigEndian:\n        {\n          union {\n            BigEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0x7FF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          inf = tmpVal.fltVal;\n          break;\n        }\n      }\n    }\n\n    return inf;\n  }\n\n  /*\n   * Initialize rtInfF needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real32_T rtGetInfF(void)\n  {\n    IEEESingle infF;\n    infF.wordL.wordLuint = 0x7F800000U;\n    return infF.wordL.wordLreal;\n  }\n\n  /*\n   * Initialize rtMinusInf needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real_T rtGetMinusInf(void)\n  {\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n    real_T minf = 0.0;\n    if (bitsPerReal == 32U) {\n      minf = rtGetMinusInfF();\n    } else {\n      uint16_T one = 1U;\n      enum {\n        LittleEndian,\n        BigEndian\n      } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\n      switch (machByteOrder) {\n       case LittleEndian:\n        {\n          union {\n            LittleEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0xFFF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          minf = tmpVal.fltVal;\n          break;\n        }\n\n       case BigEndian:\n        {\n          union {\n            BigEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0xFFF00000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          minf = tmpVal.fltVal;\n          break;\n        }\n      }\n    }\n\n    return minf;\n  }\n\n  /*\n   * Initialize rtMinusInfF needed by the generated code.\n   * Inf is initialized as non-signaling. Assumes IEEE.\n   */\n  real32_T rtGetMinusInfF(void)\n  {\n    IEEESingle minfF;\n    minfF.wordL.wordLuint = 0xFF800000U;\n    return minfF.wordL.wordLreal;\n  }\n}\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/nCORTEx_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetInf.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"nCORTEx\".\n *\n * Model version              : 1.119\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Oct 12 12:29:21 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rtGetInf_h_\n#define RTW_HEADER_rtGetInf_h_\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#include \"rtwtypes.h\"\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern real_T rtGetInf(void);\n  extern real32_T rtGetInfF(void);\n  extern real_T rtGetMinusInf(void);\n  extern real32_T rtGetMinusInfF(void);\n\n#ifdef __cplusplus\n\n}                                      /* extern \"C\" */\n\n#endif\n#endif                                 /* RTW_HEADER_rtGetInf_h_ */\n"},{"name":"rtGetNaN.cpp","type":"source","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/nCORTEx_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetNaN.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"nCORTEx\".\n *\n * Model version              : 1.119\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Oct 12 12:29:21 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"rtwtypes.h\"\n\nextern \"C\"\n{\n\n#include \"rtGetNaN.h\"\n\n}\n\n#include <stddef.h>\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#define NumBitsPerChar                 8U\n\nextern \"C\"\n{\n  /*\n   * Initialize rtNaN needed by the generated code.\n   * NaN is initialized as non-signaling. Assumes IEEE.\n   */\n  real_T rtGetNaN(void)\n  {\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n    real_T nan = 0.0;\n    if (bitsPerReal == 32U) {\n      nan = rtGetNaNF();\n    } else {\n      uint16_T one = 1U;\n      enum {\n        LittleEndian,\n        BigEndian\n      } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\n      switch (machByteOrder) {\n       case LittleEndian:\n        {\n          union {\n            LittleEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0xFFF80000U;\n          tmpVal.bitVal.words.wordL = 0x00000000U;\n          nan = tmpVal.fltVal;\n          break;\n        }\n\n       case BigEndian:\n        {\n          union {\n            BigEndianIEEEDouble bitVal;\n            real_T fltVal;\n          } tmpVal;\n\n          tmpVal.bitVal.words.wordH = 0x7FFFFFFFU;\n          tmpVal.bitVal.words.wordL = 0xFFFFFFFFU;\n          nan = tmpVal.fltVal;\n          break;\n        }\n      }\n    }\n\n    return nan;\n  }\n\n  /*\n   * Initialize rtNaNF needed by the generated code.\n   * NaN is initialized as non-signaling. Assumes IEEE.\n   */\n  real32_T rtGetNaNF(void)\n  {\n    IEEESingle nanF = { { 0.0F } };\n\n    uint16_T one = 1U;\n    enum {\n      LittleEndian,\n      BigEndian\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\n    switch (machByteOrder) {\n     case LittleEndian:\n      {\n        nanF.wordL.wordLuint = 0xFFC00000U;\n        break;\n      }\n\n     case BigEndian:\n      {\n        nanF.wordL.wordLuint = 0x7FFFFFFFU;\n        break;\n      }\n    }\n\n    return nanF.wordL.wordLreal;\n  }\n}\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/nCORTEx_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetNaN.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"nCORTEx\".\n *\n * Model version              : 1.119\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Oct 12 12:29:21 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rtGetNaN_h_\n#define RTW_HEADER_rtGetNaN_h_\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#include \"rtwtypes.h\"\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern real_T rtGetNaN(void);\n  extern real32_T rtGetNaNF(void);\n\n#ifdef __cplusplus\n\n}                                      /* extern \"C\" */\n\n#endif\n#endif                                 /* RTW_HEADER_rtGetNaN_h_ */\n"},{"name":"rt_nonfinite.cpp","type":"source","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/nCORTEx_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rt_nonfinite.cpp\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"nCORTEx\".\n *\n * Model version              : 1.119\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Oct 12 12:29:21 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\nextern \"C\"\n{\n\n#include \"rtGetNaN.h\"\n\n}\n\nextern \"C\"\n{\n\n#include \"rtGetInf.h\"\n\n}\n\n#include <stddef.h>\n#include \"rtwtypes.h\"\n\nextern \"C\"\n{\n\n#include \"rt_nonfinite.h\"\n\n}\n\n#define NumBitsPerChar                 8U\n\nextern \"C\"\n{\n  real_T rtInf;\n  real_T rtMinusInf;\n  real_T rtNaN;\n  real32_T rtInfF;\n  real32_T rtMinusInfF;\n  real32_T rtNaNF;\n}\n\nextern \"C\"\n{\n  /*\n   * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\n   * generated code. NaN is initialized as non-signaling. Assumes IEEE.\n   */\n  void rt_InitInfAndNaN(size_t realSize)\n  {\n    (void) (realSize);\n    rtNaN = rtGetNaN();\n    rtNaNF = rtGetNaNF();\n    rtInf = rtGetInf();\n    rtInfF = rtGetInfF();\n    rtMinusInf = rtGetMinusInf();\n    rtMinusInfF = rtGetMinusInfF();\n  }\n\n  /* Test if value is infinite */\n  boolean_T rtIsInf(real_T value)\n  {\n    return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\n  }\n\n  /* Test if single-precision value is infinite */\n  boolean_T rtIsInfF(real32_T value)\n  {\n    return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\n  }\n\n  /* Test if value is not a number */\n  boolean_T rtIsNaN(real_T value)\n  {\n    boolean_T result = (boolean_T) 0;\n    size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n    if (bitsPerReal == 32U) {\n      result = rtIsNaNF((real32_T)value);\n    } else {\n      union {\n        LittleEndianIEEEDouble bitVal;\n        real_T fltVal;\n      } tmpVal;\n\n      tmpVal.fltVal = value;\n      result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) ==\n                           0x7FF00000 &&\n                           ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\n                            (tmpVal.bitVal.words.wordL != 0) ));\n    }\n\n    return result;\n  }\n\n  /* Test if single-precision value is not a number */\n  boolean_T rtIsNaNF(real32_T value)\n  {\n    IEEESingle tmp;\n    tmp.wordL.wordLreal = value;\n    return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\n                       (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\n  }\n}\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/nCORTEx_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rt_nonfinite.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"nCORTEx\".\n *\n * Model version              : 1.119\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Oct 12 12:29:21 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rt_nonfinite_h_\n#define RTW_HEADER_rt_nonfinite_h_\n#include <stddef.h>\n#include \"rtwtypes.h\"\n#define NOT_USING_NONFINITE_LITERALS   1\n#ifdef __cplusplus\n\nextern \"C\"\n{\n\n#endif\n\n  extern real_T rtInf;\n  extern real_T rtMinusInf;\n  extern real_T rtNaN;\n  extern real32_T rtInfF;\n  extern real32_T rtMinusInfF;\n  extern real32_T rtNaNF;\n  extern void rt_InitInfAndNaN(size_t realSize);\n  extern boolean_T rtIsInf(real_T value);\n  extern boolean_T rtIsInfF(real32_T value);\n  extern boolean_T rtIsNaN(real_T value);\n  extern boolean_T rtIsNaNF(real32_T value);\n  struct BigEndianIEEEDouble {\n    struct {\n      uint32_T wordH;\n      uint32_T wordL;\n    } words;\n  };\n\n  struct LittleEndianIEEEDouble {\n    struct {\n      uint32_T wordL;\n      uint32_T wordH;\n    } words;\n  };\n\n  struct IEEESingle {\n    union {\n      real32_T wordLreal;\n      uint32_T wordLuint;\n    } wordL;\n  };\n\n#ifdef __cplusplus\n\n}                                      /* extern \"C\" */\n\n#endif\n#endif                                 /* RTW_HEADER_rt_nonfinite_h_ */\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"/home/electro/Code_Repo/n-CORTEx/nCORTEx_slrealtime_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtwtypes.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"nCORTEx\".\n *\n * Model version              : 1.119\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Oct 12 12:29:21 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTWTYPES_H\n#define RTWTYPES_H\n#include \"tmwtypes.h\"\n#ifndef POINTER_T\n#define POINTER_T\n\ntypedef void * pointer_T;\n\n#endif\n\n/* Logical type definitions */\n#if (!defined(__cplusplus))\n#ifndef false\n#define false                          (0U)\n#endif\n\n#ifndef true\n#define true                           (1U)\n#endif\n#endif\n\n#ifndef INT64_T\n#define INT64_T\n\ntypedef long int64_T;\n\n#define MAX_int64_T                    ((int64_T)(9223372036854775807L))\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807L-1L))\n#endif\n\n#ifndef UINT64_T\n#define UINT64_T\n\ntypedef unsigned long uint64_T;\n\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFUL))\n#endif\n\n/*===========================================================================*\n * Additional complex number type definitions                                           *\n *===========================================================================*/\n#ifndef CINT64_T\n#define CINT64_T\n\ntypedef struct {\n  int64_T re;\n  int64_T im;\n} cint64_T;\n\n#endif\n\n#ifndef CUINT64_T\n#define CUINT64_T\n\ntypedef struct {\n  uint64_T re;\n  uint64_T im;\n} cuint64_T;\n\n#endif\n#endif                                 /* RTWTYPES_H */\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"/home/electro/Code_Repo/n-CORTEx/nCORTEx_slrealtime_rtw","tag":"","groupDisplay":"Interface files","code":"/*\n *  rtmodel.h:\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"nCORTEx\".\n *\n * Model version              : 1.119\n * Simulink Coder version : 9.9 (R2023a) 19-Nov-2022\n * C++ source code generated on : Thu Oct 12 12:29:21 2023\n *\n * Target selection: slrealtime.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_rtmodel_h_\n#define RTW_HEADER_rtmodel_h_\n#include \"nCORTEx.h\"\n#define GRTINTERFACE                   0\n#endif                                 /* RTW_HEADER_rtmodel_h_ */\n"},{"name":"sg_IO191_di_s.c","type":"source","group":"interface","path":"/home/electro/Code_Repo/n-CORTEx/nCORTEx_slrealtime_rtw/../../../.speedgoat/speedgoatlib/R2023a/9.6.1.1_4/sg_blocks/analog","tag":"","groupDisplay":"Interface files","code":"// Copyright 2006-2023 Speedgoat GmbH\r\n\r\n#define S_FUNCTION_LEVEL    (0x490+2482-0xe40)\r\n#undef S_FUNCTION_NAME\r\n#define S_FUNCTION_NAME     sg_IO191_di_s\r\n#include \"sg_IO191.h\"\r\n#ifndef MATLAB_MEX_FILE\r\n#include \"sg_printf.h\"\r\n#include \"sg_common.h\"\r\nvoid readPciBar(sg_PCIDevice*z7c46aa329e,int16_t bus,int16_t slot,int16_t z1e0fd5210f);\r\n#else\r\n#include \"mex.h\"\r\n#endif\r\n#include \"sg_callback.h\"\r\n#define ze13f49a01f           ssGetSFcnParam(S, (0x1759+2617-0x2192))\r\n#define z3832b85a32           ssGetSFcnParam(S, (0x5f8+3193-0x1270))\r\n#define z702a26a5e9                ssGetSFcnParam(S, (0x2c5+4208-0x1333))\r\n#define zb18e38a301           ssGetSFcnParam(S, (0xa61+4466-0x1bd0))\r\n#define zdf24515981                           ((0x16f8+3286-0x23ca))\r\n#define z2e6483d505              ((0x26a+8085-0x21ff))\r\n#define zc5ce4cb81a              ((0x11f5+4924-0x2531))\r\n#define z0194338df7         ((0x3c2+703-0x681))\r\n#define z2b17e2ee3b              ((0x147c+2948-0x1fff))\r\nstatic char msg[z71934bf57c];static void mdlInitializeSizes(SimStruct*S){uint16_t i;ssSetNumSFcnParams(S,zdf24515981);if(ssGetNumSFcnParams(S)!=ssGetSFcnParamsCount(S)){sprintf(msg,\"\\x57\\x72\\x6f\\x6e\\x67\\x20\\x6e\\x75\\x6d\\x62\\x65\\x72\\x20\\x6f\\x66\\x20\\x69\\x6e\\x70\\x75\\x74\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x70\\x61\\x73\\x73\\x65\\x64\\x2e\" \"\\n\" \"\\x25\\x64\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x61\\x72\\x65\\x20\\x65\\x78\\x70\\x65\\x63\\x74\\x65\\x64\" \"\\n\",zdf24515981);ssSetErrorStatus(S,msg);return;}ssSetNumContStates(S,(0xc7b+5592-0x2253));ssSetNumDiscStates(S,(0x1185+3229-0x1e22));if(!ssSetNumInputPorts(S,(0xb62+481-0xd43)))return;if(!ssSetNumOutputPorts(S,(int)mxGetN(zb18e38a301)))return;for(i=(0x1d13+145-0x1da4);i<(int)mxGetN(zb18e38a301);i++){ssSetOutputPortWidth(S,i,(0x486+5466-0x19df));ssSetOutputPortDataType(S,(0x56c+6929-0x207d),SS_DOUBLE);}ssSetNumSampleTimes(S,(0x1a08+2901-0x255c));ssSetNumRWork(S,zc5ce4cb81a);ssSetNumIWork(S,z2e6483d505);ssSetNumPWork(S,z2b17e2ee3b);ssSetNumModes(S,(0x1aad+2738-0x255f));ssSetNumNonsampledZCs(S,(0x1482+3272-0x214a));for(i=(0xd05+5164-0x2131);i<zdf24515981;i++){ssSetSFcnParamTunable(S,i,(0x12db+3246-0x1f89));}ssSetOptions(S,SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME|SS_OPTION_EXCEPTION_FREE_CODE|SS_OPTION_RUNTIME_EXCEPTION_FREE_CODE);}static void mdlInitializeSampleTimes(SimStruct*S){if(mxGetPr(z3832b85a32)[(0x2cd+619-0x538)]==-1.0){ssSetSampleTime(S,(0x136d+3208-0x1ff5),INHERITED_SAMPLE_TIME);ssSetOffsetTime(S,(0x19a0+2894-0x24ee),FIXED_IN_MINOR_STEP_OFFSET);}else{ssSetSampleTime(S,(0x574+6180-0x1d98),mxGetPr(z3832b85a32)[(0x662+3656-0x14aa)]);ssSetOffsetTime(S,(0xbd9+2070-0x13ef),0.0);}ssSetModelReferenceSampleTimeDefaultInheritance(S);}\r\n#ifndef MATLAB_MEX_FILE\r\nstatic void sg_ModelLoad(SimStruct*S){}static void sg_ModelStart(SimStruct*S){sg_PCIDevice zeccbadd9b3;uint32_t bus,slot,za0d38ae598;volatile uint32_t*z27fd94ac66;if(mxGetN(z702a26a5e9)==(0xb62+5554-0x2113)){bus=(0x10ed+5301-0x25a2);slot=(uint32_t)mxGetPr(z702a26a5e9)[(0x874+6135-0x206b)];}else{bus=(uint32_t)mxGetPr(z702a26a5e9)[(0xadd+5988-0x2241)];slot=(uint32_t)mxGetPr(z702a26a5e9)[(0x8cd+1253-0xdb1)];}za0d38ae598=((uint32_t)mxGetPr(ze13f49a01f)[(0x1749+1291-0x1c54)]);if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,za1afbacc4a,z78f5b4c5a6,z2bc00458b9,za0d38ae598,bus,slot)!=(0xf55+4351-0x2054)){if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,zb765876dc5,z44a525e63d,za64fcbac7d,za0d38ae598,bus,slot)!=(0x594+130-0x616)){ssSetErrorStatus(S,pSgErrorStr);return;}}\r\n#ifdef _MSC_BUILD\r\nreadPciBar(&zeccbadd9b3,zeccbadd9b3.bus,zeccbadd9b3.slot,(0x1252+4672-0x2492));\r\n#endif\r\nz27fd94ac66=(volatile uint32_t*)sg_mapMemory(&zeccbadd9b3,(0x189+4706-0x13e9));ssSetPWorkValue(S,z0194338df7,(uint32_t*)z27fd94ac66);}static void sg_ModelStep(SimStruct*S){volatile uint32_t*za42cf7dd4a=ssGetPWorkValue(S,z0194338df7);uint32_t i,input,z4e3026977c;double*y;input=za42cf7dd4a[z52eac5d033];for(i=(0x180b+74-0x1855);i<(uint32_t)mxGetN(zb18e38a301);i++){z4e3026977c=(uint32_t)mxGetPr(zb18e38a301)[i]-(0x2c4+612-0x527);y=ssGetOutputPortSignal(S,i);if(input&((0x2149+672-0x23e8)<<z4e3026977c)){y[(0x1c4c+1042-0x205e)]=(0x60f+1538-0xc10);}else{y[(0xcf3+2372-0x1637)]=(0xc11+4873-0x1f1a);}}}static void sg_ModelStop(SimStruct*S){}\r\n#endif  \r\n#include \"sg_sfcn_glue.h\"   \r\n\r\n"},{"name":"sg_IO191_do_s.c","type":"source","group":"interface","path":"/home/electro/Code_Repo/n-CORTEx/nCORTEx_slrealtime_rtw/../../../.speedgoat/speedgoatlib/R2023a/9.6.1.1_4/sg_blocks/analog","tag":"","groupDisplay":"Interface files","code":"// Copyright 2006-2023 Speedgoat GmbH\r\n\r\n#define S_FUNCTION_LEVEL    (0x5bf+2361-0xef6)\r\n#undef S_FUNCTION_NAME\r\n#define S_FUNCTION_NAME     sg_IO191_do_s\r\n#include \"sg_IO191.h\"\r\n#ifndef MATLAB_MEX_FILE\r\n#include \"sg_printf.h\"\r\n#include \"sg_common.h\"\r\nvoid readPciBar(sg_PCIDevice*z7c46aa329e,int16_t bus,int16_t slot,int16_t z1e0fd5210f);\r\n#else\r\n#include \"mex.h\"\r\n#endif\r\n#include \"sg_callback.h\"\r\n#define ze13f49a01f           ssGetSFcnParam(S, (0x13e0+4526-0x258e))\r\n#define z3832b85a32           ssGetSFcnParam(S, (0x182+5115-0x157c))\r\n#define z702a26a5e9                ssGetSFcnParam(S, (0xc01+464-0xdcf))\r\n#define z5bc3ce0d50           ssGetSFcnParam(S, (0x776+1601-0xdb4))\r\n#define z2d8f240c11           ssGetSFcnParam(S, (0x1772+625-0x19df))\r\n#define z1f9bebb47b             ssGetSFcnParam(S, (0x1683+2315-0x1f89))\r\n#define zdf24515981                           ((0xf52+4685-0x2199))\r\n#define z2e6483d505              ((0x9a8+3518-0x1766))\r\n#define zc5ce4cb81a              ((0x1263+4888-0x257b))\r\n#define z0194338df7         ((0x1786+2885-0x22cb))\r\n#define z2b17e2ee3b              ((0x17e9+3860-0x26fc))\r\n#define THRESHOLD               0.5\r\nstatic char msg[z71934bf57c];static void mdlInitializeSizes(SimStruct*S){uint16_t i;ssSetNumSFcnParams(S,zdf24515981);if(ssGetNumSFcnParams(S)!=ssGetSFcnParamsCount(S)){sprintf(msg,\"\\x57\\x72\\x6f\\x6e\\x67\\x20\\x6e\\x75\\x6d\\x62\\x65\\x72\\x20\\x6f\\x66\\x20\\x69\\x6e\\x70\\x75\\x74\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x70\\x61\\x73\\x73\\x65\\x64\\x2e\" \"\\n\" \"\\x25\\x64\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x61\\x72\\x65\\x20\\x65\\x78\\x70\\x65\\x63\\x74\\x65\\x64\" \"\\n\",zdf24515981);ssSetErrorStatus(S,msg);return;}ssSetNumContStates(S,(0x140a+1006-0x17f8));ssSetNumDiscStates(S,(0x1616+685-0x18c3));if(!ssSetNumOutputPorts(S,(0x13da+1201-0x188b)))return;if(!ssSetNumInputPorts(S,(int)mxGetN(z5bc3ce0d50)))return;for(i=(0x46b+7087-0x201a);i<(int)mxGetN(z5bc3ce0d50);i++){ssSetInputPortWidth(S,i,(0xe05+6052-0x25a8));ssSetInputPortDirectFeedThrough(S,i,(0xed2+5455-0x2420));ssSetInputPortRequiredContiguous(S,i,(0x12af+3337-0x1fb7));}ssSetNumSampleTimes(S,(0x1528+613-0x178c));ssSetNumRWork(S,zc5ce4cb81a);ssSetNumIWork(S,z2e6483d505);ssSetNumPWork(S,z2b17e2ee3b);ssSetNumModes(S,(0x4cd+6065-0x1c7e));ssSetNumNonsampledZCs(S,(0x117a+4372-0x228e));for(i=(0xf68+410-0x1102);i<zdf24515981;i++){ssSetSFcnParamTunable(S,i,(0x3d8+8140-0x23a4));}ssSetOptions(S,SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME|SS_OPTION_EXCEPTION_FREE_CODE|SS_OPTION_RUNTIME_EXCEPTION_FREE_CODE);}static void mdlInitializeSampleTimes(SimStruct*S){if(mxGetPr(z3832b85a32)[(0x9fa+5271-0x1e91)]==-1.0){ssSetSampleTime(S,(0x11bd+334-0x130b),INHERITED_SAMPLE_TIME);ssSetOffsetTime(S,(0x1899+3649-0x26da),FIXED_IN_MINOR_STEP_OFFSET);}else{ssSetSampleTime(S,(0x136d+1483-0x1938),mxGetPr(z3832b85a32)[(0xbe9+1888-0x1349)]);ssSetOffsetTime(S,(0x46+6698-0x1a70),0.0);}ssSetModelReferenceSampleTimeDefaultInheritance(S);}\r\n#ifndef MATLAB_MEX_FILE\r\nstatic void sg_ModelLoad(SimStruct*S){}static void sg_ModelStart(SimStruct*S){sg_PCIDevice zeccbadd9b3;uint32_t zf91d71c6d9=(uint32_t)mxGetN(z5bc3ce0d50);volatile uint32_t*z27fd94ac66;uint32_t bus,slot,za0d38ae598,zcb341ffb0e,i;if(mxGetN(z702a26a5e9)==(0x9d9+408-0xb70)){bus=(0x149+2546-0xb3b);slot=(uint32_t)mxGetPr(z702a26a5e9)[(0x140a+3821-0x22f7)];}else{bus=(uint32_t)mxGetPr(z702a26a5e9)[(0x7c+6885-0x1b61)];slot=(uint32_t)mxGetPr(z702a26a5e9)[(0x3d3+2043-0xbcd)];}za0d38ae598=((uint32_t)mxGetPr(ze13f49a01f)[(0x1799+3688-0x2601)]);if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,za1afbacc4a,z78f5b4c5a6,z2bc00458b9,za0d38ae598,bus,slot)!=(0x662+3015-0x1229)){if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,zb765876dc5,z44a525e63d,za64fcbac7d,za0d38ae598,bus,slot)!=(0x69c+69-0x6e1)){ssSetErrorStatus(S,pSgErrorStr);return;}}\r\n#ifdef _MSC_BUILD\r\nreadPciBar(&zeccbadd9b3,zeccbadd9b3.bus,zeccbadd9b3.slot,(0xe31+1798-0x1537));\r\n#endif\r\nz27fd94ac66=(volatile uint32_t*)sg_mapMemory(&zeccbadd9b3,(0xd58+5538-0x22f8));ssSetPWorkValue(S,z0194338df7,(uint32_t*)z27fd94ac66);zcb341ffb0e=z27fd94ac66[z52eac5d033];for(i=(0xb41+4562-0x1d13);i<zf91d71c6d9;i++){if((int)mxGetPr(z2d8f240c11)[i]>THRESHOLD){zcb341ffb0e|=((0xda2+5684-0x23d5)<<((uint32_t)mxGetPr(z5bc3ce0d50)[i]-(0x157d+4050-0x254e)));}else{zcb341ffb0e&=~((0x2d6+837-0x61a)<<((uint32_t)mxGetPr(z5bc3ce0d50)[i]-(0x153f+221-0x161b)));}}z27fd94ac66[z52eac5d033]=zcb341ffb0e;}static void sg_ModelStep(SimStruct*S){volatile uint32_t*z27fd94ac66=ssGetPWorkValue(S,z0194338df7);uint16_t z344fcf0ef3;uint32_t i,zcb341ffb0e;double output;double*zc7fdaf6331;z344fcf0ef3=(uint16_t)mxGetN(z5bc3ce0d50);zcb341ffb0e=(0x4fa+3413-0x124f);for(i=(0x36+8129-0x1ff7);i<z344fcf0ef3;i++){zc7fdaf6331=(double*)ssGetInputPortRealSignal(S,i);output=zc7fdaf6331[(0x19e1+2812-0x24dd)];if(output>THRESHOLD){zcb341ffb0e|=((0x671+3271-0x1337)<<((uint16_t)mxGetPr(z5bc3ce0d50)[i]-(0xab+1594-0x6e4)));}}z27fd94ac66[z52eac5d033]=zcb341ffb0e;}static void sg_ModelStop(SimStruct*S){volatile uint32_t*z27fd94ac66=ssGetPWorkValue(S,z0194338df7);uint32_t zf91d71c6d9=(uint32_t)mxGetN(z5bc3ce0d50);uint32_t i,zcb341ffb0e;zcb341ffb0e=z27fd94ac66[z52eac5d033];for(i=(0x651+2318-0xf5f);i<zf91d71c6d9;i++){if((int)mxGetPr(z1f9bebb47b)[i]==(0x127d+4999-0x2603)){if((int)mxGetPr(z2d8f240c11)[i]>THRESHOLD){zcb341ffb0e|=((0x11fa+1665-0x187a)<<((uint32_t)mxGetPr(z5bc3ce0d50)[i]-(0x996+7480-0x26cd)));}else{zcb341ffb0e&=~((0x1a70+576-0x1caf)<<((uint32_t)mxGetPr(z5bc3ce0d50)[i]-(0x85f+5265-0x1cef)));}}}z27fd94ac66[z52eac5d033]=zcb341ffb0e;}\r\n#endif  \r\n#include \"sg_sfcn_glue.h\"   \r\n\r\n"},{"name":"sg_IO191_setup_s.c","type":"source","group":"interface","path":"/home/electro/Code_Repo/n-CORTEx/nCORTEx_slrealtime_rtw/../../../.speedgoat/speedgoatlib/R2023a/9.6.1.1_4/sg_blocks/analog","tag":"","groupDisplay":"Interface files","code":"// Copyright 2006-2023 Speedgoat GmbH\r\n\r\n#define S_FUNCTION_LEVEL    (0x10cb+2737-0x1b7a)\r\n#undef S_FUNCTION_NAME\r\n#define S_FUNCTION_NAME     sg_IO191_setup_s\r\n#include \"sg_IO191.h\"\r\n#ifndef MATLAB_MEX_FILE\r\n#include \"sg_printf.h\"\r\n#include \"sg_common.h\"\r\nvoid readPciBar(sg_PCIDevice*z7c46aa329e,int16_t bus,int16_t slot,int16_t z1e0fd5210f);\r\n#else\r\n#include \"mex.h\"\r\n#endif\r\n#include \"sg_callback.h\"\r\n#define z702a26a5e9                ssGetSFcnParam(S, (0x154+6099-0x1927))\r\n#define ze13f49a01f           ssGetSFcnParam(S, (0xaa2+2017-0x1282))\r\n#define z1e0b67709d       ssGetSFcnParam(S, (0x7b7+749-0xaa2))\r\n#define z3644586f49         ssGetSFcnParam(S, (0x1a0c+2186-0x2293))\r\n#define z8d5c288b32         ssGetSFcnParam(S, (0x42b+217-0x500))\r\n#define z9876548c58         ssGetSFcnParam(S, (0xff7+3171-0x1c55))\r\n#define zfa79626a1f        ssGetSFcnParam(S, (0xb19+229-0xbf8))\r\n#define z832477988f        ssGetSFcnParam(S, (0xcbc+1663-0x1334))\r\n#define z4526a8632b         ssGetSFcnParam(S, (0xc27+2227-0x14d2))\r\n#define zdf24515981                           ((0xe83+6110-0x2658))\r\n#define z2e6483d505              ((0x1e94+1092-0x22d8))\r\n#define z8caad2a8e6              ((0x551+1754-0xc2b))\r\n#define z5bfe7a2613            ((0x1341+4557-0x250d))\r\n#define zc5ce4cb81a              ((0x1152+4077-0x213d))\r\n#define z0194338df7         ((0x841+6504-0x21a9))\r\n#define z2b17e2ee3b              ((0x1e5+7568-0x1f74))\r\nstatic char msg[z71934bf57c];static void mdlInitializeSizes(SimStruct*S){uint16_t i;ssSetNumSFcnParams(S,zdf24515981);if(ssGetNumSFcnParams(S)!=ssGetSFcnParamsCount(S)){sprintf(msg,\"\\x57\\x72\\x6f\\x6e\\x67\\x20\\x6e\\x75\\x6d\\x62\\x65\\x72\\x20\\x6f\\x66\\x20\\x69\\x6e\\x70\\x75\\x74\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x70\\x61\\x73\\x73\\x65\\x64\\x2e\" \"\\n\" \"\\x25\\x64\\x20\\x61\\x72\\x67\\x75\\x6d\\x65\\x6e\\x74\\x73\\x20\\x61\\x72\\x65\\x20\\x65\\x78\\x70\\x65\\x63\\x74\\x65\\x64\" \"\\n\",zdf24515981);ssSetErrorStatus(S,msg);return;}ssSetNumContStates(S,(0x2e0+9175-0x26b7));ssSetNumDiscStates(S,(0xa2b+4369-0x1b3c));if(!ssSetNumInputPorts(S,(0x2070+1166-0x24fe)))return;if(!ssSetNumOutputPorts(S,(0x46+573-0x283)))return;ssSetNumSampleTimes(S,(0x16a5+3548-0x2480));ssSetNumRWork(S,zc5ce4cb81a);ssSetNumIWork(S,z2e6483d505);ssSetNumPWork(S,z2b17e2ee3b);ssSetNumModes(S,(0xecd+231-0xfb4));ssSetNumNonsampledZCs(S,(0x147f+2175-0x1cfe));for(i=(0x8c2+6705-0x22f3);i<zdf24515981;i++){ssSetSFcnParamTunable(S,i,(0x72d+7595-0x24d8));}ssSetOptions(S,SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME|SS_OPTION_EXCEPTION_FREE_CODE|SS_OPTION_RUNTIME_EXCEPTION_FREE_CODE|SS_OPTION_PLACE_ASAP);}static void mdlInitializeSampleTimes(SimStruct*S){ssSetSampleTime(S,(0x21b6+431-0x2365),INHERITED_SAMPLE_TIME);ssSetOffsetTime(S,(0xc59+5933-0x2386),FIXED_IN_MINOR_STEP_OFFSET);ssSetModelReferenceSampleTimeDefaultInheritance(S);}\r\n#ifndef MATLAB_MEX_FILE\r\nstatic void sg_ModelLoad(SimStruct*S){}static void sg_ModelStart(SimStruct*S){sg_PCIDevice zeccbadd9b3;uint32_t bus,slot,za0d38ae598,i;uint16_t z4e3026977c,z0e26ef1137;volatile uint32_t*z27fd94ac66;if(mxGetN(z702a26a5e9)==(0x2413+265-0x251b)){bus=(0x1286+3641-0x20bf);slot=(uint32_t)mxGetPr(z702a26a5e9)[(0xb13+5593-0x20ec)];}else{bus=(uint32_t)mxGetPr(z702a26a5e9)[(0x1ea3+159-0x1f42)];slot=(uint32_t)mxGetPr(z702a26a5e9)[(0x9dd+2573-0x13e9)];}za0d38ae598=((uint32_t)mxGetPr(ze13f49a01f)[(0xba+8255-0x20f9)]);if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,za1afbacc4a,z78f5b4c5a6,z2bc00458b9,za0d38ae598,bus,slot)!=(0x1bed+1278-0x20eb)){if(sg_findPciDevice(&zeccbadd9b3,DEVNAME,VENDORID,zb765876dc5,z44a525e63d,za64fcbac7d,za0d38ae598,bus,slot)!=(0x160+861-0x4bd)){ssSetErrorStatus(S,pSgErrorStr);return;}}\r\n#ifdef _MSC_BUILD\r\nreadPciBar(&zeccbadd9b3,zeccbadd9b3.bus,zeccbadd9b3.slot,(0x3bb+8030-0x2319));\r\n#endif\r\nz27fd94ac66=(volatile uint32_t*)sg_mapMemory(&zeccbadd9b3,(0x1017+4953-0x236e));ssSetPWorkValue(S,z0194338df7,(uint32_t*)z27fd94ac66);SG_PRINTF_DEBUG(\"\\x25\\x73\\x3a\\x20\\x46\\x50\\x47\\x41\\x20\\x72\\x65\\x76\\x20\\x30\\x78\\x25\\x58\" \"\\n\",DEVNAME,z27fd94ac66[REVISION]);z0e26ef1137=(0x3d2+7874-0x2294);for(i=(0xf05+2232-0x17bd);i<(uint32_t)mxGetN(z4526a8632b);i++){z4e3026977c=(uint32_t)mxGetPr(z4526a8632b)[i];if(z4e3026977c==(0xdb5+5768-0x243c)){z0e26ef1137=(0x21f3+336-0x2342);}else{z0e26ef1137|=((0xf52+2401-0x18b2)<<(z4e3026977c+(0x145c+4654-0x2684)));}}z27fd94ac66[zef0a03cb9f]=z0e26ef1137;}static void sg_ModelStep(SimStruct*S){}static void sg_ModelStop(SimStruct*S){}\r\n#endif  \r\n#include \"sg_sfcn_glue.h\"   \r\n\r\n"},{"name":"main.cpp","type":"source","group":"legacy","path":"/home/electro/Code_Repo/n-CORTEx/nCORTEx_slrealtime_rtw","tag":"","groupDisplay":"Other files","code":"/* Main generated for Simulink Real-Time model nCORTEx */\n#include <ModelInfo.hpp>\n#include <utilities.hpp>\n#include \"nCORTEx.h\"\n#include \"rte_nCORTEx_parameters.h\"\n\n/* Task descriptors */\nslrealtime::TaskInfo task_1( 0u, std::bind(nCORTEx_step), slrealtime::TaskInfo::PERIODIC, 0.001, 0, 40);\n\n/* Executable base address for XCP */\n#ifdef __linux__\nextern char __executable_start;\nstatic uintptr_t const base_address = reinterpret_cast<uintptr_t>(&__executable_start);\n#else\n/* Set 0 as placeholder, to be parsed later from /proc filesystem */\nstatic uintptr_t const base_address = 0;\n#endif\n\n/* Model descriptor */\nslrealtime::ModelInfo nCORTEx_Info =\n{\n    \"nCORTEx\",\n    nCORTEx_initialize,\n    nCORTEx_terminate,\n    []()->char const*& { return nCORTEx_M->errorStatus; },\n    []()->unsigned char& { return nCORTEx_M->Timing.stopRequestedFlag; },\n    { task_1 },\n    slrealtime::getSegmentVector()\n};\n\nint main(int argc, char *argv[]) {\n    slrealtime::BaseAddress::set(base_address);\n    return slrealtime::runModel(argc, argv, nCORTEx_Info);\n}\n"},{"name":"rt_matrx.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2023a/rtw/c/src","tag":"","groupDisplay":"Other files","code":"/* File    : rt_matrx.c\n * Abstract:\n *      Implements stand alone matrix access and creation routines.\n *\tThere are two types of MATLAB objects which can be \"passed\" to\n *\tthe generated code, a 2D real matrix and a string. Strings are\n *\tpassed as 2D real matrices. The first two elements of an S-function\n *\tparameters are the row and column (m and n) dimensions respectively.\n *\tThese are followed by the matrix data.\n */\n\n\n\n/*\n * Copyright 1994-2022 The MathWorks, Inc.\n */\n\n/*==========*\n * Includes *\n *==========*/\n\n#if defined(MDL_REF_SIM_TGT)\n#undef MATLAB_MEX_FILE\n#endif\n\n#if defined(MATLAB_MEX_FILE)\n# error \"rt_matrix cannot be used within a mex file. It is for codegen only.\"\n#endif\n\n#include <string.h>    /* for strlen */\n#include \"rt_matrx.h\"\n\n#include <stddef.h> /* needed for size_t and NULL */\n#include <float.h>  /* needed for definition of eps */\n\n/*==========*\n * Typedefs *\n *==========*/\n\n#ifndef rt_typedefs_h\n#define rt_typedefs_h\n\n#if !defined(TYPEDEF_MX_ARRAY)\n# define TYPEDEF_MX_ARRAY\n  typedef real_T mxArray;\n#endif\n\ntypedef real_T mxChar;\n\n#if !defined(TMW_NAME_LENGTH_MAX)\n#define TMW_NAME_LENGTH_MAX 64\n#endif\n#define mxMAXNAM  TMW_NAME_LENGTH_MAX\t/* maximum name length */\n\ntypedef enum {\n    mxREAL,\n    mxCOMPLEX\n} mxComplexity;\n\n#endif /* rt_typedefs_h */\n\n/*==================*\n * Extern variables *\n *==================*/\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nextern real_T rtInf;\nextern real_T rtMinusInf;\nextern real_T rtNaN;\n\n#ifdef __cplusplus\n}\n#endif\n\n/*=======================================*\n * Defines for mx Routines and constants *\n *=======================================*/\n\n\n#define mxCalloc(n,size) \\\n        calloc(n,size)\n\n#define mxCreateCharArray(ndim, dims) \\\n        mxCreateNumericArray(ndim, dims, mxCHAR_CLASS);\n\n#define mxDestroyArray(pa) \\\n        if (pa) free(pa)\n\n/* NOTE: You cannot mxFree(mxGetPr(pa)) !!! */\n#define mxFree(ptr) \\\n        if(ptr)free(ptr)\n\n#define mxGetClassID(pa) \\\n        mxDOUBLE_CLASS\n\n/* NOTE: mxGetClassName(pa) returns \"double\" even on a character array */\n#define mxGetClassName(pa) \\\n        \"double\"\n\n#define mxGetData(pa) \\\n        ((void *)(&((pa)[2])))\n\n#define mxGetElementSize(pa) \\\n        (sizeof(real_T))\n\n#define mxGetInf() \\\n        rtInf\n\n#define mxGetM(pa) \\\n        ((size_t) ((pa)[0]))\n#define mxGetN(pa) \\\n        ((size_t) ((pa)[1]))\n\n#define mxGetNaN() \\\n        rtNaN\n\n#define mxGetNumberOfDimensions(pa) \\\n        (2)\n#define mxGetNumberOfElements(pa) \\\n        (mxGetM(pa)*mxGetN(pa))\n\n/* NOTE: mxGetPr() of an empty matrix does NOT return NULL */\n#define mxGetPr(pa) \\\n        ( &((pa)[2]) )\n\n/* NOTE: mxGetDoubles() of an empty matrix does NOT return NULL */\n#define mxGetDoubles(pa) \\\n        ( &((pa)[2]) )\n\n#define mxGetScalar(pa) \\\n        ((pa)[2])\n\n#define mxIsComplex(pa) \\\n        false\n\n#define mxIsDouble(pa) \\\n        true\n\n#define mxIsEmpty(pa) \\\n        (mxGetM(pa)==0 || mxGetN(pa)==0)\n\n#define mxIsFinite(r) \\\n        ((r)>rtMinusInf && (r)<rtInf)\n\n#define mxIsInf(r) \\\n        ((r)==rtInf || (r)==rtMinusInf)\n\n#define mxIsInt16(pa) \\\n        false\n\n#define mxIsInt32(pa) \\\n        false\n\n#define mxIsInt8(pa) \\\n        false\n\n#define mxIsLogical(pa) \\\n        false\n\n#define mxIsNumeric(pa) \\\n        true\n\n#define mxIsSingle(pa) \\\n        false\n\n#define mxIsSparse(pa) \\\n        false\n\n#define mxIsStruct(pa) \\\n        false\n\n#define mxIsUint16(pa) \\\n        false\n\n#define mxIsUint32(pa) \\\n        false\n\n#define mxIsUint8(pa) \\\n        false\n\n#define mxMalloc(n) \\\n        malloc(n)\n\n#define mxRealloc(p,n) \\\n        realloc(p,n)\n\n/*==============*\n * Local macros *\n *==============*/\n#define _mxSetM(pa,m) \\\n        (pa)[0] = ((int)(m))\n\n#define _mxSetN(pa,n) \\\n        (pa)[1] = ((int)(n))\n\n\n/*==========================*\n * Visible/extern functions *\n *=========================*/\n\n/* Function: mxCreateCharMatrixFromStrings ====================================\n * Abstract:\n *\tCreate a string array initialized to the strings in str.\n */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nmxArray *rt_mxCreateCharMatrixFromStrings(int_T m, const char_T **str)\n{\n    int_T nchars;\n    int_T i, n;\n    mxArray *pa;\n\n    n = 0;\n    for (i = 0; i < m; ++i) {\n\tnchars = (int_T)strlen(str[i]);\n\tif (nchars > n) {\n\t    n = nchars;\n\t}\n    }\n\n    pa = (mxArray *)malloc((m*n+2)*sizeof(real_T));\n    if(pa!=NULL) {\n\tmxChar *chars;\n\tint_T  j;\n\t_mxSetM(pa, m);\n\t_mxSetN(pa, n);\n\tchars = mxGetPr(pa);\n\tfor (j = 0; j < m; ++j) {\n\t    const char_T *src  = str[j];\n\t    mxChar *dest = chars + j;\n\n\t    nchars = (int_T)strlen(src);\n\t    i = nchars;\n\t    while (i--) {\n\t\t*dest = *src++;\n\t\t dest += m;\n\t    }\n\t    i = n - nchars;\n\t    while (i--) {\n\t\t*dest = 0.0;\n\t\tdest += m;\n\t    }\n\t}\n    }\n    return pa;\n} /* end mxCreateCharMatrixFromStrings */\n\n#ifdef __cplusplus\n}\n#endif\n\n/* Function: mxCreateString ===================================================\n * Abstract:\n *\tCreate a 1-by-n string array initialized to null terminated string\n *\twhere n is the length of the string.\n */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nmxArray *rt_mxCreateString(const char *str)\n{\n    int_T   len = (int_T)strlen(str);\n\n    mxArray *pa = (mxArray *)malloc((len+2)*sizeof(real_T));\n\n    if(pa!=NULL) {\n\treal_T *pr;\n\tconst unsigned char *ustr_ptr = (const unsigned char *) str;\n\n\t_mxSetM(pa, 1);\n\t_mxSetN(pa, len);\n\tpr = mxGetPr(pa);\n\twhile (len--) {\n            *pr++ = (real_T)*ustr_ptr++;\n        }\n    }\n    return(pa);\n\n} /* end mxCreateString */\n\n#ifdef __cplusplus\n}\n#endif\n\n/* Function: mxCreateDoubleMatrix =============================================\n * Abstract:\n *\tCreate a two-dimensional array to hold real_T data,\n *\tinitialize each data element to 0.\n */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nmxArray *rt_mxCreateDoubleMatrix(int m, int n, mxComplexity flag)\n{\n    if (flag == mxREAL) {\n        mxArray *pa = (mxArray *)calloc(m*n+2, sizeof(real_T));\n        if(pa!=NULL) {\n            _mxSetM(pa, m);\n            _mxSetN(pa, n);\n        }\n        return(pa);\n    } else {\n        return(NULL);\n    }\n\n} /* end mxCreateDoubleMatrix */\n\n#ifdef __cplusplus\n}\n#endif\n\n/* Function: mxCreateNumericArray =============================================\n * Abstract:\n *\tCreate a numeric array and initialize all its data elements to 0.\n */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nmxArray *rt_mxCreateNumericArray(int_T ndims, const mwSize *dims, \n                                        mxClassID classid, mxComplexity flag)\n{\n    if (ndims == 2 && classid==mxDOUBLE_CLASS) {\n        return(rt_mxCreateDoubleMatrix((int)(dims[0]), (int)(dims[1]), flag));\n    } else {\n        return(NULL);\n    }\n\n} /* end mxCreateNumericArray */\n\n#ifdef __cplusplus\n}\n#endif\n\n/* Function: mxDuplicateArray =================================================\n * Abstract:\n *\tMake a deep copy of an array, return a pointer to the copy.\n */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nmxArray *rt_mxDuplicateArray(const mxArray *pa)\n{\n\n    size_t   nbytes = (mxGetNumberOfElements(pa)+2)*mxGetElementSize(pa);\n    mxArray *pcopy = (mxArray *)malloc(nbytes);\n\n    if (pcopy!=NULL) {\n\t(void)memcpy(pcopy, pa, nbytes);\n    }\n    return(pcopy);\n\n} /* end mxDuplicateArray */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n/* Function: mxGetDimensions ==================================================\n * Abstract:\n *\tGet pointer to dimension array\n */\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nconst mwSize *rt_mxGetDimensions(const mxArray *pa)\n{\n    static mwSize dims[2];\n    dims[0] = mxGetM(pa);\n    dims[1] = mxGetN(pa);\n    return dims;\n} /* end mxGetDimensions */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n/* Function: mxGetEps =========================================================\n * Abstract:\n *\tReturn eps, the difference between 1.0 and the least value\n *\tgreater than 1.0 that is representable as a real_T.\n */\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nreal_T rt_mxGetEps(void)\n{\n    return (sizeof(double)==sizeof(real_T)) ? DBL_EPSILON : FLT_EPSILON;\n}\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n/* Function: mxGetString ======================================================\n * Abstract:\n *\tConverts a string array to a C-style string.\n */\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nint_T rt_mxGetString(const mxArray *pa, char_T *buf, int_T buflen)\n{\n    int_T        nchars;\n    const real_T *pr;\n    char_T       *pc;\n    int_T        truncate = 0;\n\n    nchars = (int_T)mxGetNumberOfElements(pa);\n    if (nchars >= buflen) {\n\t/* leave room for null byte */\n\tnchars = buflen - 1;\n\ttruncate = 1;\n    }\n    pc = buf;\n    pr = mxGetPr(pa);\n    while (nchars--) {\n\t*pc++ = (char) (*pr++ + .5);\n    }\n    *pc = '\\0';\n    return truncate;\n} /* end mxGetString */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n#define mxCreateCharMatrixFromStrings(m, str) \\\n        rt_mxCreateCharMatrixFromStrings(m, str)\n\n#define mxCreateString(str) \\\n        rt_mxCreateString(str) \n\n#define mxCreateDoubleMatrix(m, n, flag) \\\n        rt_mxCreateDoubleMatrix(m, n, flag)\n\n#define mxCreateNumericArray(ndims, dims, classid, flag) \\\n        rt_mxCreateNumericArray(ndims, dims, classid, flag)\n\n#define mxDuplicateArray(pa) \\\n        rt_mxDuplicateArray(pa)\n\n#define mxGetDimensions(pa) \\\n        rt_mxGetDimensions(pa)\n\n#define mxGetEps() \\\n        rt_mxGetEps()\n\n#define mxGetString(pa, buf, buflen) \\\n        rt_mxGetString(pa, buf, buflen)\n\n/*=========================*\n * Unsupported mx Routines *\n *=========================*/\n\n#define mxCalcSingleSubscript(pa,nsubs,subs) \\\n        mxCalcSingleSubscript_is_not_supported_in_Simulink_Coder\n\n#define mxCreateCellArray(ndim,dims) \\\n        mxCreateCellArray_is_not_supported_in_Simulink_Coder\n\n#define mxCreateCellMatrix(m,n) \\\n        mxCreateCellMatrix_is_not_supported_in_Simulink_Coder\n\n#define mxCreateSparse(pm,pn,pnzmax,pcmplx_flg) \\\n        mxCreateSparse_is_not_supported_in_Simulink_Coder\n\n#define mxCreateStructArray(ndim,dims,nfields,fieldnames) \\\n        mxCreateStructArray_is_not_supported_in_Simulink_Coder\n\n#define mxCreateStructMatrix(m,n,nfields,fieldnames) \\\n        mxCreateStructMatrix_is_not_supported_in_Simulink_Coder\n\n#define mxGetCell(pa,i) \\\n        mxGetCell_is_not_supported_in_Simulink_Coder\n\n#define mxGetField(pa,i,fieldname) \\\n        mxGetField_is_not_supported_in_Simulink_Coder\n\n#define mxGetFieldByNumber(s,i,fieldnum) \\\n        mxGetFieldByNumber_is_not_supported_in_Simulink_Coder\n\n#define mxGetFieldNameByNumber(pa,n) \\\n        mxGetFieldNameByNumber_is_not_supported_in_Simulink_Coder\n\n#define mxGetFieldNumber(pa,fieldname) \\\n        mxGetFieldNumber_is_not_supported_in_Simulink_Coder\n\n#define mxGetImagData(pa) \\\n        mxGetImagData_is_not_supported_in_Simulink_Coder\n\n#define mxGetIr(ppa) \\\n        mxGetIr_is_not_supported_in_Simulink_Coder\n\n#define mxGetJc(ppa) \\\n        mxGetJc_is_not_supported_in_Simulink_Coder\n\n#define mxGetNumberOfFields(pa) \\\n        mxGetNumberOfFields_is_not_supported_in_Simulink_Coder\n\n#define mxGetNzmax(pa) \\\n        mxGetNzmax_is_not_supported_in_Simulink_Coder\n\n#define mxGetPi(pa) \\\n        mxGetPi_is_not_supported_in_Simulink_Coder\n\n#define mxIsFromGlobalWS(pa) \\\n        mxIsFromGlobalWS_is_not_supported_in_Simulink_Coder\n\n#define mxIsNaN(r) \\\n        mxIsNaN_is_not_supported_in_Simulink_Coder\n\n#define mxIsChar(pa) \\\n        mxIsChar_is_not_supported_in_Simulink_Coder\n\n#define mxIsClass(pa,class) \\\n        mxIsClass_is_not_supported_in_Simulink_Coder\n\n#define mxIsCell(pa) \\\n        mxIsCell_is_not_supported_in_Simulink_Coder\n\n#define mxSetCell(pa,i,value) \\\n        mxSetCell_is_not_supported_in_Simulink_Coder\n\n#define mxSetClassName(pa,classname) \\\n        mxSetClassName_is_not_supported_in_Simulink_Coder\n\n#define mxSetData(pa,pr) \\\n        mxSetData_is_not_supported_in_Simulink_Coder\n\n#define mxSetDimensions(pa, size, ndims) \\\n        mxSetDimensions_is_not_supported_in_Simulink_Coder\n\n#define mxSetField(pa,i,fieldname,value) \\\n        mxSetField_is_not_supported_in_Simulink_Coder\n\n#define mxSetFieldByNumber(pa, index, fieldnum, value) \\\n        mxSetFieldByNumber_is_not_supported_in_Simulink_Coder\n\n#define mxSetFromGlobalWS(pa,global) \\\n        mxSetFromGlobalWS_is_not_supported_in_Simulink_Coder\n\n#define mxSetImagData(pa,pv) \\\n        mxSetImagData_is_not_supported_in_Simulink_Coder\n\n#define mxSetIr(ppa,ir) \\\n        mxSetIr_is_not_supported_in_Simulink_Coder\n\n#define mxSetJc(ppa,jc) \\\n        mxSetJc_is_not_supported_in_Simulink_Coder\n\n#define mxSetM(pa, m) \\\n        mxSetM_is_not_supported_in_Simulink_Coder\n\n#define mxSetN(pa, m) \\\n        mxSetN_is_not_supported_in_Simulink_Coder\n\n#define mxSetPr(pa,pr) \\\n        mxSetPr_is_not_supported_in_Simulink_Coder\n\n#define mxSetNzmax(pa,nzmax) \\\n        mxSetNzmax_is_not_supported_in_Simulink_Coder\n\n#define mxSetPi(pa,pv) \\\n        mxSetPi_is_not_supported_in_Simulink_Coder\n\n\n\n/*==========================*\n * Unsupported mex routines *\n *==========================*/\n\n#define mexPrintAssertion(test,fname,linenum,message) \\\n        mexPrintAssertion_is_not_supported_by_Simulink_Coder\n\n#define mexEvalString(str) \\\n        mexEvalString_is_not_supported_by_Simulink_Coder\n\n#define mexErrMsgTxt(str) \\\n        mexErrMsgTxt_is_not_supported_by_Simulink_Coder\n\n#define mexWarnMsgTxt(warning_msg) \\\n        mexWarnMsgTxt_is_not_supported_by_Simulink_Coder\n\n#define mexPrintf \\\n        mexPrintf_is_not_supported_by_Simulink_Coder\n\n#define mexMakeArrayPersistent(pa) \\\n        mexMakeArrayPersistent_is_not_supported_by_Simulink_Coder\n\n#define mexMakeMemoryPersistent(ptr) \\\n        mexMakeMemoryPersistent_is_not_supported_by_Simulink_Coder\n\n#define mexLock() \\\n        mexLock_is_not_supported_by_Simulink_Coder\n\n#define mexUnlock() \\\n        mexUnlock_is_not_supported_by_Simulink_Coder\n\n#define mexFunctionName() \\\n        mexFunctionName_is_not_supported_by_Simulink_Coder\n\n#define mexIsLocked() \\\n        mexIsLocked_is_not_supported_by_Simulink_Coder\n\n#define mexGetFunctionHandle() \\\n        mexGetFunctionHandle_is_not_supported_by_Simulink_Coder\n\n#define mexCallMATLABFunction() \\\n        mexCallMATLABFunction_is_not_supported_by_Simulink_Coder\n\n#define mexRegisterFunction() \\\n        mexRegisterFunction_is_not_supported_by_Simulink_Coder\n\n#define mexSet(handle,property,value) \\\n        mexSet_is_not_supported_by_Simulink_Coder\n\n#define mexGet(handle,property) \\\n        mexGet_is_not_supported_by_Simulink_Coder\n\n#define mexCallMATLAB(nlhs,plhs,nrhs,prhs,fcn) \\\n        mexCallMATLAB_is_not_supported_by_Simulink_Coder\n\n#define mexSetTrapFlag(flag) \\\n        mexSetTrapFlag_is_not_supported_by_Simulink_Coder\n\n#define mexUnlink(a) \\\n        mexUnlink_is_not_supported_by_Simulink_Coderw\n\n#define mexSubsAssign(plhs,sub,nsubs,prhs) \\\n        mexSubsAssign_is_not_supported_by_Simulink_Coder\n\n#define mexSubsReference(prhs,subs,nsubs) \\\n        mexSubsReference_is_not_supported_by_Simulink_Coder\n\n#define mexPrintAssertion(test,fname,linenum,message) \\\n        mexPrintAssertion_is_not_supported_by_Simulink_Coder\n\n#define mexAddFlops(count) \\\n        mexAddFlops_is_not_supported_by_Simulink_Coder\n\n#define mexIsGlobal(pa) \\\n        mexIsGlobal_is_not_supported_by_Simulink_Coder\n\n#define mexAtExit(fcn) \\\n        mexAtExit_is_not_supported_by_Simulink_Coder\n\n/* [EOF] rt_matrx.c */\n"},{"name":"rt_printf.c","type":"source","group":"legacy","path":"/usr/local/MATLAB/R2023a/rtw/c/src","tag":"","groupDisplay":"Other files","code":"/* Copyright 1994-2015 The MathWorks, Inc.\n *\n * File: rt_printf.c\n *\n * Abstract:\n *      Stub I/O printf facility for systems which don't have stdio.\n *\n */\n\n\n\n/* Function: rtPrintfNoOp ======================================================\n * Abstract:\n *      Maps ssPrintf to rtPrintfNoOp if HAVESTDIO is not defined (see\n *      simstruct.h\n */\nint rtPrintfNoOp(const char *fmt, ...)\n{\n    /* do nothing */\n    return(fmt == (const char *)0); /* use fmt to quiet unused var warning */\n}\n\n\n/* [eof] rt_printf.c */\n"},{"name":"rte_nCORTEx_parameters.cpp","type":"source","group":"legacy","path":"/home/electro/Code_Repo/n-CORTEx/nCORTEx_slrealtime_rtw","tag":"","groupDisplay":"Other files","code":"#include \"rte_nCORTEx_parameters.h\"\n#include \"nCORTEx.h\"\n#include \"nCORTEx_cal.h\"\n\nextern nCORTEx_cal_type nCORTEx_cal_impl;\nnamespace slrealtime\n{\n  /* Description of SEGMENTS */\n  SegmentVector segmentInfo {\n    { (void*)&nCORTEx_cal_impl, (void**)&nCORTEx_cal, sizeof(nCORTEx_cal_type),\n      2 }\n  };\n\n  SegmentVector &getSegmentVector(void)\n  {\n    return segmentInfo;\n  }\n}                                      // slrealtime\n"},{"name":"rte_nCORTEx_parameters.h","type":"header","group":"other","path":"/home/electro/Code_Repo/n-CORTEx/nCORTEx_slrealtime_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef _RTE_NCORTEX_PARAMETERS_H\n#define _RTE_NCORTEX_PARAMETERS_H\n#include \"rtwtypes.h\"\n#include \"SegmentInfo.hpp\"\n\nnamespace slrealtime\n{\n  SegmentVector &getSegmentVector(void);\n}                                      // slrealtime\n\n#endif\n"},{"name":"slrealtime_datatype_ground.cpp","type":"source","group":"legacy","path":"/home/electro/Code_Repo/n-CORTEx/nCORTEx_slrealtime_rtw","tag":"","groupDisplay":"Other files","code":"#include \"slrtdatatypes.h\"\n\nconst serialfifoptr serialfifoground = { 0, 0, 0 };\n\nconst bcmsglist1553 bcmsg1553ground = { 0, 0, 0, 0 };\n\nconst bcstatus1553 bcstatground = { 0, 0, 0, 0, 0, 0 };\n\nconst bmmsglist1553 bmmsg1553ground = { 0, 0, 0, 0 };\n"}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true}};